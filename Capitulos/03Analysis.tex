%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------

\chapter{Análisis}

\begin{FraseCelebre}
\begin{Frase}
Sólo sé que no se nada y, al saber que no sé nada, algo sé; porque sé que no sé nada
\end{Frase}
\begin{Fuente}
Sócrates de Atenas {\sc\scriptsize a través de Ale Gallardo}
\end{Fuente}
\end{FraseCelebre}

\begin{resumen}
En este capítulo se realiza un estudio previo de la plataforma \android{} y de las diferentes interfaces de comunicación de interés. Por último se analiza la viabilidad de implementar características cognitivas en \sphone{s}.
\end{resumen}


%-------------------------------------------------------------------
\section{Plataformas Móviles: Android}
\label{sec:android}
%-------------------------------------------------------------------

La plataforma móvil que hemos elegido para la implementación de la arquitectura cognitiva es \android{}. Esta elección está motivada por los siguientes motivos:
\begin{itemize}
	\item \textbf{Código libre}: como hemos visto en el capítulo anterior, la \ac{CN} requiere de una capa \ac{SAN} subyacente que permita modificar parámetros de comunicación, muchas veces restringidos y ocultados a los niveles superiores. El tener la posibilidad de poder hacer una modificación en el código del sistema operativo, recompilarlo y poder cargarlo en un dispositivo, hace que este aspecto no sea una pared insalvable para el proyecto. Supone un riesgo moderado, pues los conocimientos necesarios para conseguir hacer esas modificaciones son bastantes altos.

\item \textbf{Madurez}: \android{} es una de las plataformas móviles más ``antiguas'' entre las listadas en la sección~\ref{sec:mobilePlatforms}. Con el paso del tiempo la estabilidad y funcionalidad de la plataforma se incrementa al igual que lo hace la comunidad de desarrolladores y la documentación disponible, facilitando el desarrollo de aplicaciones. La plataforma anunció en noviembre de 2014 el lanzamiento de la versión 5.0 - Lollipop que corresponde con la versión vigésima primera de la \ac{API} del sistema.

\item \textbf{Cuota de mercado}: otro factor importante es la
  penetración de la tecnología en la sociedad. %XXX-jblesa me falta un
                                %nexo aquí
Es relevante %XXX-cvillar es relevante, funciona como nexo?
por dos motivos: uno para poder recrear una \ac{CN} en la que se necesita la participación de muchos nodos y el segundo responde a que cuanto más extendido está una plataforma, más modificaciones y oportunidades aparecen.

\end{itemize}

\subsection{Fundamentos de una aplicación}
En \android{} las aplicaciones se escriben en lenguaje \java{} que gracias a las herramientas del \ac{SDK}, se compilan encapsulando en un solo archivo (\texttt{.apk}) tanto el código como archivos de datos o recursos como lo son las imágenes. Este archivo único contiene un espacio de nombres exclusivo, el cual puede ser referenciado desde otras aplicaciones para la invocación de componentes concretos. \android{} es un sistema multiusuario donde cada aplicación es un usuario diferente, ejecutándose cada una de ellas en su propio espacio. Cada aplicación es aislada del resto al ser ejecutada en una instancia distinta de la máquina virtual y ser tratada como un proceso de \linux{} diferente~\cite{andProcess}. Se implementa por tanto el principio del mínimo privilegio que consiste en que por defecto, cada aplicación sólo tiene acceso a los componentes que requiere y no a otros. Esto crea un entorno bastante seguro. No obstante, cada aplicación puede pedir el acceso al resto de recursos del sistema mediante la aceptación de unos permisos, los cuales se informan en el momento de la instalación. También es posible que dos aplicaciones se ejecuten en el mismo proceso al compartir el identificador del usuario \linux{} que sólo es conocido por el sistema y no por las aplicaciones en cuestión. Para ello las aplicaciones tienen que estar firmadas bajo el mismo certificado.

\figura{Bitmap/analysis/android-arch}{width=.76\textwidth}{fig:android-arch}{Arquitectura global de \android{} obtenido de \cite{andArchitecture}}

En la figura~\ref{fig:android-arch} vemos que el sistema se apoya sobre el núcleo de Linux, dependiendo del dispositivo las versiones de éste oscilan desde la 2.6 hasta la versión 3.10 al igual que los distintos componentes para adecuarse al \textit{hardware}. Sobre este núcleo se construyen unas librerías escritas tanto en C como C++ que completan las funciones básicas de los módulos y componentes. Se une con el resto de la arquitectura gracias a la interfaz \ac{JNI} que permite ejecutar métodos nativos escritos en otros lenguajes y así permitir que la máquina virtual de \java{} interactúe con los programas del núcleo y las librerías. 

El resto de la arquitectura la componen los componentes de manejan las aplicaciones ubicadas en el \textit{System Server}, las demás librerías necesarias para \android{} y la implementación de \java{} libre (Apache Harmony, proyecto descontinuado a finales de 2011). La comunicación entre estos procesos se realiza con un objeto \textit{Binder}. 

Por último la arquitectura se corona con las aplicaciones tanto del sistema como desarrolladas por terceros. Como veremos hay ciertas aplicaciones que tienen acceso a zonas y funciones del sistema que no son accesibles desde la \ac{API}, ni están contempladas por la aceptación de permisos de cara al usuario. Para llevar a cabo este propósito, estas aplicaciones se instalan además, en una partición especial y se ejecutan en procesos cuyo usuario tiene más privilegios que un usuario destinado a una aplicación sin más. La comunicación entre las aplicaciones y la arquitectura se produce gracias a la \ac{API} que publica el sistema.\\

Las aplicaciones se estructuran y se componen de los siguientes componentes:
\subsubsection{Activity}
Este componente que podríamos traducir como actividad, representa una parte de la interfaz gráfica que consiste en una única pantalla de interacción con el usuario. Una aplicación proporciona tantas actividades como sea necesario que son encadenadas para construir el flujo de trabajo de ésta. Aunque estas actividades trabajan juntas y comparten datos para lograr una experiencia de usuario óptima, cada una de ellas es independiente, es más, pueden ser iniciadas desde cualquier otro punto de la misma aplicación u otra si se habilita para ello.

Cada vez que se inicia una actividad se para la actividad anterior, el sistema conserva esta actividad en una cola \ac{LIFO}, es decir que cuando un usuario presiona el botón \bsq{atrás} se recupera la actividad que se pausó en último lugar. Las actividades, al igual que los otros componentes, siguen un ciclo de vida propio que es manejado por el sistema que llama a ciertos métodos de ésta para informar de su estado actual.

\figura{Bitmap/analysis/activity-lifecycle}{width=.76\textwidth}{fig:activity-lifecycle}{Ciclo de vida de una actividad en \android{} extraído de \cite{andActivity}}

En la figura~\ref{fig:activity-lifecycle}, vemos los métodos que son llamados por el sistema. Cuando una aplicación se crea el sistema llama al método \textit{onCreate()} de la actividad. En él debemos inicializar los componentes de ésta tales como su interfaz gráfica. Justo antes de que la actividad torne por primera vez en la pantalla del dispositivo, o cuando ha estado en el estado de parada, se llama al método \textit{onStart()}. En las sucesivas veces que la actividad vuelva a la pantalla del dispositivo se ejecutará \textit{onResume()} que puede ser utilizado para recuperar la información que tuviera antes de perder el foco del usuario. Cuando otra actividad coja la atención del usuario nuestra actividad será pausada con \textit{onPause()} y cuando no sea visible en pantalla el sistema llamará a \textit{onStop()}. En este estado la actividad se mantiene en memoria pero es buena ocasión para guardar su estado para poder recuperarlo en caso de que el sistema la mate por una necesidad de memoria. Cuando la actividad termina, bien por la llamada a su método \textit{finish()} o porque el usuario decide destruirla con el botón \bsq{atrás}, el sistema invoca el método \textit{onDestroy()} de la actividad. Este método también se invoca si el sistema decide prescindir de la actividad por falta de recursos y esta necesidad no es muy urgente, es decir la llamada a este método no está garantizada en todas las situaciones.

El ciclo de vida de las actividades se ve modificado por cambios en la configuración, ejemplos de ello son un cambio en el idioma del sistema, la disponibilidad del teclado físico o un cambio en la orientación de la pantalla. Ante estos eventos las actividades son destruidas y reconstruidas automáticamente pero hay que restaurar de manera manual el estado que tuviesen. No obstante, hay algunos fabricantes que no consideran el cambio de orientación de la pantalla como un cambio en la configuración y por tanto el ciclo de vida no se ve afectado ante este evento.


\subsubsection{Service}
\label{subsec:service}
Un servicio es un componente que está pensado para realizar tareas cuyo tiempo de ejecución es dilatado o para trabajar con procesos remotos como la descarga de un archivo. Es un componente sin interfaz gráfica, por lo que debe ser iniciado por otro componente, normalmente por una actividad que requiera de sus servicios.

Un servicio se ejecuta, en principio, en la misma hebra y en el mismo proceso que la aplicación. Pero al no tener interfaz gráfica, su ciclo de vida está desligado de la pantalla. Es más, su ejecución es totalmente independiente del componente que lo inició, es decir, aunque éste este fuera de foco o incluso haya sido destruido o matado por el sistema, el servicio seguirá su propio camino.\\ 

Para proporcionar de una serie de operaciones a la aplicación (u otras ya que \android{} nos permite la instanciación de otros componentes fuera del alcance de ésta si lo habilitamos para ello) tenemos dos opciones: un servicio empezado o un servicio atado.

Un servicio empezado es aquel que es iniciado por un componente que requiere de una operación pero no necesita que flujo de trabajo dependa de ésta. Aunque el servicio tiene mecanismos para devolver un resultado, éstos no están contemplados bajo el punto de vista de este tipo de servicio. Tras su iniciación, permanecerá ejecutándose hasta que sea parado por el componente que lo inició u otro o sea parado por el mismo al terminar su trabajo. Un servicio atado sin embargo, permite la comunicación con el componente que lo inició mediante una interfaz cliente-servidor. Como esta interfaz debe ser capaz de comunicarse no sólo con el proceso donde está alojado el servicio, si no con otros procesos o aplicaciones, su implementación se basa en un objeto \textit{IBinder}: un objeto ligero que define una interfaz para el procedimiento de llamada remota diseñado para tener un gran rendimiento en procesos y llamadas a procesos cruzados~\cite{andIBinder}. Hay tres formas de declarar esta interfaz:
\begin{description}
 \item [Extendiendo la clase Binder] Si el alcance se restringe a la misma aplicación y no se necesita comunicación entre procesos, está es la manera más sencilla de conseguir una referencia para llamar a todos los métodos públicos del servicio.
 \item [Usando un Messenger] Este objeto nos permite que el servicio preste soporte a otros procesos más allá del local, evitando además condiciones de carrera entre las distintas peticiones ya que la hebra que maneja el \textit{Handler}~\cite{andHandler} recoge y encola las solicitudes. Las peticiones son en forma de mensaje por lo que no hay una interfaz que declare métodos propiamente dichos, si no que brinda una comunicación entre ambos por medio de paso de mensajes que son procesados en una cola.
 \item [Usando AIDL] Esta forma es la menos intervencionista por parte de \android{}. Nos permite definir una \ac{API} propiamente dicha con la declaración de funcionalidad gracias a \ac{AIDL}, que descompone los objetos en primitivas que pueden ser traspasadas entre procesos para desempeñar \ac{IPC}. Es la única manera de proveer un servicio que acepte peticiones simultáneamente pero es responsabilidad del programador proveer una estructura multihebra segura. 
\end{description}

\figura{Bitmap/analysis/service-lifecycle}{width=.56\textwidth}{fig:service-lifecycle}{Ciclo de vida de los distintos tipos de servicios en \android{} extraído de \cite{andService}}

El ciclo de vida de los servicios se plasma en la figura~\ref{fig:service-lifecycle}, en ella se ve que ningún evento del teléfono tales como la interacción del usuario o llamadas entrantes modifica el flujo de trabajo del servicio. En la parte izquierda tenemos al servicio que ha sido empezado por un componente y la derecha el servicio que ha sido vinculado o atado por el componente. La manera de parar este segundo tipo de servicio es mediante la desvinculación de todos los componentes que hayan interactuado con él. \android{} no obstante, no restringe que un servicio que haya sido vinculado no pueda ser iniciado y al revés, para acomodarse a los distintos requerimientos de una operación.


\subsubsection{Content provider}
Un proveedor de contenidos permite dotar de un contexto para el intercambio de datos entre aplicaciones. Una aplicación decide donde guardar sus datos: base de datos, archivo de preferencias, sistema de ficheros, en remoto\ldots Pero para que otras aplicaciones puedan acceder o incluso modificar sus datos, se necesita el uso del objeto \textit{ContentResolver}. Éste recibe las peticiones de otras aplicaciones, las procesa y devuelve el resultado por medio de una \ac{API} estandarizada para el intercambio. 


\subsubsection{Broadcast receiver}
\label{subsec:broadcastReceiver}
Es un componente que responde a avisos que son difundidos a todo el sistema. Muchos de estos avisos se originan desde el propio sistema \android{} informando del estado del dispositivo o eventos producidos, pero también una aplicación puede lanzar este tipo de avisos. Una aplicación puede recibir este tipo de avisos registrándose a la acción y tipo que lleve el anuncio. Éstos son capturados en el método \textit{onReceive()} que está pensado para una ejecución corta, si no el sistema puede matar la aplicación por bloquear el flujo normal. En este método podemos aprovechar para lanzar una notificación al usuario o iniciar otro componente.

\subsubsection{Vertebrando el flujo de la aplicación}
La forma de canalizar el flujo e ir disparando y enlazando los diferentes componentes para crear un flujo de aplicación se basa en una llamada asíncrona llamada \textit{Intent}~\cite{andIntent}. Se trata de una especie de mensaje para activar un componente específico o un tipo de componente que se adapte al deseo para el cual se creó el \textit{Intent}. Se trata del tipo explícito, donde conocemos qué componente queremos que realice la acción, o implícito, en caso de que expresemos un deseo a través de una acción y una \ac{URI} para identificar un dato necesario para esa acción. Con este \textit{Intent} implícito \android{} elige entre todos los componentes disponibles aquel que pueda realizar este deseo, si hay varios componentes elegibles, la decisión depende en último lugar del usuario del dispositivo.


\subsubsection{AndroidManifest.xml}
El archivo manifiesto permite registrar la aplicación en el sistema y ofrecer los servicios que tenga ésta. En él debemos definir:
\begin{itemize}
	\item Todos los componentes de aplicación para que puedan ser activados. Además pueden ser declarados junto con la etiqueta \textit{intent-filter} para que el sistema identifique y clasifique al componente y sea así elegible de manera implícita. Podemos usar este archivo para reconocer el evento de encendido y activar un componente, característica que desde el propio código no podemos capturar.
	\item Cuál es la mínima versión de la \ac{API} del sistema que garantiza que nuestra aplicación se ejecuta correctamente.
	\item Cada uno de los permisos que la aplicación necesita para ejecutarse, así como los componentes \textit{hardware} que necesita para su ejecución.
 	\item Librerías existentes en el teléfono que necesita vincular (a parte de la del sistema) para acceder a ciertas funcionalidades.
	\item Otros: nombre de la aplicación, icono, crear permisos personalizados, definir procesos\ldots 
\end{itemize}
                         
\subsection{Otros componentes de interés}

Estos otros componentes se utilizan dentro de los ya descritos o por sí mismos y suponen una especialización. No contraen gran peso en la arquitectura de \android{} aunque junto con otros muchos, que no describimos aquí pues no son útiles para la implementación de este proyecto, ayudan a componer la funcionalidad que ofrece la plataforma.


\subsubsection{AsyncTask}
\label{subsubsec:asyncTask}
Este componente nos permite realizar trabajos asíncronos como si estuviésemos en la hebra principal, en la llamada hebra de interfaz de usuario. \android{} no tolera que una aplicación bloquee la hebra principal~\cite{andANR} por un tiempo: cinco segundos en el caso de la respuesta a eventos provenientes de la interfaz de usuario o diez para la ejecución de un \textit{BroadcastReceiver}. Por lo tanto la hebra principal o de interacción con el usuario, no debe ser usada para realizar trabajos si no que deben ser delegados en otra hebra. Eso es precisamente lo que una tarea \textit{AsyncTask}~\cite{asynctask} realiza de manera automática sin que el programador de aplicaciones tenga que intervenir en la creación, manejo y destrucción de la hebra encargada para este trabajo. El sistema llama a su método \textit{doInBackground()} cuando arranca la tarea. Éste se ejecuta en un grupo de hebras en segundo plano, la instanciación y finalización de esta hebra es manejada por el sistema. Una vez se ha terminado la ejecución en segundo plano, el sistema llama al método \textit{onPostExecute()} que recoge el resultado arrojado por la ejecución. Este método en cambio, se ejecuta en la hebra principal por lo tanto es un lugar seguro para actualizar la interfaz de usuario evitando comportamientos inesperados~\cite{andSingleThreadedModel}. La \textit{AsyncTask} también proporciona un mecanismo para ir actualizando la interfaz de usuario no sólo al final de la ejecución de la tarea. Esto se realiza mediante la llamada a \textit{publishProgress()} desde el método \textit{doInBackground()} y recogido en la hebra principal con el método \textit{onProgressUpdate()}. Este componente puede ser utilizado en cualquier otro componente pudiendo acceder a su ámbito: dentro de un servicio, de una actividad\ldots


\subsubsection{ServiceIntent}
\label{subsubsec:serviceIntent}
Se trata de una especialización de un servicio. Este componente~\cite{intentService} permite crear un servicio iniciado en una hebra independiente a la principal. Una vez que el servicio ha terminado de ejecutar su tarea finaliza por sí mismo si no tiene que atender a más peticiones destruyendo la hebra utilizada para ello.

Al contrario que una \textit{AsyncTask}, este componente se presenta por sí solo, la manera de pasarle parámetros es mediante el objeto \textit{Intent}. En cambio no hay una manera estándar para recoger el resultado del trabajo. Una manera que podemos utilizar es lanzando un anuncio que sea recogido por el componente interesado. Si sólo necesitamos informar al componente que lo inició, lo es mejor usar un anuncio local con el objeto \textit{LocalBroadcastManager}. Otras maneras son mediante variables usadas como banderas u otros mecanismos de la programación de objetos. Este componente se instancia una sola vez, es decir si lo invocamos varias veces, no importando desde qué lugar, las peticiones serán encoladas y atendidas en orden de llegada. Desde fuera podemos vaciar la cola en cualquier momento y así parar la ejecución, pero una vez una petición está siendo atendida no hay forma de detenerla al menos que implementemos un mecanismo especial para ello.

\subsubsection{Handler}
El objeto \textit{Handler}~\cite{andHandler} nos permite hacer dos cosas: programar la ejecución de objetos \textit{Runnable} o \textit{Message} en un punto del futuro o encolar una acción para que sea realizada en una hebra diferente a la actual~\cite{andSingleThreadedModel}. Cada instancia de un \textit{Handler} se asocia a una hebra que maneja la cola de mensajes, es aquí donde se envían las acciones que posteriormente serán entregadas en orden y procesadas en la hebra principal.

Como hemos visto el \textit{Handler} maneja dos tipos de objetos y prevé métodos para ambos, los \textit{Runnable} van asociados a los métodos \textit{post} y los \textit{Messsage} a los \textit{sendMessage}. Nuestra aplicación de por sí, tiene asociada un \textit{Handler} que utiliza para manejar todos los objetos de alto nivel (Actividades, \textit{BroadcastReceiver}\ldots), pero nosotros mismos podemos extender una instancia de la clase \textit{Handler} y proporcionar el método \textit{handleMessage()} para recoger los mensajes enviados desde hebras que creemos en nuestra aplicación y así tener un mecanismo de comunicación con ellas.


\subsubsection{Fragments}
\label{subsubsec:fragments}
La llegada de las tabletas al mundo móvil deja gran parte de la pantalla sin utilizar ya que el diseño de la interfaz gráfica está diseñada para dispositivos con pantalla más pequeña. En esta tesitura si mantenemos la misma tecnología las aplicaciones tendrían que rediseñar su interfaz dependiendo del dispositivo en el que ejecuten, teniendo que duplicar tanto el código que maneja la interfaz como la funcionalidad enmarañando el modelo de modularidad que brinda la programación de objetos.

Para ello \android{} desarrolló el fragmento~\cite{fragments}. En las versiones anteriores una actividad representaba una ventana de la interfaz de usuario, un fragmento representa una porción de esta interfaz dentro de una actividad. Según las posibilidades de la pantalla podemos combinar distintos fragmentos en una actividad creando una interfaz multipanel dinámica. Este sistema nos da la posibilidad de reutilizar de manera más cómoda cada fragmento en varias actividades. La actividad, por tanto, se convierte en un contenedor de fragmentos que es utilizada para manejarlos y hacer posible que unos se comuniquen con otros, pues el modelo independiza a cada uno de ellos dotándole de un espacio propio y un ciclo de vida propios.

La actividad por ser dueña del fragmento tiene acceso a todos los métodos de éste, además los eventos producidos en un fragmento (como la pulsación de un botón) pueden ser capturados directamente en la propia actividad. Por este motivo la comunicación hacia abajo (\textit{activity} $\rightarrow$ \textit{fragment}) es bastante sencilla al basarse en la invocación.

 Sin embargo, la comunicación hacia arriba (\textit{activity} $\leftarrow$ \textit{fragment}), debido al carácter autónomo del fragmento, se basa en que éste declare una interfaz de métodos que la actividad debe cumplir. Estos métodos por tanto, tienen que ser implementados en la correspondiente actividad. Para asegurarse de esto, el fragmento puede forzar a que la actividad que le contenga, cumpla con la interfaz declarada. Esta comprobación la realiza en su método \textit{onAttach()}, asegurándose que al llamar a estos métodos, cuyos parámetros son la información que transfiere a la actividad, se van a ejecutar en la actividad sin causar un error en tiempo de ejecución.

La comunicación entre fragmentos se basa en una mezcla de los dos procedimientos, una comunicación hacia arriba y una vez se está en el ámbito de la actividad realizar la invocación del método en el fragmento deseado, produciéndose una comunicación hacia abajo.
          
                                                   
%-------------------------------------------------------------------
\section{Interfaz de comunicación: Wi-Fi}
\label{sec:wifi-analysis}
%-------------------------------------------------------------------

\wifi{}~\cite{wifi} es nombre comercial, sin significado aparente, para un conjunto de estándares para redes \ac{LAN} inalámbricas basado en las especificaciones de la norma \ac{IEEE} 802.11~\cite{802.11} que engloba los dos primeros niveles del modelo \ac{OSI}: la capa física (PHY) y la de enlace (MAC). \wifi{} realiza las mismas funciones que el estándar \ac{IEEE} 802.3~\cite{802.3} pero de manera inalámbrica.

El espectro utilizado por \wifi{} se localiza en varias zonas del espectro, las más populares son las posicionadas en las bandas de 2.4 GHz (802.11b/g/n) y de 5 GHz (802.11a/h/j/n/ac), pero hay otras implementaciones en otras bandas tal como vemos en~\cite{wifiChannels}. En la figura~\ref{fig:wifiChannels} observamos que tenemos catorce canales de los cuales sólo hay tres que no solapan (por ejemplo el 1, 6 y 11) si tenemos en cuenta un ancho de 22 MHz por canal y una separación de 5 MHz a excepción del 14 que se separa 12 MHz. En la versión \bsq{n} podemos utilizar un ancho de canal de 40 MHz y por tanto todos los canales se solapan. No en todo el mundo está permitido el total uso de estos canales además el uso la aplicación (interior o exterior) también es un factor que restringe su uso, no obstante aunque con singularidades, el uso de los once primeros canales está aceptado globalmente. 

\figura{Vectorial/analysis/wifiChannels}{width=0.976\textwidth}{fig:wifiChannels}{Asignación frecuencias a los canales de \wifi{} en la banda ISM de 2.4 GHz}

En la banda de 5 GHz existen más restricciones debido a que es una banda relativamente nueva y no en todos los países se ha liberado. A pesar de ser una banda más ancha espectralmente y menos ocupada, lo que ayuda al incremento de la velocidad de transmisión, sus condiciones de propagación son peores~\cite{802.11nPropagation} y requiere de una mayor planificación y mantenimiento lo que hace que sea descartada para ciertas aplicaciones. A parte no es una tecnología muy extendida en el campo de los \sphone{s}, sólo unos pocos terminales la incorporan como el \bsq{Samsung Galaxy S3} en adelante, el \bsq{HTC One X} o \bsq{BlackBerry Z30}, por citar algunos.\\


Toda la información sobre \wifi{} en \android{} está recogida en el paquete \texttt{net}~\cite{andWiFiNet}, en él se recogen todos los mecanismos para la configuración de redes \wifi{} y todas las funciones de la \ac{API}. Entre estas funciones están la consulta de información de la red a través de la clase \class[android.net.wifi]{WifiInfo}, estado y eventos de la interfaz junto con las acciones disponibles: conectarse o desconectarse de una red a través de los métodos \textit{enableNetwork(), reconnect()} y \textit{disconnect()}; encender o apagar la interfaz con el método \textit{setWifiEnable()}; escanear todas las redes disponibles con \textit{getScanResult()}. Todas estas funcionalidades se encuentran en la clase \class[android.net.wifi]{WifiManager}~\cite{andWifi}, para poder usarlas debemos aceptar en el archivo manifiesto de la aplicación estos permisos:
\begin{verbatim}
 - android.permission.ACCESS_WIFI_STATE
 - android.permission.CHANGE_WIFI_STATE
\end{verbatim}
 La información recogida del proceso de escaneo para cada red detectada incluye: 
\begin{itemize}
	\item \textbf{Identificación básica de la red}, el nombre dado a la red \wifi{}: \ac{SSID}, y la dirección \ac{MAC} del \ac{AP}: \ac{BSSID}.
	\item \textbf{Identificación de seguridad}, los protocolos de autenticación y manejo de claves, así como los esquemas de cifrado soportados por el \ac{AP}.
	\item \textbf{Relativo a señal}, la frecuencia (el canal) asignada y el nivel \ac{RSSI} percibido medido en dBm.
	\item \textbf{Relativo al momento}, una marca de tiempo recogida en el momento que se hizo el escaneo.
\end{itemize}


%-----------------------------------
\subsection{Viabilidad: modos de funcionamiento}
\label{sec:adhoc-analysis}
%-----------------------------------
Una interfaz \wifi{} describe seis modos de operación: \textit{Master} (actuando como un \ac{AP}), \textit{Managed} (cliente o también conocido como estación), \adhoc{}, \textit{Mesh}, \textit{Repeater} y \textit{Monitor}. De éstas, sólo el modo cliente o infraestructura está plenamente soportado en cualquier dispositivo \android{}, es decir en aquellas redes en las que existe un \ac{AP} externo que maneja la red. En relación a los otros modos no todos los \textit{chipset} que montan los dispositivos los soportan en su plenitud.

\paragraph{Modo Master} Con respecto al modo \textit{Master}, usado en aplicaciones de \textit{Tethering}, cada fabricante suministra, para aquellos modelos que pueden soportarlo, una aplicación para compartir la interfaz de datos móviles a través de \wifi{}. Esta aplicación necesita permisos especiales y usa una \ac{API} no publicada exclusiva del fabricante o del sistema para poder modificar la tarjeta de red. Una manera de configurar este modo, a parte de la aplicación suministrada por el fabricante, es confiar en las herramientas de \android{} con el método oculto \textit{setWifiApEnable()} de la \class[android.net.wifi]{WifiManager}. Podemos llamar a este método a través de la técnica \textit{reflection}. Este método acepta como parámetro una configuración de red que incluye los protocolos de cifrado, el nombre de la red, la contraseña, si es visible\ldots  Esta configuración suministrada, que no incluye el canal y no tiene efecto en modelos como el \bsq{HTC Desire} o \bsq{HTC Desire C}. 

De hecho el mismo método puede no encontrarse en la \ac{API} del dispositivo, lo que implica una gran dependencia del dispositivo. Por otro lado la selección del canal es, si cabe, más dependiente lo que dificulta su modificación. Algunos dispositivos como el \bsq{Motorola Defy+} permiten elegir el canal o frecuencia de funcionamiento de esta red \wifi{} en las preferencias de la aplicación suministrada. En este dispositivo, un cambio del canal desemboca en el envío al \textit{ContentProvider} \texttt{MotorolaSettingsProvider.apk} con la siguiente \ac{URI} \texttt{content://com.motorola.android.providers.settings\allowbreak/wifi\allowbreak\_ap\_frecuency}, otros como el \bsq{HTC Desire C} permiten configurar el canal de forma automática colocando la red en la región menos saturada. Esta característica no es del todo deseable, pues aunque desde el punto de vista de nuestra comunicación, esta región puede ser la más apropiada, igual se trata de una región donde operan usuarios primarios y terminaríamos entorpeciéndoles. Sin embargo, en este modelo para poder levantar la interfaz en este modo se requiere del permiso:
\begin{verbatim}
 - android.permission.WRITE_SETTINGS
\end{verbatim}
Permiso que está reservado a procesos del sistema. Otra técnica intentada por el autor es la de configurar el modo \textit{Master} llamando al método previamente citado para que \android{} carge de forma automática el módulo de \wifi{} con la configuración oportuna, que recordemos es muy dependiente del dispositivo, una vez hecho esto, intentaríamos con permisos de superusuario cambiar el canal. En concreto se intentó con el modelo \bsq{HTC Desire} con el sistema operativo CyanogenMod 10.1 (una modificación del sistema \android{}) pero fue imposible cargar un binario \texttt{iwconfig} que funcionase, pues no viene ninguno en el sistema.\\

La utilización del \textit{Tethering} no se ajusta a nuestras necesidades para recrear una red \wifi{} que no necesite componentes externos en la que transmitir paquetes, pues en última instancia éste no es su objetivo. El suyo es conectar la interfaz de datos móviles con la interfaz \wifi{} para encaminar los paquetes de esta red por la otra interfaz. Además, los problemas experimentados tanto a la hora de configurar este modo como los problemas para ajustar el canal, más restrictivos si cabe, hacen que este modo sea descartable para el diseño de nuestra arquitectura cognitiva.

\paragraph{Modo Ad-Hoc} Otro modo más interesante es el modo \adhoc{} pues nos permite recrear una red \wifi{} sin depender de elementos externos~\cite{adhocNetworks}. La red se construye enlace a enlace entre dispositivos y es una solución real \ac{P2P}, cada enlace~\cite{adhocNetworks2} depende de las capacidades del nodo (memoria, potencia computacional, potencia de transmisión) de las propiedades del medio (longitud del enlace, interferencias y ruido) y del tipo de enlace (fiabilidad). Como estos enlaces pueden establecerse y destruirse en cualquier momento, una red en funcionamiento tiene que ser capaz de reconfigurarse de manera sencilla. Por este motivo, la capa de red es bastante ligera, sin restricciones en la topología, protocolos sencillos y sin mecanismos de descubrimiento ni seguridad implementados de forma nativa, lo que hace que sea idónea para adaptarse a múltiples aplicaciones.\\

\android{} no da soporte a este modo, es más, intenta ocultarlo. En su archivo \texttt{wpa\_supplicant}, utilizado por los clientes para asociarse y negociar con el \ac{AP}, se restringen este tipo de redes también llamadas \ac{IBSS}. De tal manera que aunque el \textit{chipset} \wifi{} reconozca este tipo de redes,  los niveles superiores filtran estos resultados. Si tenemos permiso de superusuario podemos sustituir nuestro archivo \texttt{wpa\_supplicant} por otro que no filtre este tipo de redes, así en las sucesivas veces que se cargue el módulo de \wifi{}, éste cogerá la nueva configuración, haciendo que un cliente vea y pueda cooperar en este tipo de redes al tomar como \ac{AP} al nodo que envía \textit{beacons} con información de la red. Algunos modelos como el \bsq{Motorolola Defy+} ven las redes \adhoc{} sin necesidad de practicarles ningún cambio.\\

Harina de otro costal es configurar el modo \adhoc{} para poder recrear una red de este tipo. Cada dispositivo monta un \textit{chipset} de \wifi{} diferente que es manejado cada uno por diferentes \textit{drivers} que a su vez pueden estar incluidos dentro del núcleo o como un módulo externo. Para el modelo \bsq{HTC Desire} con CyanogenMod 10.1 vemos que trae consigo un módulo \texttt{bcmdhd} que no es configurable bajo comandos del  binario \texttt{iwconfig} (herramientas de red Wext), sin embargo la versión 7 de CyanogenMod trae consigo para este modelo el módulo \texttt{bcm4329} que si es configurable mediante este método. Para el modelo \bsq{Samsung Galaxy S1} debemos quitar el módulo \texttt{dhd} para volverlo a cargar manualmente con el \textit{firmware\_path} apropiado \texttt{bcm4329\_sta.bin} y configurar el modo \adhoc{} mediante comandos de \texttt{iwconfig}. Sin embargo estamos hablando de una versión 2.2 en \android{} que es demasiado antigua para montar una arquitectura cognitiva que pueda ser utilizada hoy en día, debido a que la versión Jelly Bean (4.1) es la más popular~\cite{andPopularVersion}. Coincide la introducción de \android{} 4.0 y la anexión de \wifiD{} con el momento en el que la mayoría de módulos de \wifi{} dejan de dar soporte al ejecutable \texttt{iwconfig}, por lo que aunque seamos capaces de descubrir cómo cargar el módulo de \wifi{} con la configuración adecuada, no seremos capaces de interactuar con el pues las herramientas de red Wext no nos serán de ayuda. Por este motivo y para un número pequeño de dispositivos en~\cite{andAdhoc} se describe la modificación realizada en el \textit{driver} \texttt{bcmdhd} (que no soporta Wext) y en la \ac{API} de \android{} para que la creación de redes \adhoc{} sea accesible de manera cómoda y sin la necesidad de permisos especiales. Esta modificación ha sido incluida en CyanogenMod 10, lo que facilita su integración en dispositivos a la par que no se queda desactualizada el resto del sistema, y rechazada en el proyecto \ac{AOSP} de Google, por lo que es poco probable que en un futuro próximo veamos que se soporta el modo \adhoc{} de forma nativa en más dispositivos. Con esta modificación somos capaces de crear una red \adhoc{} en el modelo \bsq{Samsung Galaxy S1} desde el menú de redes y también de manera programática, así como la elección del canal usado.\\ 

En realidad, como hemos visto, no hay una recreación como tal, la red se construye poco a poco sin que haya un agente que asuma el peso de ésta. Cada dispositivo actúa con independencia donde todos toman el mismo estatus, cada nodo es libre de conectarse con otros en su rango de alcance. Una vez este modo está configurado en la tarjeta de red, el dispositivo que quiera unirse a una \ac{IBSS} con un cierto nombre (\ac{SSID}) escaneará el canal para ver si la red ya existe, bien escuchando pasivamente \textit{beacons} en donde debería encontrarse la red, o bien de manera activa enviando solicitudes a modo de sondeo. Si se detecta este \ac{IBSS} se asume el \ac{BSSID} observado y sin más dilación se pueden intercambiar tramas de datos entre los todos los nodos que estén al alcance. Si no se detecta, empezamos nosotros mismos a enviar \textit{beacons} anunciando la red. Por diseño, todos los dispositivos deben estar forzosamente bajo el mismo canal y recae sobre todos ellos la tarea de distribuir, bajo una espera aleatoria, la información de la red bajo tramas \textit{beacons}. Este anuncio se produce hasta que la tarjeta de red deje de estar configurada en este modo.\\

Uno de los problemas que primero nos encontramos es la numeración en la red, al ser una red distribuida donde no se conoce a priori cuáles nodos son los que van a formar la red, ni hay un agente que la maneje ni asigne direcciones \ac{IP}, al igual que tampoco existe una solución nativa para que se propaguen los cambios del registro o salida de la red de un dispositivo. Como primera solución al problema de la numeración podemos hacer que un nodo despliegue un servidor \ac{DHCP} para asignar direcciones. Entre los posibles, un buen candidato sería Dnsmasq~\cite{dnsmasq}. Esta solución centralizadora parece ser la única asumible en un entorno, que como hemos dicho, desconocemos el número de nodos, por lo cual no es posible una asignación estática previa. \android{} no olvidemos que se trata de un sistema Linux, por lo que puede ejecutar este binario pero se necesita el permiso de superusuario para que funcione correctamente. Aún así, éste puede que no sea el único requisito pues en el modelo \bsq{HTC Desire} con CyanogenMod 10.1 el autor no ha podido hacer funcionar este servidor. Además como este binario escribe en un archivo el recuento de las direcciones asignadas, cada vez que recibe una petición a través de la clase \textit{FileObserved}~\cite{andFileObserved} de \android{}, podemos darnos cuenta del registro de un nodo en el mismo momento de su entrada sin que éste tenga que hacer nada más.\\

Este modo, al igual que el anterior, es muy dependiente del dispositivo en el que se ejecute el \textit{software} lo que hace que tengamos que desarrollar una solución particular. Parece que las nuevas versiones de \android{} dificultan en mayor medida la posibilidad de recrear este tipo de redes y todas ellas van ligadas a la adquisición del permiso de superusuario. La toma de este permiso puede provocar problemas de inestabilidad tanto en nuestra aplicación como en el resto del sistema si no se realizan las cosas de forma correcta. Esta serie de problemas hacen que sea difícil implementar este modo de manera general en cualquier dispositivo por lo que puede y será descartado en fase de diseño. 

\subsection{Viabilidad: Wi-Fi Direct}
\label{sec:wifiD-analysis}
Es una tecnología~\cite{wifiD} que permite tener enlaces 802.11 entre dispositivos sin la necesidad de un \ac{AP}, para ello se usa un \textit{software} conocido como \textit{softAP} que debe estar presente en el \textit{chipset} de \wifi{}. Surgió como competencia a \bt{} 3.0 pero integra todos los protocolos de descubrimiento y establecimiento de la conexión a través de \wifi{}. También conocido como \wifi{} peer-to-peer~\cite{andWifiD}, aunque realmente no constituye un protocolo real de \ac{P2P} pues se basa en el establecimiento jerárquico de grupos donde uno toma el papel central, el papel del tradicional \ac{AP}, con el que puede establecer comunicaciones uno a uno o uno a varios. La norma viene junto con una serie de servicios predefinidos que completan el abanico de posibilidades tales como compartición de archivos, impresión, compartición de la pantalla\ldots 

En~\cite{wifiDvsAdhoc} se analizan los ventajas e inconvenientes de este tipo de red frente a enlaces tipo \adhoc{}. Entre las desventajas están el no ser un sistema escalable que no reacciona muy bien frente a cambios en la tipología, la complejidad de sus protocolos y el hecho de tener que intercambiar mucha información antes del envío de tramas de datos. Su principal ventaja es la seguridad y el cifrado que forman parte del estándar y el descubrimiento de servicios.\\

\android{} introdujo esta característica en su versión 4.0, aunque no todos los dispositivos los soportan, ya que como hemos dicho se necesita de un \textit{software} especial que no todos las tarjetas de red son capaces de incorporar. Lo que incita a pensar la imposibilidad de usar Wext y la adopción de \wifiD{} están relacionados. Otro indicio es la imposibilidad de manejar esta característica aunque subamos de versión un dispositivo del que no hay un desarrollo por parte del fabricante como ocurre en el modelo \bsq{HTC Desire} con CyanogenMod, sistema que integra el \textit{sofware} adecuado. \wifiD{} no presenta, por el momento, un buen rendimiento con más de 4 dispositivos y existen fallos en su implementación en algunos dispositivos como el \bsq{Nexus 7}~\cite{andWifiDBug}. Con respecto al requisito de la \ac{CR} de ser transparente al usuario, el autor no ha sido capaz de desplegar este tipo de redes sin la intervención del usuario. Mediante el uso de \textit{reflection} se logra acceder al método \textit{wifiP2Penable()} de la clase \class[android.net.wifi.p2p]{WifiP2pManager} pero este método termina con la apertura de un dialogo de confirmación al usuario. Este problema hace incompatible la adopción de esta interfaz de comunicación en nuestra arquitectura cognitiva. 

\subsection{Viabilidad: MTU}
\label{sec:mtu-analysis}
El parámetro \ac{MTU} es propio de una transferencia \ac{IP}, por lo que aunque lo comentemos en esta sección aplica también a la interfaz de datos móviles pues funciona bajo el mismo tipo de datos: el paquete \ac{IP}. Este parámetro representa la longitud en \textit{bytes} de la unidad de datos más grande que puede enviarse por un protocolo de comunicaciones. Normalmente este parámetro es elegido por el dispositivo de forma automática o se fija en 1500 \textit{bytes} por herencia de \textit{Ethernet} pues en el inicio o en el final del paquete enviado pasará por un segmento de este tipo. Encontrar el punto óptimo de este parámetro incrementa el rendimiento al evitar retransmisiones enviando la máxima cantidad de datos y manteniendo una baja latencia.

En \android{} una forma de modificarlo es como se realiza en una máquina Linux, con la herramienta \texttt{ifconfig} pero requiere de permisos de superusuario y que este comando esté presente y funcione. Al no ser fácil conocer cuántas retransmisiones se producen ni los tiempos de envío, la optimización de este parámetro se presenta complicada. Esto sumado al hecho de no ser un punto crítico y que su optimización puede que tenga un efecto bajo en el computo global hacen que sea descartado para la fase de diseño.

%-------------------------------------------------------------------
\section{Interfaz de comunicación: Bluetooth}
\label{sec:bt-analysis}
%-------------------------------------------------------------------

\bt{} sin embargo, es una tecnología \ac{WPAN} de bajo consumo que opera en la banda \ac{ISM} de 2.4 GHz, que recordemos es sin licencia. Creada en 1994 por Ericcson como la alternativa inalámbrica al cable RS-232 se estandarizó como \ac{IEEE} 802.15.1~\cite{802.15.1} pero el estándar ha dejado de mantenerse, en su lugar surgió el \bt{} \ac{SIG} que mantiene el desarrollo de la tecnología. Podemos clasificar a los dispositivos según su alcance de transmisión y según la capacidad de canal~\cite{bluetoothWiki}:\\[10pt]
\begin{minipage}[t]{.5\textwidth}%
	\begin{center}%
	\uwave{Alcance}%
	\end{center}%	
\begin{itemize}%
		\item \textbf{Clase 1}: limitado a una potencia de transmisión máxima de 100 mW (20 dBm) con un alcance medio de $\approx$100 m.%
		\item \textbf{Clase 2}: limitado a 2.5 mW (4 dBm), la clase más común con un alcance medio de $\approx$10 m.%
		\item \textbf{Clase 3}: cuenta con una limitación de 1 mW (0 dBm) que le permite alcanzar distancias de $\approx$1 m.%
	\end{itemize}%
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}%
	\begin{center}%
 	\uwave{Capacidad}%
	\end{center}%
	\begin{itemize}%
		\item \textbf{Versión 1.2}: alcanza una tasa de 721 kbps.%
		\item \textbf{Versión 2.0 + EDR}: hasta 2.1 Mbps con modulación GFSK~\cite{btRegulation}.%
		\item \textbf{Versión 3.0 + HS}: hasta 24 Mbps con un enlace basado en 802.11 cuyo establecimiento se realiza con los protocolos de \bt{}.%
		\item \textbf{Versión 4.0}: simplificación de protocolos y baja energía.%
	\end{itemize}%
\end{minipage}%

\paragraph{}Esta tecnología utiliza la técnica de espectro ensanchado~\cite{meel99} mediante el salto de frecuencia: \ac{FHSS}, ésta se basa en transmitir la información en pequeños trozos cada vez sobre una portadora distinta en una banda de frecuencias. La pseudoaleatoria secuencia de salto es conocida por el receptor para poder recoger toda la información de manera íntegra. Esto hace que la densidad de potencia espectral disminuya al repartirse sobre una banda muy ancha lo que hace que sea difícil de detectar y que sea robusta frente a interferencias pues nuestra señal se divide en muchas componentes espectrales.

Como se puede ver en la figura~\ref{fig:btChannels} las frecuencias en las que \bt{} puede saltar son 79 portadoras que están espaciadas 1 MHz. Sin embargo algunos países por la asignación que hicieron, no disponen de una banda tan ancha lo que les obliga a restringir el salto a 23 portadoras~\cite{btRegulation}.

\figura{Bitmap/analysis/btChannels}{width=0.8817\textwidth}{fig:btChannels}{Asignación canales de salto en \bt{}. Banda ISM de 2.4 GHz extraído de~\cite{btMeasures}}

Un ejemplo que ilustra la baja densidad espectral de potencia es el que podemos ver en~\cite{btVsWifi}. En él se comparan las densidades de una transmisión en \bt{} con una medición de -27.17 dBm y la transmisión utilizando la técnica de \ac{DSSS} en 802.11b sobre el canal 1 que ocupa menos en frecuencia pero cuya potencia alcanza a -6.776 dBm.
%\clearpage
\begin{figure}[h!]%
\centering%
\begin{minipage}{.5\textwidth}%
  \centering%
  \includegraphics[width=.97\linewidth]{Imagenes/Bitmap/analysis/bluetooth-spectrum}%
  \captionof{figure}{Medición de la densidad\\espectral de potencia bajo una señal de\\ búsqueda de otros dispositivos \bt{}}%
  \label{fig:test1}%
\end{minipage}%
\begin{minipage}{.5\textwidth}%
  \centering%
  \includegraphics[width=.97\linewidth]{Imagenes/Bitmap/analysis/wifi-spectrum}%
  \captionof{figure}{Medición de la densidad espectral de potencia de una señal 802.11b ubicada en el canal 1}%
  \label{fig:test2}%
\end{minipage}%
\end{figure}%

\newpage
\bt{} permite crear redes de hasta ocho dispositivos: siete esclavos y un maestro que dirige la secuencia de saltos. Este límite en el número de dispositivos reside en el formato de tramas intercambiadas en lo que se denomina \textit{piconet} que va identificada por un \ac{UUID}.\\

Toda la información sobre \bt{} en \android{} se encuentra recogida bajo el paquete \texttt{bluetooth}~\cite{andbt}. Obviando toda la información sobre perfiles y baja energía (versión 4.0) nos interesan el adaptador \class[android.bluetooth]{BluetoothAdapter} y una clase para interactuar con el dispositivo remoto \class[android.bluetooth]{BluetoothDevice}, estas clases junto con los \textit{sockets} \class[android.bluetooth]{BluetoothSocket} y \class[android.bluetooth]{BluetoothServerSocket}, nos permiten crear un canal comunicaciones \ac{RFCOMM}. \android{} permite, aunque no lo recomienda, encender y apagar la interfaz \bt{} sin interacción del usuario, este punto no constituye por tanto un factor limitante para su uso en \ac{CR}. Para usar estas \ac{API}, la aplicación necesita aceptar estos dos permisos, precisándose el segundo para lanzar un descubrimiento de dispositivos:
\begin{verbatim}
 - android.permission.BLUETOOTH
 - android.permission.BLUETOOTH_ADMIN
\end{verbatim} 
La \ac{API} de \bt{} sólo permite conocer el valor \ac{RSSI} del enlace en la ronda de descubrimiento. Este valor se obtiene a través de un anuncio del sistema que se produce cuando se halla un dispositivo. Sin embargo, no es posible con las herramientas que nos ofrece \android{}, realizar una monitorización continua de este valor mientras se encuentran ambos dispositivos con una conexión abierta. Una manera de conseguir esto, aunque finalmente descartado, es con la herramienta \texttt{hcitool} que se encuentra disponible para Linux, para integrarla hay que recompilarla con el \ac{NDK} sobre las \textit{shared libraries} presentes en el dispositivo.

Para recrear una \textit{piconet} necesitamos que los esclavos estén escuchando en un \textit{ServerSocket} marcado con un \ac{UUID} y sea el maestro quien vaya disparando conexiones a los diferentes dispositivos con el identificador de la \textit{piconet} y vaya añadiendo nodos a ésta. Por propia experiencia del autor, un dispositivo de media-alta gama es el apropiado para ser el maestro de la \textit{piconet}, si no es complicado que pueda manejar el límite teórico de esclavos. El \ac{UUID} de la \textit{piconet} no tiene por qué ser único, dos o más dispositivos pueden publicar su red bajo este identificador. Lo que sí es observable es la incapacidad de un dispositivo para pertenecer a varias \textit{piconets} al mismo tiempo, singular es el dispositivo que puede cooperar en más de cuatro redes distintas.


%-------------------------------------------------------------------
\section{Interfaz de comunicación: Datos Móviles}
\label{sec:mobile-analysis}
%-------------------------------------------------------------------

Debido a que el espectro radioeléctrico es un recurso limitado propiedad de cada país, la discordancia entre asignaciones se evidencia aún más en los sistemas telefónicos que empezaron adoptando soluciones particulares fuera de un estándar común.\\

Los primeros datos móviles se cursaron bajo \ac{GPRS}, un añadido a las redes \ac{GSM} que consiste en hacer las mínimas modificaciones en el interfaz radio dedicando alguno de los canales físicos de voz para paquetes y haciendo una asignación dinámica para cuando no hay demanda de voz~\cite{bates2001gprs}. En ese entonces surgieron tres clases de dispositivos: la clase A capaces de utilizar simultáneamente los servicios de \ac{GPRS} o \ac{GSM}; la clase B, la más común, que no es capaz de simultanear en el tiempo ambos servicios pero alterna entre ambos automáticamente y la clase C, cuyo cambio de servicio se tiene que realizar de manera asistida. Las velocidades alcanzadas varían desde los pocos kbps hasta los 177.6 kbps con las mejora \ac{EDGE} introducida al final de la segunda generación. Las velocidades son siempre dependientes del tipo de dispositivos involucrados y la población de red. En~\cite{gsmBands} vemos un resumen de las bandas de frecuencias asignadas por los diferentes países.

La siguiente generación de redes llamada \ac{UMTS}~\cite{veguillas2003comunicaciones} introducía la tecnología de acceso múltiple \ac{WCDMA} para lograr tasas de hasta 2 Mbps, al igual que su predecesora mantiene circuitos de voz pero mejora los circuitos de paquetes. Soporta tecnologías como \ac{FDD} y \ac{TDD} y todos los dispositivos son capaces de transmitir voz y datos simultáneamente. Estas redes introducen un control de potencia que intenta mantener la potencia de transmisión al mínimo, para ello intenta decrecer siempre este valor hasta que nota una degradación en \ac{QOS} que no es deseable y eleva el nivel de potencia para comenzar otra vez el ciclo. La evolución de esta red se le otorgó el nombre de \ac{HSPA} y recoge varias versiones, todas ellas encaminadas a la convergencia \ac{IP} de las redes, incluyendo modulaciones digitales más eficientes tipo 64 \ac{QAM} llegando a tasas de 21 Mbps, aunque si se utilizan técnicas avanzadas de antena pueden alcanzarse tasas mayores. Sobre la asignación de frecuencias realizada~\cite{umtsBands} se puede ver en algunos casos una reutilización de bandas de \ac{GSM}, los dispositivos suelen ser compatibles con varias de estas bandas para poder operar en más de un territorio o compañía.

La cuarta generación de redes móviles llamada \ac{LTE}~\cite{penuelas20123gpp} es una red \bsq{todo \ac{IP}}: no hay circuitos de voz, tan sólo dominio de paquetes. Respecto al enlace de subida se utiliza la técnica \ac{OFDMA} y para el de bajada la \ac{SCFDMA} alcanzando tasas de 300 Mbps con \ac{LTEA}~\cite{dahlman20134g}. En~\cite{lteBands} vemos que hay nuevas asignaciones en países en desarrollo y la misma reutilización que en los casos anteriores, de hecho como ya vimos, para el futuro se proyectan reasignaciones en países desarrollados para mejorar y permitir tráfico creciente en estas redes~\cite{refarming700}.\\

El diseño del núcleo de estas redes y en general de \textit{Internet} motivado, en parte por la escasez de direcciones \ac{IP}, hacen que las conexiones entre iguales (que no siguen un papel centralizado tal como lo es la figura de un servidor expuesto y accesible desde cualquier punto de la red) presenten problemas. Si queremos comunicar dos \sphone{s} en una red móvil tenemos que hacer frente a varios inconvenientes~\cite{p2pIssues}:
\begin{itemize}
	\item Los dispositivos suelen dormir esta interfaz para minimizar el consumo cuando no están transmitiendo o recibiendo, lo que hace difícil que prestemos un servicio en el que haya que estar escuchando para conexiones entrantes.
	\item El dispositivo no es accesible desde fuera de la red, es decir o bien la operadora por motivos de seguridad bloquea las conexiones entrantes o la \ac{IP} recibida en el dispositivo no es pública y al encontrarse tras un \ac{NAT} no es posible establecer una conexión entrante. Un caso estudiado por el autor es el de Vodafone España, esta operadora no restringe ninguna conexión excepto las de \ac{VOIP}, si el cliente no tiene este servicio suplementario. Sin embargo las tarifas de menor importe asignan direcciones \ac{IP} privadas al dispositivo imposibilitando que actúen como servidores.
	\item Una dificultad menor consiste que en caso de recibir una dirección \ac{IP} pública, ésta no es conocida a priori por los otros dispositivos que quieran establecer una conexión.
	\item El carácter móvil de los dispositivos y la política acerca de qué interfaz de red usar entre las disponibles: por motivos esencialmente económicos, si la interfaz \wifi{} está disponible el dispositivo tenderá a conectarse mediante este método. Si hemos establecido la conexión con la interfaz de red móvil, al caer dentro de una red \wifi{} seremos ocultados por un \ac{NAT}. Esta situación supone que no podamos seguir estableciendo conexiones si no tenemos control sobre esta red para configurar y hacer accesible al dispositivo desde fuera, a parte hemos de comunicar al resto de dispositivos la nueva dirección \ac{IP} pública de la red en la que nos encontremos.
\end{itemize}


\paragraph{}Accedemos a toda la información sobre la interfaz de comunicación móvil con el paquete \texttt{telephony}~\cite{andTelephony}, de entre todas las clases ofertadas, nos resulta interesante la clase \class[android.telephony]{TelephonyManager} de la que obtenemos una referencia a una instancia que mantiene el sistema para poder manejarla. Nos proporciona toda la información de la célula móvil en la que estemos: tipo de red, estado de la conexión, información sobre el propio \sphone{}\ldots
Esta \ac{API} hay que utilizarla en conjunción con la especificada en \class[android.net]{ConnectivityManager} que tampoco es instanciable. Esta clase monitoriza la conexión a \textit{Internet} que tengamos, nos informa cuando la conexión cambia y nos permite hacer consultas o peticiones respecto a éstas. Al igual que esta clase se utiliza en conjunción con la interfaz móvil, la podemos usar con la interfaz \wifi{}. Para utilizar estas \ac{API} necesitamos aceptar estos permisos:
\begin{verbatim}
	- android.permission.ACCESS_NETWORK_STATE;
	- android.permission.CHANGE_NETWORK_STATE;
\end{verbatim}

Para conseguir encender y apagar la interfaz móvil necesitamos recurrir a la técnica \textit{reflection} pues no es una característica, debido al carácter sensible, a la que podamos acceder desde la \ac{API}. Como se muestra en~\cite{turnOnMobileData}, según la versión de \android{} tendremos que usar una clase u otra. Para las versiones más nuevas necesitamos invocar el método \textit{setMobileDataEnabled()} pasando como parámetro un valor booleano que dicte si queremos levantar o apagar la interfaz.   

%-----------------------------------
\subsection{Viabilidad: cambio tipo red}
\label{sec:switchMobileNetwork-analysis}
%-----------------------------------
Sobre esta interfaz no podemos tener mucho control por la razón que dependemos bastante de la operadora que nos de servicio que nos asignará los recursos que considere oportunos. Un objetivo interesante es decidir en cada momento a qué tipo de red queremos conectarnos: 2G, 3G o 4G. Esto nos permite, por ejemplo, acomodar nuestras necesidades de comunicación a nuestras necesidades de batería o otras ya que el gasto de energía no es el mismo según la red elegida.

\android{} permite a través de su aplicación \bsq{Ajustes} elegir el tipo preferido de red a la que conectarse. Sin embargo, al tratarse de un recurso sensible su modificación está reservada al proceso \texttt{com.android.phone} que ejecuta el usuario \texttt{android.uid.system}. Esto nos obliga a que si tenemos que desarrollar una aplicación que llegue a modificar este parámetro, ésta tenga que estar firmada con la misma clave que la aplicación \texttt{phone.apk} y encontrarse instalada en la carpeta \texttt{system/app} para poder adquirir los procesos necesarios.

La aplicación \texttt{phone.apk} viene firmada con la clave del fabricante, esto nos relega a modificaciones del sistema operativo de código libre como lo es CyanogenMod de la cual conocemos su clave. Respecto a la instalación, esa partición del sistema está protegida por lo que para instalar nuestra aplicación recurriremos a la técnica de \textit{flash} accesible desde el menú de recuperación del teléfono, dependiendo del modelo tendremos que desbloquear el \textit{bootloader}. Al ser procesos relativamente difíciles, es recomendable aislarlos en una aplicación pequeña que luego llamaremos desde nuestra aplicación cognitiva, para que no perjudique las actualizaciones del resto de ésta.

La manera de hacer este tipo de cambios de red se ilustra en~\cite{toggle2g}, para ello mediante \textit{reflection} intentamos instanciar la clase \class[com.android.internal.telephony]{PhoneFactory} pues la \class[com.android.internal.telephony]{phone} es una interfaz. Llamamos al método \textit{setPreferredNetworkType()}, este método acepta como parámetros un entero que representa el tipo de red y un objeto \textit{Message}. En este objeto, que utilizamos para recoger el resultado en la cola asociada al objeto \textit{Handler} al que pertenece el \textit{Message}, aprovechamos para incluir en él la información con la que hemos llamado al método y un \textit{timeout} para poder realizar copias de esta llamada garantizando un punto de salida por si \android{} no pudiese satisfacer nuestra petición. 

%-------------------------------------------------------------------
\section{Viabilidad marco cognitivo}
\label{sec:cb-Analysis}
%-------------------------------------------------------------------

Por completar, 
\begin{itemize}
	\item Sensado y adaptación al medio,
	\item aprendizaje y colaboración -> almacenamiento y computo alto. Desarrollo software hablar del sdk libre, del NDK para integrar cosas de C, de la bbdd
	\item otras caracteristicas cognitivas
	\item pocos trabajos y pocos framework - necesidad de usar uno: pequeño resumen del CB
\end{itemize}

%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex
%%% End:
