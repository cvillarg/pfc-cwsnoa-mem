%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\chapter{Diseño}
\label{chap:design}
\begin{FraseCelebre}
	\begin{Frase}
	No es pretender el triunfo,\\ es resistir a los fracasos
	\end{Frase}
	\begin{Fuente} \textit{Def.} Esperanza, {\scriptsize\sc Novena Virgen de la Salud} \end{Fuente}
\end{FraseCelebre}
\begin{resumen}
En este capítulo definimos la arquitectura del nodo cognitivo sobre la cual detallamos las interfaces de programación y los procesos de red involucrados en su funcionamiento.
\end{resumen}


%-------------------------------------------------------------------
\section{Arquitectura cognitiva}
%-------------------------------------------------------------------
\label{sec:arquitecturaCognitiva}
\figura{Vectorial/design/node}{width=.65\textwidth}{fig:architecture}{Arquitectura cognitiva}

Nuestra arquitectura se ha diseñado siguiendo pinceladas del modelo
\ac{CB} \cite{conbrok}. Sin embargo, no se han podido seguir todas las
recomendaciones puesto que no implementamos el objeto \texttt{CompNet}
(distintas redes cooperando para por ejemplo mitigar la interferencia)
y que no tenemos acceso a otros planos que no sea el de aplicación. Al
tener un \textit{hardware} fijo, sin posibilidad de cambios y tener un
control limitado de éste (sólo las partes que \android{} nos permite)
se desvanece la posibilidad de seleccionar activamente la
modulación, la codificación o el nivel de potencia en la
transmisión. Nos restringimos al diseño de una arquitectura
confiando en las propias capacidades cognitivas u optimizaciones que
elige la plataforma de por sí o que son accesibles de alguna u otra
manera: \textit{reflection}, superusuario\ldots\\

%En este primer parrafo creo que despues de la referencia va punto:
%[1]. Sin embargo, no se han podido... %XXX-cvillar OK

%\figura{Vectorial/design/node}{width=.65\textwidth}{fig:architecture}{Arquitectura cognitiva}

Como puede verse en la figura~\ref{fig:architecture} se ha estructurado la arquitectura en dos capas, existiendo una subdivisión de la capa inferior en otras dos. Un modelo de capas permite definir interfaces de comunicación entre las diferentes unidades, limitando el alcance y conocimiento de cada módulo, independizando su propósito del resto. A saber:

\begin{enumerate}
\item \bsq{\bf Capa de aplicación}: Formada por cada una de las aplicaciones que operan sobre el módulo o servicio cognitivo que les sirve como canal de comunicaciones. Cada una de estas aplicaciones debe cumplir con la interfaz definida entre esta capa y la inferior (aplicación y cognitiva). El diseño e implementación de cada aplicación excede a este proyecto y depende en cada caso del tercero que desarrolle la aplicación. No obstante para probar y utilizar las capacidades de nuestro nodo cognitivo se ha desarrollado una aplicación cuyo diseño presentamos en la sección~\ref{sec:app} del presente capítulo e implementación en la sección~\ref{sec:appImpl} del siguiente.
\item \bsq{\bf Capa cognitiva} El interés del proyecto se centra en el desarrollo de esta capa. Es una capa compuesta por otras dos: una primera capa de control donde se recoge toda la inteligencia y propósitos cognitivos y otra capa de actuación que provee de toda la funcionalidad para recibir y enviar datos por cada una de las interfaces de comunicación presentes:
	\begin{enumerate}[i.]
		\item \bsq{\bf Módulo radio cognitiva}, está fuertemente inspirado en los módulos presentes en 
la arquitectura del simulador cognitivo \cite{castaliacwsn} desarrollado en el laboratorio de sistemas
integrados en la \ac{ETSIT} escrito para dotar de estas capacidades a la plataforma \bsq{Castalia}. La 
implementación cuenta con ciertas peculiaridades que veremos a continuación.

%XXX-jblesa No diria sobre Castalia, sino sobre un simulador cognitivo
%desarrollado en el laboratorio de sistemas integrados. %XXX-cvillar OK.

		\item \bsq{\bf Controladores de interfaz}, esta capa está formada por cada una de las interfaces
presentes en el \sphone{}. La implementación final recoge la interfaz de \wifi{} y \bt{}, 
pero el diseño recoge un número arbitrario debido a que si construimos este módulo siguiendo la interfaz
entre capas, puede ser fácilmente añadida a la arquitectura final.
	\end{enumerate}
\end{enumerate}

A continuación haremos una breve descripción de los diferentes bloques que hemos definido en la arquitectura que conforman el nodo cognitivo. Al ser los procesos entidades que hacen uso de más de un bloque, se ha preferido dejar para más adelante (sección~\ref{sec:procesosRed}) su explicación una vez vista la arquitectura. Así se obtienen varios puntos de vista que ayudan a comprender el funcionamiento del nodo.
%---------

\subsection{Interfaz Aplicación - Módulo cognitivo}
El apellido cognitivo supone una abstracción en el modelo de comunicaciones de tal forma que los parámetros, tiempos o detalles de la comunicación usada para transmitir los datos sean transparentes al usuario o aplicación. Para lograr esta abstracción necesitamos un punto de ruptura que aísle y defina solamente la información estrictamente necesaria a intercambiar entre ambos agentes para poder recrear una \ac{CWSN}.\\%En la sección~\ref{sec:api} se expone la definición de la \ac{API} que debe cumplir el desarrollador de las distintas aplicaciones.\\

Al definir una interfaz permitimos que terceros puedan desarrollar sus propias aplicaciones que usen de este \var{Módulo cognitivo} para montar sus comunicaciones, podemos decir que es una interfaz tipo cliente-servidor, donde se permite dar soporte simultáneo a varias aplicaciones. Esto es posible gracias al \var{Gestor de Aplicaciones} que explicamos en la sección~\ref{subsec:sensorManager}.

Esta interfaz, que podemos darle el nombre de \ac{API} del servicio, se basa en el intercambio de mensajes en ambos sentidos: desde \bsq{capa de aplicación} a la \bsq{capa cognitiva} y al revés. Unas veces estos mensajes van acompañados de una respuesta, también en forma de mensaje, para comunicar el resultado de un proceso y otras en cambio son entregados de manera aislada sin previo aviso. En la sección~\ref{sec:api} explicamos en profundidad las singularidades de esta interfaz.

%\subsection{Sensor Manager}
\subsection{Gestor del sensor}
\label{subsec:sensorManager}
Es el punto de entrada a nuestro \var{Módulo cognitivo}, el encargado de
recoger las peticiones de las distintas aplicaciones e informar tanto
de la respuesta a la aplicación que lo solicitó, como al resto de
ellas, si las hubiese, acerca de informaciones comunes generadas en la
\ac{CWSN} donde cooperan. Esto se consigue gracias al submódulo
\var{Gestor de Aplicaciones} que lleva un registro de cada una de las
aplicaciones y permite discernir entre peticiones de éstas. Las
peticiones entrantes son sanetizadas y codificadas para poder disparar
los procesos internos a lo largo de los diferentes módulos y
descodificadas eliminando cualquier rastro cognitivo antes de ser
entregadas a la aplicación en cuestión. La presencia del submódulo
\var{Cola} permite, entre otras funciones que se detallarán, encolar
mensajes de aplicación por si estas peticiones no pudiesen ser
atendidas en el mismo momento de la recepción (fundamentalmente debido
a cambios de contexto). Una vez que las
condiciones lo permitan se consulta a esta cola para ver si quedan
ordenes pendientes.
%XXX-jblesa Ten cuidado con las palabras en ingles. Siempre hay que
%intentar buscar palabras en español.
%----------

\subsection{Políticas, optimizador, ejecutor}
Estos tres módulos podemos considerarlos como el cerebro cognitivo, su
interacción es encadenada: la salida de uno es la entrada del siguiente. 
De acuerdo a unas políticas descritas en el módulo \var{Políticas}, el \var{Optimizador}
evalúa el cumplimiento de ellas conforme a valores que recoge del módulo \var{Repositorio}
que sirve como punto concentrador de la información. Esta evaluación puede
generar nuevos valores a almacenar en el \var{Repositorio} y/o la actuación
directa gracias al módulo \var{Ejecutor}.\\


%XXX-jblesa. Exlica lo de la interaccion jerarquica, no lo veo claro.
%XXX-cvillar Quería decir que La politica es quien gobierna al optimizador
% que utiliza al ejecutor para actuar y cumplir así lo que dice la politica.

Para nuestro primer diseño sólo hemos definido una política cognitiva
(ver sección~\ref{subsec:senseAndPolicy}). El módulo \var{Ejecutor} sólo
realiza cambios de contexto debido a
las limitaciones en la plataforma para ajustar otros parámetros que
finalmente han sido descartados del diseño: \adhoc(), potencia de transmisión, \ac{MTU}, \ac{RSSI} en \bt{} e interfaz de datos móviles.

%XXX-jblesa Dos veces seguidas la palabra cambio. XXX-cvillar done.
%----------

\subsection{Repositorio}
\label{subsec:repository}
Este módulo hace las labores de concentración, estructuración y perseverancia de la información. Los demás módulos a menudo se comunican con otros a través del éste, para ello necesitamos almacenar:
%La información que hemos de guardar en el repositorio es:
%XXX-jblesa. Me falta una pequeña frase introductoria. XXX-cvillar done.

\begin{description}
	\item[Información relativa al Módulo cognitivo:] necesitamos almacenar la interfaz de comunicaciones actual y su estado, así como un valor que nos permita averiguar si el \var{Módulo cognitivo} ha sido destruido por causas ajenas para intentar reconstruir la \ac{CWSN} ante una eventualidad, esta información debe ser persistente. También necesitamos almacenar cuál es el periodo con la que el optimizador y ejecutor actúan en base al tiempo. Si en vez de sobrescribir esta información hacemos un seguimiento, podemos obtener información acerca de la estabilidad y la adaptabilidad de la red.

\item[Información relativa a los nodos en la red:] para hacer un mapa
  de la red necesitamos información acerca de qué nodos hay en la red y cómo llegar a ellos. Los datos elegidos son:
	\begin{itemize}
%		\item Identificador del nodo. Un \integer{} asignado al conocer el nodo por primera vez. 
		\item Identificador del nodo, asignado al conocer el nodo por primera vez. 
%		\item Nombre del nodo. Una \String{} representando el nombre con el que se presenta a la red.
		\item Nombre del nodo, sirve para nombrar a un nodo con un lenguaje humano.
%		\item Papel del nodo. Una \String{} cuya codificación es: \bsq{p} para usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconido).
		\item Papel del nodo, para distinguir usuarios primarios y secundarios.
%		\item Tipo de nodo. Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\bsq{u} para valor desconocido).
		\item Tipo de nodo, nos permite clasificar el nodo entre normal, coordinador y otros.
		\item Dirección \ac{MAC} de \bt{} del nodo, este dato es el elegido para identificar al nodo unívocamente.
		\item Dirección \ac{IP} del nodo.
		\item Identificador de su nodo coordinador, una referencia a un identificador de nodo previamente conocido y que nos permite alcanzar todos sus datos.
	\end{itemize}

\item[Información relativa al sensado:] los datos recogidos por cada dispositivo los almacenamos siguiendo esta estructura:
	\begin{itemize}
%		\item Identificador del nodo, un \integer{} que nos indica quién es el propietario de la información.
		\item Identificador del nodo, que nos indica quién es el propietario de la información.
%		\item RSSI, un \integer{} con el valor en dBm de la intensidad de señal recogida de la red \wifi{}.
		\item RSSI, el valor en dBm de la intensidad de señal observada de la red \wifi{}.
%		\item Tasa de envío, un \double{} con el intervalo de tiempo medio de envios en la red.
		\item Tasa de envío, el intervalo de tiempo medio de envíos de datos en la red.
		\item Marca de tiempo, una referencia al momento en que estos datos fueron obtenidos.
	\end{itemize}
\end{description}

Estos datos son compartidos con el coordinador quien distribuye esta información sin alteraciones.
El módulo \var{Acceso} no hace ningún filtro de esta información, no obstante el diseño contempla valores por defecto que ocultarían la información sensible, por si se quisiese implementar, sin demasiados problemas, un módulo más complejo. Como veremos la compartición de información es completa salvo los datos de sensado que no son compartidos entre todos los nodos. A excepción de ello, el resto de información está distribuida de tal forma que todos tengan la misma foto aunque no
tengan los mismos valores: los identificadores de los nodos en
cada dispositivo varían, la clave que nos permite sincronizar los diferentes repositorios de los
diferentes nodos recae en la dirección \ac{MAC} de \bt{}.

%XXX-jblesa. Quita dummy y pon algo en español. XXX-cvillar ok, reestructurado un poquito.
%----------

\subsection{Sensado}
Este módulo se asemeja a los ojos de nuestra arquitectura, siguiendo
con el anterior símil del cerebro, una ventana al mundo. Ambos módulos (\var{Sensado} y la tripla formada por: \var{Políticas/Optimizador/Ejecutor})
se conectan a través del \var{Repositorio} que actúa como una especie de bus.

%XXX-jblesa. A que modulos te refieres con ambos modulos? XXX-cvillar discovery & policy/optimizer/executor

Este módulo no sólo recoge parámetros (ver sección~\ref{subsec:senseAndPolicy} para conocer en detalle qué datos son sensados), si no que monitoriza el estado de las diferentes interfaces de comunicaciones. Por esta razón parte de este módulo está muy ligado al controlador de la interfaz, sin embargo debido a que ciertas políticas necesitan que el optimizador evalúe parámetros relativos a interfaces de comunicaciones no activas, se ha sacado del diseño del controlador esta parte para añadirla al modulo \var{Sensado}, para que pueda ser manejada en cualquier momento. En la sección~\ref{subsec:btControllerImpl} del siguiente capítulo completamos el por qué de esto. 
%----------

\subsection{Gestor de Interfaces}
Este módulo es el punto de salida del módulo o servicio cognitivo hacia los controladores. En él confluyen dos planos: el primero para los mensajes de aplicación provenientes del \var{Gestor del Sensor} (plano de datos) y el segundo para la elaboración de señalización proveniente del módulo \var{Ejecutor} o de eventos de red generados en el \var{Gestor de Estados} (ver sección~\ref{subsubsec:stateManager}) (plano de control y gestión).\\

En él se implementan todas las funciones de encaminamiento que son necesarias transmitir a los controladores pues estos no conocen nada del plano cognitivo, son meras palancas de acción. En este módulo también implementamos el submódulo \var{Acceso} encargado de compartir con el resto de nodos parte de nuestro \var{Repositorio} que es enviado por el canal \var{VCC}. 

El diseño del canal \var{VCC} encargado de transmitir toda la información de control y gestión de la \ac{CWSN} se ubica en la misma red por la que circulan los datos, a diferencia de otros sistemas como el \ac{SS7} \cite{ss7} por razones de simplicidad. De hecho el mismo canal comparte ambos tráficos, la manera de distinguirlos recae en el etiquetado con la que van codificados los distintos mensajes de red~\ref{subsec:networkMessages}. Sin embargo, la arquitectura no cierra las puertas a que el plano de datos y el de control sean transmitidos en distintas interfaces de comunicación, por ejemplo datos en \wifi{} y señalización en \bt{}.

%----------

\subsection{Interfaz Módulo cognitivo - Controlador}
\subsubsection{Comunicación hacia controlador: Invocación de métodos}
La forma de comunicarse con el controlador de la interfaz de comunicación es mediante la invocación directa de métodos del propio controlador. Para homogeneizar la interacción entre el \var{Módulo cognitivo} y los \var{Controladores} haciendo que ésta se produzca de forma similar con todas las interfaces, se deben implementar una serie de métodos cuya funcionalidad se adecue a las singularidades pero que mantenga unos puntos de entrada y salida semejantes. Se ha decidido que estos métodos sean llamadas asíncronas que no devuelvan ningún valor. La respuesta se obtiene en el \var{Gestor de Interfaces} cada vez que el proceso desencadenado en el controlador decide comunicarse a través de su \var{Gestor de Estados}. Los métodos que un controlador debe implementar para cumplir con la interfaz en este sentido son:
\begin{description}
	\item[start()]\hfill {\sc Método de inicialización}\\[7pt]Este método nos permite configurar el controlador según los requerimientos que tenga el módulo o servicio cognitivo.
	\item[stop()]\hfill{\sc Método de destrucción}\\[7pt]Gracias a él, se liberan todos los recursos (menos los relacionados con el módulo \var{Sensado} para permitir que se sigan obteniendo datos de sensado del espectro aunque no esté activa).
	\item[write()]\hfill{\sc Método para enviar datos o señalización}\\[7pt]Para escribir cualquier tipo de información sobre la red:
	\begin{itemize}
		\item\bsq{Plano de datos}: canal de datos.
		\item\bsq{Plano de control}: canal \var{VCC}.
	\end{itemize}
\end{description}
%----------

\subsubsection{Comunicación hacia módulo: Gestor de estados}
\label{subsubsec:stateManager}
Permite establecer una comunicación unidireccional basada en mensajes desde los distintos \var{Controladores} hacia el \var{Módulo cognitivo} en cualquier momento de tiempo. Estos mensajes son consecuencia de procesos bien disparados por el servicio cognitivo al invocar métodos del controlador (desde el módulo \var{Ejecutor}) o bien originados en el propio controlador al tratarse de un evento de red, reflejando el estado en el que se encuentra el controlador.

\paragraph{Wi-Fi} Los diferentes estados y eventos en los que pueden estar la interfaz \wifi{}:%\\
\smTableInit{\textit{Gestor de Estados Wi-Fi}}
	\smTableRow{STATE\_none}{event\_no\_device\_changes}	
	\smTableRow{STATE\_listening}{EVENT\_NODE\_JOINED}
	\smTableRow{STATE\_sending}{EVENT\_NODE\_EXITED}
	\smTableRow{STATE\_receiving}{EVENT\_HELLO\_NOT\_SUCCEEDED}
\smTableEnd{Gestor de estados Wi-Fi}{wifiStateManager}
%~\\
\paragraph{Bluetooth} De manera análoga los diferentes estados y eventos en los que pueden estar la interfaz \bt{}:
\smTableInit{\textit{Gestor de Estados Bluetooth}}
	\smTableRow{STATE\_none}{event\_no\_device\_changes}	
	\smTableRow{STATE\_listen}{EVENT\_node\_joined}
	\smTableRow{STATE\_connecting}{EVENT\_device\_LOST}
	\smTableRow{STATE\_connected}{EVENT\_CONNECTING\_DEVICE\_FAILED}
	\smTableRow{STATE\_sending}{EVENT\_CONNECTION\_ALREADY\_EXISTING}
	\smTableRow{STATE\_receiving}{}
\smTableEnd{Gestor de estados Bluetooth}{btStateManager}

La información recibida de cada controlador corresponde a cada uno de los eventos y estados que veremos en la \ac{API} (ver sección~\ref{subsec:serviceInfo}) de forma que las singularidades de cada interfaz sean ocultadas más allá del \var{Módulo cognitivo}.


\section{API del servicio: Interfaz Aplicación - Módulo cognitivo}
%-------------------------------------------------------------------
\label{sec:api} %% API DEL SERVICIO %%
%-------------------------------------------------------------------
Como se comentó, el diseño de esta interfaz se fundamenta en el intercambio de mensajes. Cada funcionalidad de esta interfaz está respalda por uno o varios mensajes modelando procesos de petición y respuesta. Cada uno de estos mensajes va clasificado con una etiqueta y acompañado de la información necesaria para realizar un proceso o informar del resultado.

\miniTableInit[!h]{.4}{}{Clasificación Mensajes Intercambiados}
	\miniTableRow{register\_client}
	\miniTableRow{unregister\_client}
	\miniTableRow{register\_data\_exchange}
	\miniTableRow{OUTGOING\_CONTENT}
	\miniTableRowNI{OUTGOING\_CONTENT\_PROGRESS}
	\miniTableRow{OUTGOING\_CONTENT\_RESULT}
	\miniTableRowNI{INCOMING\_CONTENT\_PROGRESS}
	\miniTableRow{INCOMING\_CONTENT}
%
	\miniTableSwitch{.02}{.5}{}
	\miniTableRow{SERVICE\_INFORMATION}
	\miniTableRow{ERROR\_MESSAGE}
	\miniTableRow{QUEUED\_MESSAGE}
	\miniTableRow{CONNECT\_VIA\_BT}
	\vspace{0.5em}
	\miniTableRow{{\fontsize{9pt}{10pt}\selectfont WORKAROUND}\_WHAT\_TO\_REPLY}
	\miniTableRow{{\fontsize{9pt}{10pt}\selectfont WORKAROUND}\_ASK\_RESPONSE}
%	\miniTableRow{{\fontsize{9pt}{10pt}\selectfont WORKAROUND}\_CONTEXT\_CHANGE}
	\miniTableRow{{\fontsize{9pt}{10pt}\selectfont WORKAROUND}\_SWITCH\_interface}
	\miniTableRow{{\fontsize{9pt}{10pt}\selectfont WORKAROUND}{\tiny\_}PENDINGMESSAGE{\tiny\_}put}
	\miniTableRow{{\fontsize{9pt}{10pt}\selectfont WORKAROUND}{\tiny\_}PENDINGMESSAGE{\tiny\_}send}
\miniTableEnd{Mensajes tipo intercambiados a través de la API del servicio}{apiMessages}
Las filas en {\bf\color{notImplemented} gris} corresponden a mensajes reservados no implementados. Tendrían uso si el \var{Módulo cognitivo} segmentase los mensajes que les entregase las aplicaciones para su envío en trozos más pequeños para adecuarse a directrices cognitivas. Las filas precedidas por \Scst{WORKAROUND} son mensajes que se salen del redil  para poder disparar procesos manualmente, corresponden por tanto a funciones de \textit{test} cuyo cumplimiento no es necesario para un correcto funcionamiento.

\subsection{Conectarse al módulo cognitivo}
\label{subsec:apiStart}
La manera de inicializar la comunicación con el \var{Módulo cognitivo} comienza con la petición de atadura al servicio cognitivo, tras el establecimiento debemos empezar una pequeña negociación para que ambos agentes (\var{Aplicación} y \var{Módulo cognitivo}) acuerden los términos de la colaboración. Esta negociación consiste en el intercambio de tres mensajes:
\begin{enumerate}
\item	El primer mensaje del tipo \Scst{REGISTER\_CLIENT} sirve para que el \var{Módulo cognitivo} reconozca a la aplicación y la incluya en su registro de clientes. En la tabla~\ref{tab:registerClientMessage} se nos detalla cómo debemos informar este mensaje.

\item Acto seguido la aplicación debe aportar datos sobre ella con el envío del segundo mensaje calificado como \Scst{REGISTER\_DATA\_EXCHANGE} que podemos ver en la tabla~\ref{tab:registerExchangeMessage} del siguiente capítulo. La información que debe aportar son los parámetros propios de la aplicación:
	\begin{itemize}
		\item \textbf{Papel del nodo} indicando si somos un usuario primario o secundario.
		\item \textbf{Código de aplicación} que sirve al servicio cognitivo para distinguir entre las distintas aplicaciones registradas.
	\end{itemize}

\item Con estos dos mensajes el \var{Módulo cognitivo} actuará teniendo en cuenta su situación previa a la negociación y devolverá un resultado que comprende:
	
\paragraph{En situación red no existente} Si el \var{Módulo cognitivo} no estuviese colaborando en ninguna red antes de comenzar esta negociación, la información recibida (en esta y en todas las aplicaciones), tiene el formato podemos ver en la tabla~\ref{tab:endHandshakingNotCWSNMessage}:
	\begin{itemize}
		\item \textbf{Estado de la interfaz} (ver tabla~\ref{tab:infoHandshaking}).
		\item \textbf{Interfaz de comunicación en curso}: \wifi{} o \bt{}, la interfaz de datos móviles finalmente no está implementada.
		\item \textbf{Papel del nodo finalmente adoptado}, puede darse la circunstancia de que las características que reclama la aplicación no puedan ser satisfechas por el servicio, por ello informamos de nuevo qué tipo nodo somos, en la sección~\ref{subsec:updateSettings} se detalla en profundidad este tema. 
		\item \textbf{Resultado de la configuración de la interfaz de comunicación en curso}, indicando el éxito o fracaso del proceso.		
		\item \textbf{Nombre del nodo}, como nos conocen los demás nodos en la red. 
		\item \textbf{Tipo de nodo}, indicando si se trata de un nodo normal o un nodo coordinador. Finalmente la figura del nodo subcoordinador temporal en \bt{} no está implementada.
		\item \textbf{Periodo de la tarea cognitiva}, el tiempo medido en segundos entre ejecuciones de las funciones de optimización y adaptación de la red en situación normal. Como veremos la aplicación puede proponer un periodo por si éste no fuese apropiado para sus necesidades.
	\end{itemize}	
No obstante estos tres últimos parámetros trascienden a cualquier aplicación (ver sección~\ref{subsec:updateSettings} para más detalle). Son parámetros del \var{Módulo cognitivo} los cuales pueden ser obviados por la aplicación pues no los necesita para su funcionamiento.

En esta situación antes de recibir este mensaje, es probable que nos hayan llegado mensajes del tipo \Scst{SERVICE\_INFORMATION}. Éstos informan sobre procesos de configuración y entrada en la red.

\paragraph{En situación de red previa} Si otra u otras aplicaciones estuviesen previamente registradas colaborando en una \ac{CWSN}, la información suministrada esta vez en exclusiva a esta aplicación por el \var{Módulo cognitivo} cambia ligeramente. En la tabla~\ref{tab:endHandshakingInCWSNMessage} vemos cómo se estructura la siguiente información:
	\begin{itemize}
		\item Contiene algunos de los mismos campos con el mismo significado: ``Estado de la interfaz'', ``Interfaz de comunicación en curso'', ``Papel del nodo finalmente adoptado'', ``Nombre del nodo'', ``Tipo de nodo'' y ``Periodo de la tarea cognitiva''.
		
		\item \textbf{Código de aplicación}, el servicio cognitivo nos devuelve este valor a modo de eco. Que se informe este campo coge sentido cuando la aplicación ha hecho una actualización de sus parámetros, esto permite validar que el proceso ha ido bien.
		
		\item \textbf{Lista de nodos}, los nodos que se encuentran en este momento cooperando en la red.
	\end{itemize}  
\end{enumerate}

En la sección~\ref{subsec:serviceRegisterProcess} veremos por qué hemos separado el proceso de registro en tres mensajes en vez de dos.

%\miniTableInit[!h]{.5}{Información intercambiada en la negociación}{Clasificación Mensajes Intercambiados}
%	\miniTableRow{register\_client}
%	\miniTableRow{unregister\_client}
%	\miniTableRow{register\_exchange}
%	\miniTableRow{OUTGOING\_CONTENT}
%	\miniTableRowNI{OUTGOING\_CONTENT\_PROGRESS}
%	\miniTableRow{OUTGOING\_CONTENT\_RESULT}
%	\miniTableRowNI{INCOMING\_CONTENT\_PROGRESS}
%	\miniTableRow{INCOMING\_CONTENT}
%	\miniTableRow{SERVICE\_INFORMATION}
%	\miniTableRow{ERROR\_MESSAGE}
%	\miniTableRow{QUEUED\_MESSAGE}
%	\miniTableRow{CONNECT\_TO\_VIA\_BT}
%	\vspace{0.5em}
%	\miniTableRow{WORKAROUND\_WHAT\_TO\_REPLY}
%	\miniTableRow{WORKAROUND\_ASK\_RESPONSE}
%	\miniTableRow{WORKAROUND\_CONTEXT\_CHANGE}
%	\miniTableRow{WORKAROUND\_PENDINGMESSAGE\_INJECTION}
%	\miniTableRow{WORKAROUND\_PENDINGMESSAGE\_DISPOSAL}
%
\miniTableInit[!h]{.5}{Información intercambiada en la negociación}{Estado de la Interfaz}
%	\miniTableSwitch{.1}{.4}{Estado de la Interfaz}
	\miniTableRow{INTERFACE\_STATE\_DOWN}
	\miniTableRow{INTERFACE\_STATE\_IDLE}
%	\miniTableRow{INTERFACE\_STATE\_IDLE\_} \miniTableRow{\hspace*{1.7em}NETWORKING}
	\miniTableRow{INTERFACE\_STATE\_IDLE\_CONNECTED}
	\miniTableRow{INTERFACE\_STATE\_CONNECTING}
	\miniTableRow{INTERFACE\_STATE\_SENDING}
	\miniTableRow{INTERFACE\_STATE\_RECEIVING}
%
	\miniTableHeader{Papel del nodo}
	\miniTableRow{secondary}
	\miniTableRow{Primary}
%
	\miniTableSwitch{.04}{.4}{Interfaz de comunicación}
%	\miniTableHeader{Interfaz de comunicación}
	\miniTableRow{Bluetooth}
	\miniTableRow{Wi-Fi}
	\miniTableRowNI{Mobile}
%
	\miniTableHeader{Tipo de nodo}
	\miniTableRow{Normal}
	\miniTableRow{Coordinator}
	\miniTableRowNI{temp\_subcoordinator\_on\_BT}
%
\miniTableEnd{Información involucrada en el proceso de negociación}{infoHandshaking}

%----------
\subsection{Incluir nodos a la red en Bluetooth}
\label{subsec:connectViaBT}
Cuando la interfaz de comunicación en curso sea \bt{} y seamos un nodo coordinador, podemos incluir nodos en la red de manera activa. Para ello necesitamos enviar un mensaje del tipo \Scst{CONNECT\_VIA\_BT} incluyendo el nodo al que nos queremos conectar. Si la información del nodo no fuese válida se devolverá como veremos un mensaje de error del tipo \Scst{ERROR\_CODE\_NODE\_NO\_EXISTS} o \Scst{ERROR\_CODE\_ILLEGAL\_ARGUMENT} según corresponda, al igual que si la interfaz en curso no es \bt{}.

La información proporcionada puede ser información relacionada con el nodo ya conocido o con la dirección \ac{MAC} de \bt{} para nodos completamente nuevos. En la tabla~\ref{tab:connectToBT} vemos su implementación. 

%----------
\subsection{Recibir datos de otros nodos}
En el momento en que el \var{Módulo cognitivo} recibe datos de otro nodo, se entregan a la aplicación cuyo ``código de aplicación'' coincida con el que viene marcado en el mensaje recibido. La información que se entrega a la aplicación correspondiente, mediante el tipo \Scst{INCOMING\_CONTENT} (cuya implementación vemos en la tabla~\ref{tab:incomingContent}) es:
\begin{itemize}
	\item {\bf Contenido recibido}, el contenido del mensaje enviado por otra aplicación por la red.
	\item {\bf Nodo originario}, el nodo desde el cual nos han enviado el mensaje.
\end{itemize}

%----------
\subsection{Enviar mensajes de datos a otros nodos}
\label{subsubsec:api_sendData}
Para enviar un mensaje por la red utilizamos un mensaje del tipo \Scst{OUTGOING\_CONTENT} con la siguiente información, en la tabla~\ref{tab:outgoingContent} vemos el detalle de cómo construir el mensaje:
\begin{itemize}
	\item {\bf Contenido}, la información útil del mensaje, el dato del sensor. Debe ser codificado como una \String{}.
	\item {\bf Lista de nodos destinatarios}, a partir de la información que nos haya entregado la \bsq{capa cognitiva} sobre la población en la red.
\end{itemize}

%----------
\subsection{Confirmación entrega de datos a otros nodos}
Al enviar un mensaje de datos, el \var{Módulo cognitivo} responderá a la aplicación que le envió el mensaje de datos cuando haya terminado el proceso de envío mediante un mensaje catalogado como \Scst{OUTGOING\_CONTENT\_RESULT}. En la tabla~\ref{tab:outgoingContentResultApp} se explica la estructura de información que entrega la \bsq{capa cognitiva} que incluye:
\begin{itemize}
	\item {\bf Número de mensajes correctamente entregados}.
	\item {\bf Número de mensajes no entregados}.
	\item {\bf Contenido enviado}, se nos envía de vuelta el contenido del mensaje enviado para que la aplicación pueda reconocer entre envíos que haya hecho.
	\item {\bf Lista de nodos a los que no se ha entregado el mensaje}, este campo irá relleno si ha habido uno o más fallos en la entrega del mensaje.
\end{itemize}

%----------
\subsection{Informe previo a la entrega de datos encolados}
Sucede que cuando el \var{Módulo cognitivo} no puede proceder al envío de los mensajes de datos proporcionados por las aplicaciones, éstos se encolan. La razón radica en que la \ac{CR} debe proporcionar un entorno transparente al usuario de ella, independizando y dando una solución al problema de indisponibilidad en los cambios de contexto. Una vez terminado se retoma el envío, no sin antes comprobar si ha habido un cambio en la lista de nodos.

En este momento el \var{Módulo cognitivo} avisa a las aplicaciones cuyos mensajes han sido encolados comunicándoles el envío de los mensajes. Esta información incluye:
\begin{itemize}
	\item \textbf{Porción de la lista de nodos que ya no están activos}, el subconjunto de la lista de nodos a los que estaba dirigido el mensaje pero que ya no se encuentran en la red. Y a los cuales no enviaremos el mensaje para no provocar fallos innecesarios en los \var{Controladores}.

	\item \textbf{Porción de la lista de nodos válida}, el subconjunto de la lista de nodos que siguen cooperando en la red, a éstos serán los que intentaremos enviar el mensaje de datos.

	\item \textbf{El contenido del mensaje enviado previamente}, sirve para que la aplicación reconozca qué mensaje envió.\\

{\sf Nota:} Si el mensaje estuviera dirigido a todos los nodos de la red, en la porción de la lista de nodos válida se informa de todos los nodos que forman la población actual de la red. Así la aplicación tiene una manera de conocer quién recibirá el mensaje.
\end{itemize}
Con este reporte dejamos a la aplicación en la misma situación como si enviase ahora el mensaje de datos. Este mensaje va grabado con el tipo \Scst{QUEUED\_MESSAGE}, en la tabla~\ref{tab:queuedMessage} vemos la composición de este mensaje. Al recibir este mensaje, la aplicación queda a la recepción del mensaje de confirmación de envío que acabamos de explicar.

%----------
\subsection{Información sobre el servicio cognitivo}
\label{subsec:serviceInfo}
El \var{Módulo cognitivo} comunica a todas sus aplicaciones registradas información acerca de eventos y procesos ocurridos en la red. El \var{Gestor de interfaces} aglutina la información recibida de cada uno de los \var{Controladores} y la uniformiza para su entrega a las \var{Aplicaciones} (su estructura se ve en la tabla~\ref{tab:serviceInformation}). Estos mensajes van catalogados como \Scst{SERVICE\_INFORMATION}, reflejan cada cambio puntual que se produce dentro de un proceso de red. Finalmente estos mensajes dan paso a la comunicación del proceso de red oportuno con su resultado final.

La información que se suministra en este tipo de mensajes es:
\begin{itemize}
	\item \textbf{Interfaz de comunicaciones en curso} (ver tabla~\ref{tab:infoGatheredFromService}).
	\item \textbf{Nodo coordinador}, la figura del nodo coordinador. Si somos el nodo coordinador este campo está vacío.
	\item \textbf{Nodo que propició el evento}, un evento de red tiene dos agentes de red involucrados. Uno de ellos propicia la acción que atañe a otro nodo de la red.
	\item \textbf{Estado de la interfaz} (ver tabla~\ref{tab:infoGatheredFromService}).
	\item \textbf{Evento producido en la red} (ver tabla~\ref{tab:infoGatheredFromService}).
	\item \textbf{Lista de nodos}. En caso de que el evento propiciado introdujese cambios en la población de la red, se informaría de toda la población de red actualizada.
\end{itemize}

\miniTableInit[!h]{.38}{Información suministrada por el servicio}{Interfaz de comunicaciones}
	\miniTableRow{(ver tabla}~\ref{tab:infoHandshaking})
	\miniTableHeader{Estado de la interfaz}
	\miniTableRow{(ver tabla}~\ref{tab:infoHandshaking})
	\miniTableHeader{Eventos}
	\miniTableRow{EVENT{\footnotesize\_}INTERFACE{\footnotesize\_}NO{\footnotesize\_}CHANGES}
	\miniTableRow{EVENT{\footnotesize\_}INTERFACE{\footnotesize\_}NODE{\footnotesize\_}JOINED}
%	
	\miniTableSwitch{.05}{.5}{}
%	
	\vspace{-1.6em}
	\miniTableRow{EVENT\_INTERFACE\_NODE\_EXITED}
	\miniTableRow{EVENT\_INTERFACE\_CANNOT\_CONNECT}
	\miniTableRow{EVENT{\footnotesize\_}INTERFACE{\footnotesize\_}ALREADY{\footnotesize\_}CONNECTED}
	\miniTableRow{EVENT\_INTERFACE\_SWITCHING\_TO\_BT}
	\miniTableRow{EVENT\_INTERFACE\_SWITCHING\_TO\_WIFI}
	\miniTableRowNI{EVENT\_INTERFACE\_SWITCHING\_TO\_MOBILE}
	\miniTableRow{EVENT\_INTERFACE\_SWITCHING\_ENDED}
	\miniTableRow{EVENT\_LIST\_NODES\_UPDATED}
\miniTableEnd{Información entregada a las aplicaciones desde el servicio cognitivo}{infoGatheredFromService}

%----------
\subsection{Mensajes de error: Incumplimiento de la API del servicio}
Cuando el \var{Módulo cognitivo} detecta ciertas anomalías o alguna aplicación no cumple con la \ac{API} del servicio, se notifica a la aplicación que corresponda. No se ha realizado un estudio exhaustivo sobre la casuística de valores entregados por las aplicaciones que se les presupone buena fe. A través de un mensaje catalogado como \Scst{ERROR\_MESSAGE} como el que podemos ver en la tabla~\ref{tab:errorMessage} se informa sobre algunas situaciones (ver tabla~\ref{tab:APIerrorMessages}):

\begin{itemize}
	\item \textbf{Parámetro no válido}: la aplicación no incluye el campo que permite identificarla, la negociación se realiza con parámetros no válidos o intentamos conectarnos a un nodo en \bt{} cuando la interfaz de comunicación en curso es otra.
	\item \textbf{No estamos en red} e intentamos enviar un mensaje de datos.
	\item \textbf{Nodo no válido}, el servicio cognitivo no reconoce como activo el nodo al cual queremos enviar un mensaje de datos.
	\item \textbf{Error interno}: fallos en los \var{Controladores}, otros\ldots 
\end{itemize}

El mensaje entregado a la aplicación incluye una descripción con más detalle sobre la situación producida.

\miniTableInit[!h]{.4}{}{Clasificación Mensajes de Error}
	\miniTableRow{ERROR{\footnotesize\_}CODE{\footnotesize\_}NOT{\footnotesize\_}IN{\footnotesize\_}NETWORK}
	\miniTableRow{\footnotesize{ERROR\_CODE\_NODE\_NOT\_EXISTING}}
	\miniTableRow{ERROR\_CODE\_INTERNAL}
%
	\miniTableSwitch{.03}{.5}{}
%
	\miniTableRow{ERROR\_CODE\_ILLEGAL\_ARGUMENT}
	\miniTableRow{ERROR{\footnotesize\_}CODE{\footnotesize\_}MESSAGE{\footnotesize\_}NOT{\footnotesize\_}RECOGNIZED}
	\miniTableRow{ERROR\_CODE\_ILLEGAL\_PAYLOAD}
\miniTableEnd{Mensajes de error obtenidos desde la API del servicio}{APIerrorMessages}

%----------
\subsection{Actualización de parámetros de aplicación}
\label{subsec:apiUpdateParams}

Si una aplicación quiere actualizar sus parámetros (``código de aplicación'' y ``papel del nodo'') puede hacerlo en cualquier instante enviando el segundo mensaje de la negociación vista en la sección~\ref{subsec:apiStart}. Tras esto recibiremos al igual que entonces un tercer mensaje confirmándonos los cambios hechos.

%----------
\subsection{Desconectarse del servicio cognitivo}
Para que una aplicación deje de colaborar con la \bsq{capa cognitiva} debe primero enviar un mensaje del tipo \Scst{UNREGISTER\_CLIENT} cuyo formato podemos ver en la tabla~\ref{tab:unregisterClientMenssage}. Una vez enviado necesitamos ejecutar una petición para dejar de estar atados al servicio cognitivo. Tras estos dos pasos la aplicación está totalmente desligada del \var{Módulo cognitivo}.

%\subsubsection*{\phantom{0}\hspace{1em}API oculta del servicio}
\subsection{API \bsq{oculta}~del servicio}
%\subsubsection*{\hspace*{1em}API oculta del servicio}
\label{subsubsec:darkAPI}
La \ac{API} del servicio tiene ciertos comportamientos que podríamos denominar de \textit{test} o soluciones alternativas para disparar de forma manual ciertos comportamientos. Hasta aquí cualquier aplicación que se precie debe cumplir y soportar los mensajes de la \ac{API} del servicio. Sin embargo, los comportamientos que se explican a continuación, no es necesario que estén soportados. La aplicación empaquetada junto con el servicio cognitivo sí los soporta.

%----------
\subsubsection{Actualización de parámetros del servicio cognitivo}
\label{subsubsec:darkApiUpdateParams}
Como veremos en la sección~\ref{subsec:updateSettings} los parámetros que gobiernan a un nodo cognitivo son más que los entregados por las aplicaciones. De hecho, hemos visto que en el tercer mensaje de la negociación se comunica a las aplicaciones sobre otros parámetros: ``tipo de nodo'', ``nombre del nodo'' y ``periodo tarea cognitiva''. Estos parámetros deben tener la posibilidad de ser modificados para adecuar al nodo cognitivo a cualquier \ac{CWSN}.\\

Para ello utilizamos el mismo proceso de actualización de parámetros (sección~\ref{subsec:apiUpdateParams}) pero con una estructura de mensaje distinta que permita, por una parte comunicar todos los parámetros y por otra que sea reconocible para que el servicio cognitivo actúe actualizando sus parámetros. En la tabla~\ref{tab:updateAllParamsMessage} vemos el formato de este tipo de mensajes que permiten la actualización en bloque tanto de los parámetros de aplicación como los del \var{Módulo cognitivo}.

Dependiendo del estado del \var{Módulo cognitivo} la viabilidad de la actualización cambia: si estamos cooperando en una \ac{CWSN} no se permite un cambio en el tipo de nodo. No obstante, remitimos nuevamente al lector a la sección~\ref{subsec:updateSettings} donde se explica en detalle estas actualizaciones. La aplicación comprueba si su petición ha podido ser atendida cuando recibe el tercer mensaje de la negociación que envía el servicio cognitivo al recibir esta actualización.

%----------
\subsubsection{Forzar cambio de contexto}
Si somos un nodo coordinador podemos forzar un cambio de contexto de forma manual entre las dos interfaces implementadas: \wifi{} y \bt{}. Para ello, utilizando un mensaje tipo \Scst{WORKAROUND\_SWITCH} como el que podemos ver en la tabla~\ref{tab:wa_switch} propiciaremos el cambio de contexto a la otra interfaz de comunicaciones no utilizada en ese momento.


%----------
\subsubsection{Almacenar y liberar datos encolados}
Por los motivos que explicaremos en la sección~\ref{sec:app}, si la aplicación mantiene la lista de nodos actualizada en todo momento, es muy probable que no sepa enviar un mensaje en el transcurso de un cambio de contexto debido a que haya marcado todos sus nodos como inactivos. Por ello el servicio cognitivo, habilita una manera de encolar mensajes de datos y de liberar la cola de mensajes en cualquier momento.

Para mandar un mensaje de datos que se encole directamente, debemos enviar un mensaje del tipo \Scst{WORKAROUND\_PENDINGMESSAGE\_PUT} cuya estructura podemos ver en la tabla~\ref{tab:wa_queue}, la información que debemos suministrar es la misma que al enviar un mensaje de datos normal (ver sección~\ref{subsubsec:api_sendData}). En el caso de querer dar salida a la cola de mensajes debemos enviar un mensaje catalogado como \Scst{WORKAROUND\_PENDINGMESSAGE\_SEND} sin ninguna información adicional.

%----------
\subsubsection{Mensaje de petición y respuesta}
Un mecanismo interesante presente en muchas \ac{CWSN} es la petición de información desde el nodo coordinador a un nodo normal. En nuestra arquitectura este flujo se utiliza cuando el nodo coordinador incluye por primera vez un nodo nuevo en \bt{} para preguntarle por su nombre y su papel. Este sistema que en principio se montó como una función del módulo \var{Ejecutor}, se ha decidido mantenerlo para el apartado de \textit{test} de la aplicación desarrollada.\\

Un nodo normal puede elegir la respuesta que suministrará cuando sea requerida mediante el envío desde la aplicación de un mensaje catalogado como \Scst{WORKAROUND\_WHAT\allowbreak\_TO\allowbreak\_REPLY}. Por otra parte una aplicación en el nodo coordinador puede pedir la información almacenada en un nodo normal con la ayuda de un mensaje (ver tabla~\ref{tab:wa_ask}) tipo \Scst{WORKAROUND\_ASK\_RESPONSE}. Al recibir la información, el \var{Módulo cognitivo} del nodo coordinador comunica con el mismo tipo de mensaje esta información, ver tabla~\ref{tab:wa_ask_response}. Esta información está dirigida a todas sus aplicaciones registradas, puesto que el mensaje que viene por la red no está marcado con ningún ``código de aplicación''. Por este motivo se desaconseja su uso fuera de las funciones de \textit{test} puesto que puede desconcertar a otras aplicaciones pues no esperan ninguna respuesta, no obstante las aplicaciones de un tercero puede hacer caso omiso a este tipo de mensajes.

%----------
% FIN API
%----------

%-------------------------------------------------------------------
\section{Procesos de red}
%-------------------------------------------------------------------
\label{sec:procesosRed}
Cuando ocurren eventos en la red son manejados por los distintos nodos según sea su tipo, propagando la información necesaria para que toda la red pueda reconstruir desde su propia perspectiva la misma situación actual. Veremos quién dispara y el por qué de estos eventos, cómo se informa y en qué casos a las aplicaciones montadas sobre el servicio del nodo cognitivo. Como ya se comentó, los procesos atañen a más de un bloque de la arquitectura, lo que ayuda a comprender las relaciones entre los distintos módulos. A menudo la \ac{API} del servicio cognitivo (sección~\ref{sec:api}: interfaz Aplicación - Módulo cognitivo) se ve involucrada pues es donde empieza o finaliza la acción de estos procesos.
%------------------------------
\subsection{Registro de una aplicación en el servicio cognitivo}
\label{subsec:serviceRegisterProcess}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service (manejador de mensajes entre servicio y aplicaciones)
%\end{files}
%\end{codeInvolved}
Para que una aplicación pueda registrarse de forma correcta en el \var{Módulo cognitivo} debe cumplir una cierta inicialización consistente en el intercambio de tres mensajes. El primero (\Scst{REGISTER\_CLIENT}) servirá para que el \var{Gestor de Aplicaciones} incluya a la aplicación en su base de clientes. El segundo (\Scst{REGISTER\_DATA\_EXCHANGE}) para que la aplicación le informe de sus parámetros y el tercero (también denominado \Scst{REGISTER\_DATA\_EXCHANGE}) será una confirmación por parte del \var{Módulo cognitivo} hacia la aplicación o aplicaciones informando de todos los parámetros de éste tras el intercambio de la nueva aplicación.

%XXX-jblesa quita handshaking y ponlo en español. XXX-cvillar handshaking = inicialización??

%Como hemos visto ya en la \ac{API} (ver sección \ref{sec:api}), tras
%la petición de atadura al servicio, que inicializará a éste si no
%estuviese arracando ya, obtendremos el \textit{Messenger} del
%servicio, indispensable para poder comunicarnos con él. A continuación
%debemos mandar un primer mensaje para registrar nuestra aplicación en
%el servicio, donde éste, registrará nuestro messenger para habilitar
%la comunicación en sentido contrario y nos incluirá en su lista de
%aplicaciones registradas. Los detalles de este mensaje pueden verse en
%la tabla~\ref{tab:registerClientMessage}

%XXX-jblesa pon bind en español XXX-cvillar ... sí y cómo? atadura??

%El siguiente mensaje (ver tabla~\ref{tab:registerExchangeMessage}) que debemos enviar, informaremos acerca de nuestros parámetros de aplicación como son: nuestro papel, un entero cuyo valor \bsq 0 corresponde a papel secundario y el valor \bsq 1 corresponde al papel primario y nuestro código de aplicación, útil para que el servicio nos entregue sólo los mensajes que nos atañen.

La petición de atadura junto al envío de estos mensajes arrancarán y configurarán al \var{Módulo cognitivo}. Los dos primeros mensajes están separados para poder reutilizar el segundo mensaje para incluirlo en el flujo descrito en~\ref{subsec:apiUpdateParams} o~\ref{subsec:updateSettings} de manera aislada. Con la información enviada al servicio cognitivo  actuará de una forma u otra dependiendo del punto en que se encuentre: %Al terminar nos responderá con el tercer mensaje que refleja la situación la que se encontraba el servicio antes de recibir la información por parte de la aplicación.

\subsubsection{CWSN no establecida}
\umlsdInit
	\newthread[gray]{srv}{Servicio} \newinst[2]{app}{Aplicación}
	\callSelf{app}{Aplicación.init()}	
	\begin{call}{app}{bind()}{srv}{messenger}
		\callSelf{srv}{Servicio.init()}
	\end{call}
	\mess{app}{Register client}{srv}
	\mess{app}{Register data exchange}{srv}
	\callSelf{srv}{Configuración interfaz}
	\mess{srv}{Register exchange}{app}
\umlsdEnd{Proceso de negociación partiendo de una CWSN no configurada y servicio no inicializado}{endHandshakingNotInCWSN}

Esta situación, la más común, se produce cuando la petición de atadura ha arrancado el \var{Módulo cognitivo} y por tanto estamos en una situación inicial o por el contrario, ya hay aplicaciones montadas sobre éste pero no hay conectividad con otros nodos, en otras palabras, estamos solos en la red. En la figura~\ref{fig:endHandshakingNotInCWSN} se ilustra un ejemplo cuando el \var{Módulo cognitivo} no está arrancado.

En esta situación configuraremos la interfaz no importando si estuviese ya. Actualizaremos los parámetros pasados en el anterior mensaje y lanzaremos nuevamente los procesos de registro en la red para intentar establecer una \ac{CWSN}. Al finalizar éstos (ver sección~\ref{subsec:configInterface}) el \var{Módulo cognitivo} devolverá a todas las aplicaciones registradas la información acerca de los parámetros y el estado actual de la red (ver listas de la sección~\ref{subsec:apiStart}). En la tabla~\ref{tab:endHandshakingNotCWSNMessage} puede verse el detalle de este tercer mensaje que finaliza el proceso de inicialización y que nos permite conocer el estado en el que se encontraba el servicio cognitivo antes de recibir la información por parte de la aplicación.

\subsubsection{CWSN previamente configurada}
\umlsdInit[h!]
	\newthread[gray]{srv}{Servicio} \newinst[2]{app}{Aplicación}
	\callSelf{app}{Aplicación.init()}		
	\begin{call}{app}{bind()}{srv}{messenger}
	\end{call}
	\mess{app}{Register client}{srv}
	\mess{app}{Register data exchange}{srv}
	\mess{srv}{Register data exchange}{app}
\umlsdEnd{Proceso de negociación con CWSN ya configurada}{endHandshakingInCWSN}

Puede darse el caso que, en este punto del proceso, ya haya aplicaciones montadas sobre el servicio cognitivo y estén cooperando en una \ac{CWSN}. En este caso el \var{Módulo cognitivo} no tiene que configurar nada y se limita a satisfacer, si se dan las circunstancias, las necesidades que le acaba de transmitir la nueva aplicación que acaba de registrar, es decir, cambiará el papel del nodo a primario si éste era secundario. Un cambio en sentido contrario será ignorado. 

Una vez hecho esto devolverá en exclusiva a la aplicación solicitante los parámetros del servicio cognitivo (ver tabla~\ref{tab:serviceSettings}) y el estado de la interfaz. En la tabla~\ref{tab:endHandshakingInCWSNMessage} se observa la estructura del tercer mensaje que completa la configuración o inicialización.

%------------------------------
\subsection{Configuración de la interfaz de comunicación}
\label{subsec:configInterface}
%%diseño+implementacion
\comp{D+I: 
Tras recibir el \textit{handshaking} de registro de la aplicación, el servicio si no se encuentra colaborando en una \ac{CWSN}, procede a la configuración de una interfaz de comunicación, esta configuración se realiza en una \textit{AsyncTask} de \android{} que permite descargar la \textit{UI-Thread} evitando errores del tipo \textit{ANR ``Application Not Responding''} ya que parte de la tarea se ejecuta en segundo plano, además este tipo de tarea habilita mecanismos de paso de información entre ambas hebras. Antes de configurar una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos (llamando a su método \textit{stop}) para  poder partir de una situación deseable.
}
%%---
Tras recibir el segundo mensaje de la negociación entre aplicación y \var{Módulo~\allowbreak cognitivo}, si éste no se encuentra colaborando en una \ac{CWSN} procede a la configuración de la última interfaz de comunicación usada, por defecto \bt{}. Antes de empezar la configuración de una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos para que el proceso minimice todo lo posible sus necesidades.
 
\subsubsection{Wi-Fi: servicio y controlador}
%\begin{codeInvolved}
%\begin{files}m
%\textbf{Service}: SetupWifiInterface (AsyncTask)\\
%\textbf{WifiController}: stop(), start() / StatusReceiver\_wifi (BroadcastReceiver)
%\end{files}
%\end{codeInvolved}
%%diseño+implementacion
\comp{I+D: 
La interfaz \wifi{} permite configurarse en varias modalidades como:
Infraestructura, Tethering o Ad-hoc. En la actualidad sólo está
implementado el modo infraestructura por los problemas descritos en
\ref{sec:analisisWifi}. Una vez lanzada la tarea en segundo plano, lo
primero que hacemos es intentar parar las hebras asociadas a la
interfaz \wifi{} que cerrarán los \textit{ServerSockets} y el
\textit{BroadcastReceiver} útil para registrarse a eventos de
información relativa a la interfaz \wifi{} como son \ac{RSSI} y los
eventos de conexión/desconexión a un punto de acceso. Partiendo de una
situación en que todos los recursos están liberados, encendemos la
interfaz si no lo estuviese ya, esperamos a que se encienda mediante
una espera de consulta a una variable que es modificada por
\textit{StatusReceiver\_wifi.java}, nuestro \textit{BroadcastReceiver}
para la interfaz \wifi{}. Si nos han pasado como parámetro el \ac{SSID},
intentamos conectarnos a él desconectándonos del punto de acceso
actual si no fuese el mismo. Esperamos mediante \textit{polling} con
límite de tiempo seleccionable desde las preferencias en la sección de
\textit{test}. Si agotamos el tiempo y no hemos sido capaces de
conectarnos, devolvemos un valor \false{} que provoca el envío de
mensaje a todas las aplicaciones del tipo {\small REGISTER\_DATA\_EXCHANGE}
con el campo EXTRA ``errorSetupInterface'' a \true{}. Si por el
contrario nuestro \textit{BroadcastReceiver} ha podido capturar la
acción de conexión al citado punto de acceso o ya estamos conectados a
éste continuamos arrancando las hebras del controlador dependiendo del
tipo de nodo que seamos:

%XXX-jblesa No funciona la referencia sec:analisisWifi XXX-cvillar aún no está escrita, aún así esto es un compentario, el texto está abajo.

\paragraph{Nodo normal} Arrancamos una hebra que escuche gracias a un \textit{ServerSocket} para que acepte conexiones \ac{TCP}, una vez estemos escuchando en el puerto indicado, enviamos el mensaje de tipo {\small REGISTER\_DATA\_EXCHANGE} con el campo {\small EXTRA} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red (sección~\ref{subsec:enterInNetwork}).

\paragraph{Nodo coordinador} Arrancamos un par de hebras, una para tráfico TCP que admita conexiones fiables y otra para el tráfico UDP que escuche y capture paquetes, si todo se ha configurado bien enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.
}
%---
La interfaz \wifi{} permite configurarse en varias modalidades tales como: infraestructura, \textit{tethering} o \adhoc{}. Aunque sólo está implementado el modo infraestructura debido a los problemas descritos en la sección~\ref{sec:wifi-analysis} ya que complican la implementación del nodo cognitivo en distintos terminales. 

Una vez lanzada la tarea intentamos liberar los recursos que vamos a solicitar por si éstos estuvieran reservados por llamadas anteriores y no se hubiesen liberado aún. La configuración comienza encendiendo la interfaz con la ayuda de la \ac{API} de \android{}, si no lo estuviese ya. Una vez terminada la espera para levantar la interfaz, intentamos conectarnos a la red \wifi{} que nos hayan pasado como parámetro (mediante el \ac{SSID}), desconectándonos del punto de acceso actual si no fuese el mismo. Si por el contrario, no nos han pasado ningún parámetro dejamos al sistema \android{} que elija el \ac{AP} más conveniente. Esperamos mientras se establece la conexión al punto de acceso, sin embargo esta espera está limitada para evitar un retraso excesivo (seleccionable desde el menú de preferencias: sección~\ref{sec:app}). Si agotamos el tiempo y no hemos sido capaces de conectarnos, devolvemos un valor \false{} que provoca el envío de un mensaje del tipo \Scst{REGISTER\_DATA\_EXCHANGE} a todas las aplicaciones con el campo \textit{extra} ``errorSetupInterface'' a \true{}. Si por el contrario hemos podido capturar el evento de conexión al citado \ac{AP} o ya estamos conectados a éste, continuamos estableciendo los canales de comunicación apropiados al tipo de nodo que seamos:

\paragraph{Nodo normal} Necesitamos tener un canal de comunicación permanentemente a la escucha para tráfico \ac{TCP} recibido desde el coordinador. Una vez establecido terminamos la configuración enviando un mensaje de tipo \Scst{REGISTER\_DATA\_EXCHANGE} con el campo \textit{extra} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red (sección~\ref{subsec:enterInNetwork}).

\paragraph{Nodo coordinador} Necesitamos tener dos canales de comunicación, uno para tráfico proveniente de nodos ya en la red, este tráfico necesitamos que sea fiable por lo que será un canal \ac{TCP} y otro canal para recibir avisos de nuevos nodos que se quieran incorporar a la red, este tráfico por motivos de implementación no puede ser fiable por lo que tendremos que recurrir a tráfico \ac{UDP}. Al terminar de establecer los canales enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.


\subsubsection{Bluetooth: servicio y controlador}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: SetupBTinterface (AsyncTask)\\
%\textbf{BluetoothController}: stop(), start(), connect(), setState() / StatusReceiver\_bt (BroadcastReceiver)
%\end{files}
%\end{codeInvolved}
%%diseño+implementacion
\comp{D+I:
Como en el controlador de \wifi{} empezamos (en segundo plano) liberando si no estuviesen ya cada uno de los recursos, en \bt{} coexisten, dependiendo del tipo de nodo, tres tipos de hebras: la que acepta conexiones (\textit{AcceptThread}), la que lanza la conexión (\textit{ConnectThread}) y la que mantiene la conexión entre el esclavo y el maestro (\textit{ConnectedThread}), de este tipo podemos tener más de una.
Encendemos la interfaz \bt{} si no estuviese encendida ya, mediante una petición al sistema \android{} y esperando mediante \textit{polling} a que \textit{StatusReceiver\_bt.java}, el \textit{BroadcastReceiver} para la interfaz \bt{} modifique la variable de control de esta espera. Una vez finalizada, procedemos a configurar las hebras del controlador según el tipo de nodo.
\paragraph{Nodo normal} Este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita arrancar una hebra para aceptar conexiones, como sólo esperamos un maestro cuando consigue una conexión (disparada sobre el mismo UUID por el que hemos registrado el socket) liberamos este recurso. Como ya hemos configurado la interfaz enviamos el mensaje final del \textit{handshaking} (ver tabla~\ref{tab:endHandshakingNotCWSNMessage}) con las instrucciones que hemos visto ya.

\paragraph{Nodo coordinador} Este tipo de nodo se comporta como maestro en la comunicación \bt{}, no necesita aceptar conexiones, pero si disparar éstas. Para ello, recogemos de la base de datos los nodos inactivos y para cada uno de ellos lanzamos una conexión gracias al método connect() que se ejecuta en su propia hebra para asegurarnos que no se ejecuta en la hebra de la interfaz de usuario, en este caso no hace falta ya que la estamos llamando desde el segundo plano, pero como veremos este método se llama también directamente desde la UI-thread. Este método coge como parámetros la dirección \ac{MAC} con la cual queremos establecer una conexión y el número de intentos que vamos a intentar establecer esta conexión (a parte de otras constantes como el \ac{UUID}), como en \bt{} es fácil que falle el establecimiento intentamos minimizar este riesgo reintentando la conexión. En el momento que conseguimos establecer la conexión, liberamos esta hebra que se volverá a crear con el siguiente intento de conexión a otro nodo y manejamos la conexión con una nueva hebra del tipo \textit{connectedThread}, al final tendremos tantas hebras como nodos activos en la red. La forma en la que sabemos cuando podemos pasar al siguiente nodo radica en 2 flags que son modificadas gracias al sistema de estados: setState(), que tienen los controladores. En esencia, cuando disparamos una conexión y ésta falla propagamos un estado de conexión fallida al \var{Gestor de Interfaces} quien lleva la cuenta de las conexiones fallidas. Si la conexión se produce con éxito se propaga análogamente un estado de nuevo nodo en la red, lo que nos permitirá salir de la espera en la que nos encontramos, bien por establecimiento de la conexión o bien por llegar al máximo de intentos.

 Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje del \textit{handshaking} con el formato visto en la tabla~\ref{tab:endHandshakingNotCWSNMessage}
}
%------

Como en la configuración del controlador de \wifi{} empezamos liberando cada uno de los recursos no necesarios en este momento. Encendemos la interfaz \bt{} si no estuviese ya encendida mediante una petición al sistema \android{} y esperamos a que finalice. A continuación, procedemos a configurar el controlador según el tipo de nodo:

\paragraph{Nodo normal} Por motivos de implementación este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita aceptar conexiones. Al esperar solamente un maestro, cuando se consigue esta conexión liberamos el recurso de aceptación de conexiones. Como ya hemos configurado la interfaz enviamos el tercer mensaje de la negociación (ver tabla~\ref{tab:endHandshakingNotCWSNMessage}) con las instrucciones que hemos visto ya.

\paragraph{Nodo coordinador} En cambio este tipo de nodo se debe comportar como maestro en la comunicación \bt{}, no necesita aceptar conexiones pero sí disparar éstas. Para ello obtenemos del \var{Repositorio} los nodos inactivos y para cada uno de ellos lanzamos una conexión. El proceso de conexión necesita conocer la dirección \ac{MAC} con la cual queremos establecer una conexión y el \ac{UUID} utilizado.\\ 
Como en \bt{} es fácil que falle el establecimiento, más aún cuantos más nodos hay en la \textit{piconet}, intentamos minimizar este riesgo mediante el reintento de la conexión, cuyo número de intentos es pasado como parámetro. En el momento que conseguimos establecer el canal de comunicación, trasladamos éste al manejador de conexiones del controlador que tendrá tantos canales como nodos haya en la red. Estos canales son cifrados y fiables por diseño de \android{}. Cada vez que se consigue o se falla en el establecimiento del canal, el controlador comunica al \var{Gestor de Interfaces} esta información que es utilizada para saber cuándo hemos de establecer el canal de comunicación con el siguiente nodo.

Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje de la negociación o intercambio.


%------------------------------
\subsection{Registro de un nodo en la red}
\label{subsec:enterInNetwork}

Según la interfaz en la que nos encontremos, se alterna el papel de quién es el que da el primer paso. Así en \bt{} el nodo normal espera una conexión entrante y en \wifi{} es el coordinador quien espera un paquete enviado desde un nodo normal.
\subsubsection{Registro sobre Wi-Fi}
%\begin{codeInvolved}
%\begin{files}
%\textbf{WifiController}: SendHelloPacket (AsyncTask), UDPlistener (Thread), stopSendingHelloPacket(), setState()\\
%\textbf{Service}: mHandlerWf, sendInfoNewNodeOnNetwork()\\
%\textbf{Database}: eventNewDeviceIPCoordinator(), newDeviceEventNormal(), modifyNode()
%\end{files}
%\end{codeInvolved}
%%diseño+implementación
\comp{D+I:
Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otro proceso que comienza a enviar paquetes cada 800 milisegundos hasta llegar a un máximo de 20. La razón de enviar una ráfaga de paquetes radica en que al ser trafico broadcast/multicast los puntos de acceso pueden menospreciarlo (incluso bloquearlo) y el mismo dispositivo \android{} puede que no esté escuchando siempre en este tipo de direcciones. De hecho cuando se apaga la pantalla, el driver de \wifi{} se reconfigura automáticamente para dejar de escuchar a la dirección de broadcast, por ello una ráfaga de 20 paquetes espaciados en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta el proceso de registro terminará enviando hacia el \var{Gestor de Interfaces} el estado {\small (EVENT\_HELLO\_NOT\_REACHED)} que será interpretado por éste informando a todas las aplicaciones registradas del fallo del proceso indicando que no ha sido posible establecer una \ac{CWSN} {\small (EVENT\_INTERFACE\_CANNOT\_CONNECT)}.\\
}
%------

Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otro proceso por el que comienza a enviar una ráfaga de paquetes espaciados en el tiempo. La razón radica en que el tráfico \textit{broadcast/multicast} puede ser menospreciado tanto por los puntos de acceso \wifi{} que pueden bloquearlo, como por el mismo dispositivo \android{} que puede que no esté escuchando en ese momento en este tipo de direcciones. De hecho cuando se apaga la pantalla, el \textit{driver} de \wifi{} se reconfigura automáticamente para dejar de escuchar en la dirección de difusión. 

En vista de ello una ráfaga espaciada en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Este tipo de paquetes lo denominamos \textit{``HelloPacket''}, su estructura puede verse en la tabla~\ref{itm:helloPacket} en el siguiente capítulo. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta, el proceso de registro terminará enviando hacia el \var{Gestor de Interfaces} el estado \Scst{EVENT\allowbreak\_HELLO\allowbreak\_NOT\allowbreak\_SUCCEEDED} que será interpretado por éste informando a todas las aplicaciones registradas del fallo del proceso, indicando que no ha sido posible establecer una \ac{CWSN}. En este caso, el evento facilitado a las aplicaciones se transforma en \Scst{EVENT\allowbreak\_INTERFACE\allowbreak\_CANNOT\allowbreak\_CONNECT} que concentra el mismo tipo de evento en distintos controladores, uniformando la respuesta.
%%%%%%%%%%%%%%%%
\comp{esto a implementación:\\
\protobufTableInit{Estructura mensaje registro en la red \wifi{}}
  \item[\fbox{\colorbox{green}{Tipo de paquete}}]\hfill\\[3pt] Valor ``HELLO'' del enumerado ``packetType''
	%\\\rule{2cm}{0.4pt}
	\item[\fbox{Hello packet}]\hfill\\[3pt] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo de paquete''
	%\\\noindent\rule{\textwidth}{0.4pt}
	\begin{description}
		\item[\fbox{Nombre del nodo en la red}]\hfill\\[3pt] Una \String{}  con el nombre del nodo en la red
		\item[\fbox{Papel del nodo}]\hfill\\[3pt] Una \String{} cuyo valor \bsq{p} es interpretado como primario y \bsq{s} como secundario (\bsq{u} para valor desconido)
		\item[\fbox{Tipo de nodo}]\hfill\\[3pt] Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\textcolor{notImplemented}{\bsq{t} coordinador temporal en \bt{} [sin implementar]}, \bsq{u} para valor desconocido)
		\item[\fcolorbox{blue}{red}{Dirección MAC}]\hfill\\[3pt] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca
	\end{description}
\protobufTableEnd{Campos del paquete ``HelloPacket''}{helloPacket}
}
%%%%%%%%%%%%%%%%%
Si por el contrario uno de los paquetes llega a destino y es manejado por el coordinador, se procederá a la interpretación del contenido dentro del mismo controlador. Esta ruptura del modelo de capas tiene como objetivo evitar propagar información al \var{Módulo cognitivo} acerca de paquetes que no encajen con la estructura y campos requeridos. El controlador entiende cómo manejar estos paquetes pero no el resto. Si capturamos un \textit{``HelloPacket''} generaremos un evento hacia el \var{Gestor de Interfaces} indicando que hay un nuevo nodo en la red \Scst{EVENT\_ENTERED\_IN\_NETWORK} con la información leída del paquete. 

\figura{Vectorial/design/entradaRed-wf-coord}{width=.7\textwidth}{fig:entradaRed-wf-coord}{Flujograma de los procesos desencadenados en el coordinador al introducir un nodo en \wifi{}}

Este evento llega al \var{Gestor de interfaces}, %(más concretamente al \textit{Handler} de \wifi{})
donde lo primero que hacemos es ver si el nodo ya está registrado en la red
(este paso es necesario porque tenemos varios envíos del mismo paquete
por parte del mismo nodo). Si ya está registrado ignoramos durante una guarda de
tiempo este evento, pues es una copia de otro anterior. Esta guarda está motivada porque en \wifi{} no se
detecta inmediatamente que un nodo se ha caído de la red. Sólo nos
podemos dar cuenta cuando intentamos enviarle algo y obtenemos un
error. Puede darse la situación de que un nodo se registre, se caiga e
intente registrarse de nuevo. Si en este lapsus de tiempo nadie ha intentado
ponerse en contacto con él, el resto de nodos seguirán creyendo que el
nodo está en la red, si ignorásemos este evento permanentemente, el nodo que está intentado cerrar su registro en la red no tiene manera de saber que en realidad a ojos de los demás nodos él ya está registrado en la red, creyendo que su \textit{``HelloPacket''} no ha llegado a destino resultando una situación de falso fallo. Si no estaba activo en la red lo marcamos como activo (insertándolo, si no estuviese ya, en el \var{Repositorio} con la información facilitada por el controlador) y ponemos en marcha la guarda.
Acto seguido el coordinador informará a este nodo del resto de nodos que ya hay en la red y al resto de nodos de la red se les informará del nuevo nodo. Por su parte el coordinador informará a las aplicaciones registradas que ha habido un nuevo nuevo nodo en la red y facilitará la lista de nodos actualizada.

La información de señalización que se envía y que representa %\footnote{Notar que el campo ``Dirección IP'' puede no ser informado por no estar disponible en ese momento o ser inecesario} 
al nodo la podemos ver en la tabla~\ref{itm:infoNode}, esta información está encapsulada en un mensaje de señalización junto con otra información relevante al evento.

\comp{esto a implementación:\\
\protobufTableInit{Estructura mensaje representación de un Nodo (serialización)}
	\item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red.
	\item[Papel del nodo] Una \String{} cuyo valor \bsq{p} es interpretado como usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconocido).
	\item[Tipo de nodo] Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador  (\textcolor{notImplemented}{\bsq{t} coordinador temporal en Bluetooth [sin implementar]}, \bsq{u} para valor desconocido).
	\item[Dirección MAC] Un \String{} cuyo valor es la dirección MAC en \bt{} del nodo, clave que identifica al nodo de manera unívoca.	
	\item[Dirección IP] Una \String{} cuyo valor representa la dirección IP (formato IP4) del nodo.
	\item[Dirección MAC del coordinador] Una \String{} que contiene la dirección MAC de \bt{} del coordinador del nodo que estamos enviando la información.
\protobufTableEnd{Representación de un nodo necesaria para recrear el mapa de red, contenido del mensaje de señalización}{infoNode}
}

Mientras el nodo normal está recibiendo esta información, el controlador correspondiente le habrá informado a través del \var{Gestor de Estados} de la situación de recibir datos. Este evento le sirve al \var{Módulo cognitivo} para saber que ha sido registrado en la red. Con lo que él mismo genera un evento de entrada en la red \Scst{EVENT\_ENTERED\_IN\_NETWORK} que sirve para homogeneizar el flujo y que sea idéntico al de \bt{}. Además este evento sirve para parar el envío de \textit{``HelloPacket''}. 

Al terminar de recibir el mensaje de señalización antes de procesarlo tendremos que comprobar que el nodo coordinador está incluido ya en el \var{Repositorio}. La razón radica en que necesitamos conocer el identificador del nodo para poder recrear el mapa de red. Si el coordinador no estaba ya incluido, incluimos su dirección \ac{MAC} que se obtiene haciendo un procesamiento mínimo del mensaje, así logramos obtener el identificador del nodo. A medida que vamos procesando el mensaje más profundamente, vamos sustituyendo los valores antiguos del \var{Repositorio} (y de relleno si el nodo coordinador no estaba incluido) por los nuevos valores extraídos del mensaje de señalización. En este momento el nodo normal informará a las aplicaciones de que ha entrado en la red gracias al mensaje visto en la sección~\ref{subsec:serviceInfo} con el evento \Scst{EVENT\_INTERFACE\_NODE\_JOINED} (visto en la tabla~\ref{tab:infoGatheredFromService}) y anunciará la lista de nodos y quien es el coordinador. \comp{es oportuno decir que por motivos de eficiencia, solo hacemos una pasada por el mensaje} 

\subsubsection{Registro bajo Bluetooth}
%\begin{codeInvolved}
%\begin{files}
%\textbf{BluetoothController}: connected(), setState()\\
%\textbf{Service}: mHandlerBt, sendInfoNewNodeOnNetwork()\\
%\textbf{Database}: newDeviceEventNormal(), modifyNode(), updateInfoDeviceCoordinator()
%\end{files}
%\end{codeInvolved}

Como hemos explicado antes, es ahora el coordinador quien tiene que dar el primer paso. De hecho cuando se configura la interfaz, se incluye una ronda de conexión a los nodos inactivos. Al establecerse el canal de comunicaciones tanto el nodo coordinador como el nodo normal informan a sus respectivos servicios cognitivos que se ha producido un evento de nodo nuevo \Scst{EVENT\_NODE\_JOINED}.

\paragraph{Nodo normal} Al recibir el evento conexión al coordinador vemos si éste está en el \var{Repositorio}. Si no lo estuviese, incluiríamos su dirección \ac{MAC} para obtener su identificador y pospondríamos el anuncio del nuevo nodo hacia las aplicaciones hasta obtener el mensaje de señalización donde se informa de las características del resto de nodos en la red. Si por el contrario ya habíamos cooperado antes con este nodo, anunciaremos de inmediato hacia las aplicaciones el evento de conexión al nodo coordinador. Notar que los parámetros del nodo coordinador (nombre y papel) pueden ser valores que no corresponden con la situación actual, no es una cosa que nos deba preocupar pues en primer lugar son parámetros cuyo cambio suele ser puntual y en segundo lugar será solventado momentos después al recibir la señalización con información sobre la población en la red.

\figura{Vectorial/design/entradaRed-bt-coord}{width=.6\textwidth}{fig:entradaRed-bt-coord}{Flujograma de los procesos desencadenados en el coordinador al introducir un nodo en \bt{}}

\paragraph{Nodo coordinador} El flujo (ilustrado en la figura~\ref{fig:entradaRed-bt-coord}) también comienza preguntándonos si habíamos cooperado ya con el nodo al que acabamos de conectarnos. Si no estuviese en el \var{Repositorio}, le enviamos un mensaje de petición de información para que nos informe de su nombre y papel, ya que su dirección \ac{MAC} y su tipo (normal) lo sabemos porque o nos lo facilita los \var{Controladores} o porque es deducible por el contexto. El nodo normal al recibir este mensaje envía sus datos, que el coordinador procesa como si fuese una actualización de parámetros en la red más, lo que conlleva modificar los datos del nodo que nos lo envía y la propagación de éstos al resto de nodos. Además en este caso como el nodo no estaba en la red, se le envía información sobre el mapa de red cerrando el proceso de registro y se anuncia hacia las aplicaciones la entrada de un nuevo nodo. En la tabla~\ref{tab:serviceInformation} vemos la estructura de este mensaje.

%XXX-jblesa A quien te refieres con ``que nosotros procesamos'' en el parrafo anterior? XXX-cvillar nosotros es en este caso el coordinador.


%------------------------------
\subsection{Salida de un nodo de la red}
\label{subsec:salidaNodoRed}

\figura{Vectorial/design/salidaRed}{width=.6\textwidth}{fig:salidaRed}{Flujo salida red}

La dificultad en el proceso de salida de un nodo de la red viene marcada tanto por la interfaz como por el tipo de nodo que se trate. Es un proceso que tiene dos lados: por una parte la del nodo que se desregistra de la red y por otra la de los nodos que siguen cooperando en red.\\
Un nodo se desregistra de la red cuando no quedan aplicaciones montadas sobre el \var{Gestor de Aplicaciones}. Para que una aplicación se desregistre del \var{Módulo~\allowbreak cognitivo} tiene que mandar una petición para dejar de estar atada pero que debe ser precedida por un mensaje del tipo \Scst{UNREGISTER\_CLIENT} (ver tabla~\ref{tab:unregisterClientMenssage}). Con este mensaje el servicio cognitivo sabrá que tiene que borrar de su base de clientes la aplicación y la petición liberará la conexión creada por \android{} entre ambos. 

%XXX-jblesa quita unbind y ponlo en español. XXX-cvillar done.

%El flujo que relaciona aplicación y servicio destruye a éste cuando todas las peticiones de \textit{bind} son correspondidas con sus \textit{unbind}. Parecido pasa con las peticiones de \textit{start} y \textit{stop} (en el caso general una única petición de \textit{stop()} destruye al servicio no importando cuantas peticiones de \textit{start()} haya habido). \android{} tiene este tándem para decidir si un servicio debe seguir vivo o no. Como las peticiones de \textit{start} son disparadas por el propio servicio para realizar de forma periódica su tarea cognitiva, ha sido necesario modificar el ciclo de vida para que cuando el servicio deje de tener aplicaciones sobre él, se destruya a si mismo y no automáticamente como normalmente ocurriría. 

Cuando se libera esta conexión los pasos a seguir antes de destruir el \var{Módulo cognitivo} son: la preparación del \var{Repositorio} y otros módulos para que estén preparados para una nueva instancia del servicio cognitivo. Estas acciones comprenden borrar las direcciones \ac{IP} y el identificador del coordinador para cada nodo, así como el marcaje de éstos como inactivos. Por último, una indicación que denote que el \var{Módulo cognitivo} ha sido parado de forma voluntaria para darnos cuenta de posibles cierres forzados, de tal forma que al instanciar de nuevo éste, siempre se tenga una situación de partida inicial. 
Estas acciones no son ejecutadas si la salida es forzosa: debido a un error no manejado que provoque el cierre o debido a la falta de memoria que provoca que el gestor de \android{} cierre la aplicación. En el caso de no encontrar la marca de cierre voluntario del \var{Módulo cognitivo} al arrancar, se puede realizar estas acciones al comienzo para desembocar en la misma situación inicial.\\

Según la interfaz de comunicaciones en la que nos encontremos, el nodo que sale de la red tendrá una manera diferente de avisar al resto de nodos que se quedan:
%Entre las acciones a ejecutar por el nodo que sale de la red tenemos que dependiendo de la interfaz la forma de avisar al resto de nodos que se quedan varía:
\subsubsection{Salida bajo Wi-Fi}
%\begin{codeInvolved}
%\begin{files}
%\textbf{WifiController}: sendbyePacket(), sendbyePacketReliable(), SendByePacket (AsyncTask)\\
%\textbf{Service}: mHandlerWF, eventLostActionsNormal(), onDestroy(), onCreate()\\
%\textbf{Database}: lostNode()
%\end{files}
%\end{codeInvolved}

En esta interfaz tenemos una conexión intermitente que se despliega y se retrae en los momentos en los cuales hay comunicación. En esta situación ante eventualidades no tenemos el mismo tiempo de reacción como lo podemos tener en \bt{}. En el caso de salida voluntaria necesitamos un mecanismo que informe que un nodo va a abandonar la red.

Este mecanismo consiste en el envío de un paquete llamado \textit{``ByePacket''} (ver detalle en figura~\ref{itm:byePacket}) que contiene la dirección \ac{MAC} del nodo que abandona la red. El envío de este paquete puede ser sobre \ac{TCP} o \ac{UDP}. En el caso de que el envío sea desde el nodo coordinador, sólo podremos mandarlo sobre \ac{TCP} ya que los nodos normales no escuchan sobre \ac{UDP} como hemos visto en la sección~\ref{subsec:configInterface} donde se explica la configuración de las distintas interfaces.\\
%%diseño+impletacion
\comp{D+I:
Este envío se realiza gracias a otra \textit{AsyncTask} que al finalizar libera los recursos del controlador cerrando la vida de la aplicación por completo.
%}
%%--

\protobufTableInit{Estructura mensaje desregistro en la red \wifi{}}
  \item[Tipo de paquete] Valor ``BYE'' del enumerado ``packetType''.
	\item[Bye packet] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo de paquete'':
	\begin{description}
		\item[Dirección MAC] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca.
	\end{description}
\protobufTableEnd{Campos del paquete ``ByePacket''}{byePacket}
}

Las acciones a ejecutar por los nodos que se quedan en la red son:

\figura{Vectorial/design/salidaRed-event}{width=.7\textwidth}{fig:salidaRed-event}{Flujograma tras recibir el evento desde el propio controlador de pérdida de un nodo}


\paragraph{Nodo normal} En \wifi{} tenemos dos formas de recibir el evento de pérdida de nodo:
\begin{itemize} 
	\item A través de un evento generado en el controlador tras la recepción de manera fiable del paquete \textit{``ByePacket''} por parte del coordinador. Procederemos a marcar a todos los nodos como inactivos y demás información volátil de la \ac{CWSN}. Por otra parte informamos a las aplicaciones registradas de la pérdida del nodo y de la salida de la red. 
\item Mediante un mensaje de señalización por parte del coordinador con la información de pérdida de un nodo. En este caso procedemos a marcar en exclusiva a este nodo como inactivo e informar a las aplicaciones registradas del nuevo mapa de red.
\end{itemize}

\figura{Vectorial/design/salidaRed-signaling}{width=.7\textwidth}{fig:salidaRed-signaling}{Flujograma tras recibir mediante señalización del evento de pérdida de un nodo}

\paragraph{Nodo coordinador} Al recibir el paquete \textit{``ByePacket''} se generará el evento de pérdida de nodo que se entregará al \var{Gestor de Interfaces}. Marcaremos este nodo como inactivo y veremos si aún quedan nodos en la red. Si la respuesta es afirmativa enviaremos un mensaje de señalización (cuyo detalle se explica en la figura~\ref{itm:lostNode}) a cada nodo restante en la red informando de la pérdida, así ellos podrán recomponer el mapa de red e informar a sus aplicaciones. Informamos también a nuestras aplicaciones registradas del evento y de la nueva lista de nodos. Si la respuesta es negativa nos limitamos a informar a las aplicaciones registradas del evento de pérdida y del evento de salida de la red.


%XXX-jblesa. En todos los apartados cambiaria Normal y Coordinador por
%Nodo normal y Nodo coordinador. XXX-cvillar vale.

\subsubsection{Salida bajo Bluetooth}
%\begin{codeInvolved}
%\begin{files}
%\textbf{BluetoothController}: connectionLost(), setState()\\
%\textbf{Service}: mHandlerBt, eventLostActionsNormal(), onDestroy(), onCreate()\\
%\textbf{Database}: lostNode()
%\end{files}
%\end{codeInvolved}

En este caso tenemos una conexión abierta en todo momento, por lo que ante cualquier eventualidad nos daremos cuenta inmediatamente de la pérdida de la conexión, lo que hace innecesario el mecanismo descrito en la sección anterior.
%%diseño+implementacion
\comp{D+I:
Tanto si se trata de una salida voluntaria como involuntaria, se
destruye tanto la aplicación como el servicio y se liberan todos los recursos. Al cerrarse el controlador de \bt{}, las hebras que haya abiertas desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de que el \textit{socket} usado en la comunicación ha sido cerrado, lo que supone que el controlador detecte el cierre de la conexión y lance el evento de pérdida de nodo.
}
%%---
Tanto si se trata de una salida voluntaria como involuntaria, se destruye tanto la aplicación como el nodo cognitivo y se liberan todos los recursos. Al cerrarse el controlador de \bt{}, los canales de comunicación abiertos desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de la desaparición de éstos y se lance el evento de pérdida de nodo desde ambos extremos.\\

Las acciones a ejecutar por los nodos que se quedan en la red son:
\paragraph{Nodo normal} Al igual que en el caso anterior podemos percibir la pérdida de un nodo tanto por un evento del controlador como por señalización. 
El evento elevado hasta el
\var{Gestor de Interfaces} por el \var{Gestor de Estados} del controlador significa que hemos perdido conexión con
nuestro coordinador (que acaba de abandonar la red) y por tanto con
toda la red. Procedemos a marcar a todos los nodos como inactivos
borrando además todos los datos relativos a la \ac{CWSN} que acabamos
de abandonar. Informamos a las aplicaciones registradas que hemos
dejado de formar parte de ésta. Por otro lado, al recibir la
señalización que indica la pérdida de un nodo seguimos el flujo visto
en la figura~\ref{fig:salidaRed-signaling} que es gestionado en el \var{Gestor de Interfaces}.

%XXX-jblesa. En el parrafo anterior dos veces por tanto seguidas. XXX-cvillar done.

\paragraph {Nodo coordinador} Si por el contrario somos un nodo coordinador, significa que hemos perdido la conexión con un nodo normal con el que teníamos comunicación directa y debemos informar al resto de nodos de esta eventualidad enviando un mensaje de señalización con la dirección \ac{MAC} del nodo saliente para que ellos puedan rehacer el mapa de red. Marcamos al nodo que acaba de perder la comunicación como inactivo e informamos a las aplicaciones registradas del evento y la nueva lista de nodos. Si todos los nodos de nuestro \var{Repositorio} están marcados como inactivos, significa que acabamos de perder la comunicación con el último nodo y por tanto dejamos de estar en \ac{CWSN} situación que informamos a las aplicaciones registradas de manera análoga. 

%------------------------------
\subsection{Actualización de parámetros en la red}
\label{subsec:updateSettings}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service, spreadNodeChangeOnNetwork(), updateInformationToCoordinator()
%\end{files}
%\end{codeInvolved}

Los parámetros del nodo cognitivo se pueden dividir en dos grupos: los propios del \var{Módulo cognitivo} y los de las aplicaciones. De estos últimos, uno de ellos es único y por tanto está compartido entre todas las aplicaciones registradas.
%(ver tabla~\ref{tab:serviceSettings}).

\comp{contiene datos de implementación\\
\begin{table}[h]
\begin{center}
	\begin{tabular}{r @{\hskip 1cm} p{7cm}}
	\multicolumn{2}{c}{Parámetros exclusivos del servicio}\\ \hline
	\noalign{\vskip 0.17cm} 
	\textbf{Nombre del nodo} & Una \String{} que represente el nombre del nodo en la red.\\
	\textbf{Tipo de nodo} & Un \integer{} cuyo valor \bsq{0} se traduce por normal y cuyo valor \bsq{1} corresponde a coordinador.\\
	\textbf{Periodo tarea cognitiva} & Un \double{} que expresa el número de segundos que transcurren entre ejecuciones de la tarea cognitiva.\\
	\noalign{\vskip 0.2417cm} 
	\multicolumn{2}{c}{Parámetros de aplicación}\\ \hline
	\noalign{\vskip 0.17cm} 
	\textbf{Papel del nodo} & Un \integer{} para representar el papel que juega el nodo en la red, \bsq{0}: usuario secundario mientras que el valor \bsq{1} representa al usuario primario.\\
	\textbf{Código de aplicación} & Una \String{} para discernir entre mensajes enviados por distintas aplicaciones.\\
	\end{tabular}
	\caption{Parámetros del servicio} \label{tab:serviceSettings}
\end{center}
\end{table}
}
%---
\begin{table}[h]
\begin{center}
	\begin{tabular}{r @{\hskip 1cm} p{7cm}}
	\multicolumn{2}{c}{Parámetros exclusivos del servicio}\\ \hline
	\noalign{\vskip 0.17cm} 
	\textbf{Nombre del nodo} & Tal y como nos conocen el resto de nodos en la red.\\
	\textbf{Tipo de nodo} & Permite discernir el tipo de nodo que seamos.\\
	\textbf{Periodo tarea cognitiva} & Expresa el tiempo entre ejecuciones de la tarea cognitiva.\\
	\noalign{\vskip 0.2417cm} 
	\multicolumn{2}{c}{Parámetros de aplicación}\\ \hline
	\noalign{\vskip 0.17cm} 
	\textbf{Papel del nodo} & Permite saber la prioridad y estatus del nodo en la red.\\
	\textbf{Código de aplicación} & Permite que el servicio filtre mensajes enviados por distintas aplicaciones.\\
	\end{tabular}
	\caption{Parámetros del servicio} \label{tab:serviceSettings}
\end{center}
\end{table}

Los primeros parámetros son ajustes del \var{Módulo cognitivo} que traspasan a cualquier aplicación. Sin embargo los segundos si son propios de cada aplicación: el primero expresa las necesidades de comunicación y el segundo nos sirve para filtrar mensajes en el \var{Gestor de Aplicaciones} entregando el contenido dirigido a cada aplicación en concreto. El parámetro ``papel del nodo'' en realidad es un parámetro compartido, es decir si varias aplicaciones están registradas en el servicio cognitivo cada una habrá aportado un valor distinto, como este valor es único, elegimos el más adecuado a las necesidades de comunicación de la aplicación más restrictiva. En otras palabras si una aplicación pide ser ``usuario primario'' y otra aplicación pide ser ``usuario secundario'' el valor del parámetro será ``usuario/nodo primario''.\\

La primera forma de actualizar los parámetros de aplicación es con el registro de la aplicación en el \var{Módulo cognitivo} (ver sección~\ref{subsec:serviceRegisterProcess}) o en cualquier momento enviando un mensaje desde la aplicación al \var{Gestor de Aplicaciones} del tipo \Scst{REGISTER\_DATA\_EXCHANGE} (visto en la tabla~\ref{tab:registerExchangeMessage}) que desembocará en una contestación con todos los parámetros del servicio cognitivo.\\

Con respecto a los parámetros exclusivos del \var{Módulo cognitivo} la forma de actualizarlos está un poco escondida en la \ac{API}, ya que son ajustes propios del nodo, cuyo conocimiento no trasciende a la aplicación y por tanto sometidos a cambios poco frecuentes. Normalmente estos parámetros están guardados en el \var{Repositorio} y se recuperan al recibir un mensaje del tipo \Scst{REGISTER\_DATA\_EXCHANGE}.
%Sin embargo, si en este mensaje viene informado el campo \textit{obj} con un valor booleano a \true{} entonces en vez de coger los parámetros de la base de datos, los extraemos del mensaje. El detalle del mensaje ya se definió en la tabla~\ref{tab:updateAllParamsMessage}.
Sin embargo, si este mensaje viene informado de una manera particular, podemos cambiar el flujo para que se produzca una actualización de estos parámetros. En la tabla~\ref{tab:updateAllParamsMessage} se describe el detalle de este mensaje.

La actualización de estos parámetros (tanto si sólo actualizamos los de aplicación o todos) viene condicionada a si estamos cooperando en una red o no. Si no estamos en ninguna red los valores pasados sobrescribirán los existentes, en cambio si estamos en una situación de red, los parámetros ``papel del nodo'' y ``periodo tarea cognitiva'' pueden no ser actualizados. Su actualización depende por tanto del valor actual, si el nuevo valor es más restrictivo se podrá actualizar. Es decir para el ``papel del nodo'' sólo actualizaremos si el cambio pedido es a ``nodo primario'' y para ``periodo tarea cognitiva'' sólo actualizaremos si el periodo requerido es más pequeño que el actual.  Con respecto al parámetro ``tipo de nodo'', una vez se está en una \ac{CWSN} no se permiten cambios ya que dejaríamos a la red sin coordinador o añadiríamos otro coordinador, situaciones que no son de interés. Lo anterior no aplica, salvo el cambio de tipo de nodo, en la situación en que sólo hay una aplicación registrada, situación en la que actualizaremos el resto de los parámetros al no producirse ningún conflicto.\\

Con respecto a la actualización de estos parámetros al resto de nodos, una vez validados y actualizados según las reglas descritas, si son de interés general (``nombre del nodo'', ``papel del nodo'') son enviados al coordinador (ver detalle del mensaje en figura~\ref{itm:updateToCoordinator}) para que este los distribuya como una actualización más del mapa de red (estructura del mensaje de red detallada en figura~\ref{itm:updateParams}).

En \bt{} puede darse la situación de que si somos un nodo normal los demás nodos nos vean con parámetros antiguos. Esta situación se produce si hemos actualizado nuestros parámetros fuera de una \ac{CWSN} donde obviamente no han sido propagados a la red. Cuando el coordinador, que no tiene manera de saber que hemos modificado nuestros parámetros, nos incluye en la red, si nos conoce de veces anteriores no nos preguntará sobre ellos, si no que sacará una copia desactualizada de su \var{Repositorio} que distribuirá al resto. No obstante esta situación es muy poco frecuente, por lo que teniendo en mente la minimización del tamaño de mensajes y el número de éstos, se ha preferido no implementar mecanismos que hagan mantener actualizados en todo momento los parámetros del nodo (``nombre del nodo'', ``papel del nodo'' y ``tipo de nodo'' aunque este último es deducible por el contexto) en favor de una mayor eficiencia de red y menor consumo. Esta situación no ocurre en \wifi{} ya que la forma de registro en la red conlleva el envío de un paquete para registrarse en el que enviamos toda la información del nodo, por lo que sobre \wifi{} se puede actualizar en cualquier momento y sobre \bt{} sólo en los momentos de cooperación en red. No obstante esta situación desactualizada, se soluciona cuando hay un cambio de contexto con interfaz destino \wifi{}, ya que estos parámetros se envían con el mensaje de registro de la red.

%------------------------------
\subsection{Intercambio de mensajes}
La transmisión y recepción de datos se realizan a través del intercambio de mensajes definidos en la \ac{API}. Podemos destacar tres acciones: envío, recepción y re-envío, una mezcla de los anteriores que se implementa sólo en el nodo coordinador.

\subsubsection{Recepción de mensajes}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service, mHandler<controlador>, incomingContentNormal(), incomingDataMessageToApp()\\
%\end{files}
%\end{codeInvolved}
%%diseño+implementación
\comp{D+I:
Empezamos explicando este proceso por ser el más fácil. Cuando la hebra del controlador (no importando cual) sale de su bloqueo al recibir datos, se genera el evento de recepción de datos que es manejado en el servicio. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona de nuevo al servicio los datos recibidos e información sobre el envío
%conjuntamente a información que dependiendo del controlador, incluirá {\small EXTRAS} distintos 
(ver tabla~\ref{tab:messageReadController}).
}
%%--
Empezamos explicando este proceso por ser el menos complejo, que además va a ayudar a introducir algunas de las piezas que veremos en el proceso de envío. Al recibir datos se genera el evento \Scst{INTERFACE\_STATE\_RECEIVING} que es manejado en el \var{Gestor de Interfaces}, para que éste informe a las aplicaciones. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona de nuevo al \var{Gestor de Interfaces} los datos recibidos e información sobre el envío
(ver tabla~\ref{tab:messageReadController}).

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{A implementación:\\
\messageTableInit{\controllerToServ}{2 =\\ \scriptsize{MESSAGE\_READ}}{Número de \textit{bytes} leídos}{\nc{}}{\textit{bytes} leídos de la red}{\nc{}}

\messageTableExtraControllerSpecified{\wifi{}}{device\_ip\_address}{Una \String{} con la dirección IP del nodo que nos envía los datos}

\messageTableExtraControllerSpecified{\bt{}}{device\_name}{Una \String{} con el nombre proporcionado por los servicios de \bt{} de \android{} (no es relevante)}
\messageTableExtraAddrow{device\_address}{Una \String{} con la dirección MAC de \bt{} del nodo que nos envía los datos}

\messageTableEnd{Mensaje recibido por la red entregado por ambos controladores al servicio}{messageReadController}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Una vez tenemos los \textit{bytes} leídos en el \var{Módulo cognitivo} los procesamos. Este procesamiento puede ser tan simple como entregar el contenido del mensaje a la aplicación correspondiente o reenviar el mensaje al siguiente eslabón de la cadena (sección explicada en la página~\pageref{forwardProcess}). 

El tratamiento del mensaje depende del tipo de nodo sin embargo, la presentación del mensaje hacia la aplicación es común. 
%Si estamos en la lista de destinatarios, obtenemos el ``Código de aplicación'' (ver tabla~\ref{itm:dataMessage}) que nos permite recuperar el \textit{Messenger} de la aplicación. Así filtramos y entregamos a cada aplicación los mensajes que le interesan. También, gracias al campo ``Desde'' sabemos quién es el originador del mensaje. Una vez hemos recuperado la aplicación destinataria y el nodo que envío el mensaje, podemos trasladar esta información a la aplicación correspondiente (ver tabla~\ref{tab:incomingContent}).
La presentación consiste en entregar, si aplica, es decir si el nodo está en la lista de destinatarios, los datos recibidos e información sobre el origen a la aplicación correspondiente a través del mensaje \Scst{INCOMING\_CONTENT} de la \ac{API} (ver tabla~\ref{tab:incomingContent}).
%ayudándonos del campo ``Código de aplicación'' para discernir quién es la interesada y obtener quién es el originario del mensaje que vendrá escrito en el mensaje recibido (en la tabla~\ref{tab:incomingContent} vemos el detalle entregado a la aplicación).

\subsubsection{Envío de mensajes}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service, builtDataMessage(), getNextNodes(), send(), mHandler<controlador>, outgoingContentProgress()\\
%\textbf{DataMessageQueue}: add(), hashMessage(), changeStatus(), remove()
%\end{files}
%\end{codeInvolved}

El proceso de envío de datos a través del servicio cognitivo comienza con un mensaje a través de la \ac{API} (ver estructura en la tabla~\ref{tab:outgoingContent}).

Una vez entregado el mensaje al \var{Gestor del Sensor} se empieza a
procesar. Asumimos que el mensaje que se quiere enviar es de un
contenido que se puede codificar como una \String{}. Por tanto, éste
es el tipo de dato que se espera en el campo \textit{obj} del mensaje.
%(\textit{payload}). 
Si no es así, el \var{Gestor del Sensor} devolverá un mensaje de error a la aplicación explicando que no puede manejar el contenido. En segundo lugar se comprueba que todos los valores de la lista son nodos de la red activos, también comprobamos que estamos en una \ac{CWSN}. Si no se superase alguna de estas otras validaciones se entregaría al igual que antes un mensaje de error a la aplicación con el código y descripción pertinentes provocando el aborto del proceso en curso. Si no hay ningún problema, confeccionamos con el formato expresado en la tabla~\ref{itm:dataMessage} el mensaje que se va a enviar a la red.

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje datos}
  \item[Tipo] Valor ``DATA'' del enumerado ``MessageType''.
  \item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo.
	\item[Lista destinatarios] Una lista de \String{} con la lista con las direcciones MAC de \bt{} de los nodos destinatarios.
	\item[Código de aplicación] Una \String{} con el código de aplicación para filtrar el mensaje en destino. 
	\item[Marca de tiempo] Un \textit{long} con la representación del momento en el cual la aplicación entregó el mensaje al servicio.
	\item[Mensaje de datos] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Payload] Una \String{} con el contenido del mensaje. 
	\end{description}
\protobufTableEnd{Campos del mensaje de datos}{dataMessage}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Una vez tenemos el mensaje lo guardamos en una cola, lo que nos ayuda a calcular el tiempo de llegada de los mensajes de datos por parte de las aplicaciones y es necesario para ofrecer a la aplicación una confirmación positiva o negativa sobre la entrega a los nodos destinatarios para cada mensaje. Como esta confirmación puede no ser inmediata necesitamos almacenar de alguna manera el mensaje para poder recuperarlo cuando nos llegue la confirmación. Para guardar y rescatar el mensaje cuando llegue el momento, nos ayudamos de una clave: un resumen calculado en base a la marca de tiempo, el contenido del mensaje y la dirección \ac{MAC} de \bt{} del nodo que envía el mensaje. 

El siguiente punto es ver si podemos enviar el mensaje por la red. Para ello debemos estar registrados en una \ac{CWSN} y no estar en una situación de cambio de contexto. Si se da esta situación marcamos el mensaje como ``pendiente de envío'' en la cola. Si por el contrario podemos enviarlo, lo marcamos como ``en envío'' y se procede al mismo, para ello necesitamos saber quién o quiénes son los siguientes nodos en la cadena de envío. Esta información la facilita el submódulo \var{Encaminamiento} del \var{Gestor de Interfaces}. A pesar de que cada nodo tiene información sobre cómo alcanzar a otros nodos, nuestra red está centralizada en la figura del coordinador, por lo que la comunicación entre nodos no es posible siendo precisa una comunicación de saltos en los que el coordinador juega el papel central. Se sigue la recomendación vista en \ac{CB}~\cite{conbrok} para incrementar de esta forma la eficiencia. No obstante hay casos en que esta comunicación de saltos viene forzada por la interfaz de comunicación en uso: estamos hablando de \bt{} cuya única tipología posible es la de estrella (esclavo/maestro). El encaminamiento por tanto depende del tipo de nodo: 

\paragraph{Nodo normal} El siguiente eslabón de la cadena es nuestro nodo coordinador, tanto si el mensaje es dirigido a él, como si lo es a otros nodos. 

\paragraph{Nodo coordinador} El coordinador tiene comunicación directa con todos los nodos, en \wifi{} ocurre siempre y en \bt{} tenemos la restricción de hasta siete nodos, si no introducimos la figura del ``subcoordinador temporal'', nodo que se comporta como concentrador de mensajes en su \textit{piconet} y que a su vez está en otra \textit{piconet} donde se encuentra el coordinador. En estos momentos al haber sólo un salto, tenemos contacto directo con cualquier nodo no importando la interfaz en la que nos encontremos. Por tanto los siguientes eslabones de la cadena de entrega son los mismos nodos que están en el campo ``lista de destinatarios'' del mensaje a enviar.\\

Una vez tenemos los datos codificados y a quien se lo vamos a enviar, procedemos al envío (en la siguiente sección veremos que necesitamos un parámetro más pero que por el momento podemos obviar). Enviar es básicamente pasar como parámetros el mensaje al método \textit{write()} del controlador traduciendo cada identificador del nodo a su dirección de comunicación de la interfaz en curso. Es decir si tenemos que enviar un mensaje a una serie de nodos de los cuales tenemos sus identificadores, tendremos que traducir estos identificadores a las direcciones \ac{IP} en el caso de \wifi{} o a las direcciones \ac{MAC} en \bt{}. Una vez que el mensaje ha sido escrito en la red por el controlador, este mismo informa al \var{Gestor de Interfaces} a través de un mensaje del tipo \Scst{MESSAGE\_WRITE} con resultado del envío, este informe incluye el propio mensaje de vuelta más una lista de las direcciones de comunicación a las cuales no ha podido entregar el mensaje (ver tabla~\ref{tab:messageWriteController}).\\

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\messageTableInit{\controllerToServ}{3 =\\ \scriptsize{MESSAGE\_WRITE}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{bytes} enviados a través de la red}{\nc{}}
\messageTableExtra{requester}{Una \String{} que representa el \textit{messenger} de la aplicación que origina el mensaje}
\messageTableExtraAddrow{addressNotDelivered}{Una lista de \String{} con las direcciones \ac{MAC} de \bt{} o direcciones IP de los nodos a los cuales el envío del mensaje ha resultado fallido, según el controlador que nos envíe el mensaje}
\messageTableEnd{Mensaje resultado envío de datos desde el controlador al servicio}{messageWriteController}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

%Dependiendo de quienes sean los destinatarios del mensaje, el mensaje habrá llegado a su destino (no hay saltos de por medio) y por tanto no necesitamos más confirmación de entrega que la que ya nos da \ac{TCP} de por si. Si no tuviesesemos contacto directo con los nodos a los que queremos enviar el mensaje necesitamos esperar a que nos confirmen el resultado de la entrega de éste.

Dependiendo de los destinatarios del mensaje su entrega comprenderá uno o más saltos. Si sólo tenemos un salto, es decir, ambos nodos pueden establecer un canal de comunicación directo, no necesitamos un mensaje extra de confirmación de llegada pues el protocolo \ac{TCP} nos cerciora de esta entrega. Si por contra la entrega del mensaje pasa por varios nodos antes de llegar al destino final, es necesario un mensaje de confirmación que recorra el camino contrario para informar al nodo que envió el mensaje del éxito o fallo del proceso de entrega:

%XXX-jblesa. Este parrafo anterior no tiene sentido. Escribelo otra vez. XXX-cvillar mejor?

\paragraph{No es necesario recibir mensaje ACK} En este primer caso, al ser una entrega directa, si somos un nodo normal el mensaje tiene como único destinatario nuestro coordinador. Si somos un nodo coordinador el mensaje ha sido entregado en mano a todos los nodos. Al no ser necesario ningún otro paso adicional relacionado con el envío, procedemos a borrarlo de la cola de mensajes gracias al resumen almacenado y a entregar un mensaje a la aplicación con información sobre la entrega (ver tabla~\ref{tab:outgoingContentResultApp}).

\paragraph{Es necesario mensaje ACK} En el segundo caso, el mensaje enviado requiere de un salto en la red, requiere de un reenvío. La casuística de cómo se producen este tipo de mensajes será explicada en la siguiente sección. En ésta, nos limitamos a ver el proceso de recepción del \ac{ACK} vista desde un nodo normal. En este caso al recibir por parte del controlador el mensaje (ver tabla~\ref{tab:messageWriteController}), procedemos a su marcaje en la cola como ``pendiente de ACK'' quedando a la espera de recibir la confirmación del envío del siguiente salto. En la tabla~\ref{itm:ackMessage} podemos ver el formato del mensaje de señalización utilizado para la confirmación del envío.

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:
\protobufTableInit{Estructura mensaje ACK}
  \item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``ACK'' del enumerado ``AskType''.
		\item[Mensaje de ACK] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':
			\begin{description}
				\item[Hash] Un \textit{long} con el identificador único de mensaje.
				\item[Número mensajes escritos OK] Un \integer{} con el número de mensajes que han sido correctamente entregados.
				\item[Lista de direcciones MAC NOK] Una lista de \String{} con las direcciones MAC de \bt{} de los nodos a los cuales no se ha podido entregar el mensaje.
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje ACK}{ackMessage}
}
%%%%%%%%%%%%%%%%%%%%%%%%_ 
Al recibir esta confirmación, procederemos a borrar de la cola el mensaje de datos utilizando el \textit{hash} leído de la señalización y a comunicar a la aplicación el resultado del proceso de envío (el detalle puede verse en la tabla~\ref{tab:outgoingContentResultApp}).

\umlsdInitTitle{Envío desde nodo A, a los nodos B y C}
	\newinst{a}{nodo A} \newthread[black!30]{nc}{nodo Coordinador} \newinst[1]{b}{nodo B} \newinst{c}{nodo C}
	\begin{call}{a}{Envío datos}{nc}{} \end{call}
	\prelevel\callSelf{a}{Marcar mensaje en la cola como \bsq{pendiente de ACK}}
	\begin{messcall}{nc}{Reenvío datos A}{b} \end{messcall}
		\prelevel\prelevel\callSelf{b}{Entrega datos a la app} \postlevel
	\begin{messcall}{nc}{Reenvío datos A}{c} \end{messcall}
		\prelevel\prelevel\callSelf{c}{Entrega datos a la app}
	%\mess{nc}{ACK}{a}
	%\begin{messcall}{nc}{\shortstack {ACK\\ \texttt{(Entrega datos enviados} \\ \texttt{y estadísticas a la app)}}}{a} \end{messcall}
	\begin{messcall}{nc}{ACK}{a} \end{messcall}
	%\callSelf{a}{borrado mensaje de la cola}
	\node[align=right,text width=5cm] at (0.9,-7.6){\texttt{Entrega datos enviados, borrado del mensaje en la cola y envío de estadísticas a la app}};
\umlsdEnd{Ejemplo envío con necesidad de ACK}{sendNeededACK}
 
%\newpage
\subsubsection{Re-envío de mensajes}
%XXX-jblesa quita forward y ponlo en español XXX-cvillar ok.
\label{forwardProcess}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: mHandler<controlador>, incomingContentCoordinator(), outgoingContentProgressCoordinator()\\
%\end{files}
%\end{codeInvolved}

Este proceso es una mezcla de una recepción y un envío de mensajes,
reservada al papel del nodo coordinador. Este proceso comienza con la
recepción (en el coordinador) de un mensaje originario en un nodo
normal cuya lista de nodos destinatarios atañe a más nodos de los dos
implicados en esta comunicación. En esta lista puede estar o no
incluido el coordinador. Si está incluido como paso inicial
presentaremos el mensaje a la aplicación como hemos descrito en la
recepción de mensajes. Acto seguido procederemos al reenvío de
éste. Para ello, como vimos en la sección anterior, tenemos que
conocer:
\begin{enumerate}
\item Lista de destinatarios: cuáles son los siguientes nodos a los que enviar el mensaje
(prestando especial atención a que si es un mensaje dirigido a todos,
no volver a enviarlo al nodo originario de la comunicación).
\item El mensaje a enviar: el que hemos recibido, sin modificaciones.
\item Un parámetro que antes obviamos que identifica que se trata de un re-envío.
\end{enumerate}

%XXX-jblesa La ultima frase no se entiende... ``el mensaje...'' XXX-cvillar, con la lista queda mejor?

Esta elusión tiene como objetivo haber facilitado la lectura de las dos secciones anteriores al no añadir otra pieza más al rompecabezas. Nuestro flujo de trabajo necesita transmitir a través de todas las capas (servicio cognitivo, controlador y capas inferiores, si intervienen) qué aplicación es la originaria del mensaje para poder ofrecerle una respuesta cada vez que envíe datos a través del \var{Módulo cognitivo}. En el caso de un reenvío, el mensaje se recibe por la red por tanto no hay aplicación originaria de este mensaje en el nodo. No se puede utilizar el ``código de aplicación'' grabado en el mensaje de datos, entre otras razones, porque desembocaríamos en una situación en la que, después de reenviar el mensaje, se entregaría a la aplicación que tuviese este mismo valor del ``código de aplicación'' una confirmación a un mensaje de la que no es originaria. 

%El parámetro por tanto es una simple \String{} que representa, o al \textit{Messenger} de la aplicación, para poder ponerse en contacto con ella o si ésta no existe una \String{} especial que marque la situación de re-envío.
%De esta manera uniformamos el valor de este campo al tratarse en ambos casos de \Strings{} e indirectamente evitamos serializar un objeto complejo como es el \textit{Messenger} de \android{} o ubicarlo en un sitio que no está pensado para él: al intervenir en este proceso varias capas de la arquitectura si hubicasemos el objeto en el campo (\textit{msg.replyTo}) se usaría con otro propósito al pensado por la plataforma \android{}, lo que hace poco claro el código.\\

%Es necesario transmitir este parámetro a través de todo el flujo de envío ya que son procesos que pueden no resolverse en la misma petición, además son sin memoria y pueden ser disparados por distintas aplicaciones en cualquier momento donde además el preservamiento del orden entre distintos procesos de envío no está garantizado.

%Las \Strings{} especiales que representan la situación de re-envío y que son claves para que el flujo del proceso actúe en consecuencia son: \textit{``forward-me''} y \textit{``forward-not-me''} para referirse tanto a la situación en la que el coordinador forma parte de la lista del mensaje que se re-envía, como a cuando no.

Al igual que en un envío normal, almacenamos el mensaje en la cola y lo enviamos. Al recibir por parte del controlador el mensaje descrito en la tabla~\ref{tab:messageWriteController} en vez de trasladar el mensaje confirmando que el mensaje ha sido escrito en la red tal y como se hace en el proceso de envío, es aquí donde el flujo se da cuenta de que se trata de un re-envío y confecciona el mensaje de confirmación (ver tabla~\ref{itm:ackMessage}) que enviamos al nodo originario del mensaje de datos.


%------------------------------
\subsection{Sensado del entorno compartido y política cognitiva}
\label{subsec:senseAndPolicy}
Los parámetros del entorno que son de nuestro interés son el \ac{RSSI} de la red \wifi{} a la cual estamos conectados y la tasa de envío de mensajes de datos. El sensado del entorno se realiza en varios puntos de la arquitectura: \var{Sensado} y \var{Gestor del Sensor}. Esta información se comparte mediante señalización (ver tabla~\ref{itm:scanMessage}) con el nodo coordinador de forma periódica. Éste al recibirla dependiendo de la prioridad con la que venga marcada, se limita a guardarla en su módulo \var{Repositorio} o a hacer un análisis rápido de la situación que desemboque en la toma de ciertas decisiones en el módulo \var{Ejecutor}.
%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje SCAN}
  \protobufItem{Tipo}{Valor ``RESPONSE'' del enumerado ``MessageType''.}
  \protobufItem{Mensaje de respuesta}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':}
	\begin{description}
		\protobufItem{What}{Valor ``SCAN'' del enumerado ``AskType''.}
		\protobufItem{Mensaje de SCAN}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':}
			\begin{description}
				\protobufItem{Prioridad}{Un enumerado (Priority) con la urgencia del sensado, toma dos valores {\small Priority.TASK} para sensados normales y {\small Priority.URGENT} para marcar que la información del entorno es sensible.}  
				\protobufItem{RSSI}{Un \integer{} con el nivel de señal de la red \wifi{} a la que estamos conectados (-9999 si no estamos en ninguna).}
				\protobufItem{Intervalo promedio envío de mensajes}{Un \double{} con el resultado promedio móvil del intervalo medido en segundos entre la llegada de mensajes de datos por parte de las aplicaciones.}
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SCAN}{scanMessage}
}
%%%%%%%%%%%%%%%%%%%%%%%%_
\subsubsection{Parámetro del entorno: RSSI}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: normalCognitiveTask(), mWifiAdapter.getConnectionInfo()\\
%\end{files}
%\end{codeInvolved}

Para medir la intensidad de señal podemos utilizar de manera activa la \ac{API} de \android{} obteniendo el valor de la potencia de señal medida en dBm. También lo podemos hacer de una manera indirecta aprovechando los mensajes de difusión que lanza el sistema \android{} con información acerca de este parámetro. El registro a este tipo de información del sistema se efectúa cuando se inicializa el servicio cognitivo, el desregistro (para no dejar fugas de memoria al no liberar su reserva) se produce con la destrucción de éste. Así las diferentes políticas cognitivas tienen disponible este parámetro a lo largo de toda la vida del \var{Módulo cognitivo}.\\
 
%XXX-jblesa Quita memory leaks XXX-cvillar vale.

En nuestra arquitectura utilizamos estos dos puntos de medida para este parámetro, el primero está localizado en la tarea cognitiva del \var{Optimizador} que guarda en el \var{Repositorio} el dato para usos futuros. El otro punto reside en las notificaciones por parte del sistema, éstas nos ayudan a actuar con un menor tiempo de respuesta, ya que si detectamos una situación que entrañe riesgo podemos compartir esta información sin esperar a la tarea cognitiva donde realizamos entre otras cosas el sensado del entorno. Al recibir esta información urgente, el nodo coordinador vuelve a evaluar estos datos para evitar cambios de contexto disparados por umbrales que no concuerden con su política cognitiva. 

\subsubsection{Parámetro del entorno: Intervalo promedio envío de mensajes}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: normalCognitiveTask()\\
%\textbf{DataMessageQueue}: getAvgArrivalRateUpdateTillNow()
%\end{files}
%\end{codeInvolved}

En este caso la medición se va confeccionado cada vez que una aplicación entrega un mensaje de datos al \var{Gestor del Sensor} para su envío. Al añadirlo a la cola registramos el tiempo que ha pasado desde la última vez, olvidando registros anteriores si tenemos suficientes. Esto nos permite realizar promedios móviles que se centren en una situación cercana al momento actual para extraer información reciente y no condicionada excesivamente por eventos pasados.\\

En el módulo \var{Optimizador} calculamos de manera periódica la media de estos valores. Ocurre que el promedio sólo cambia al incluir nuevos mensajes en la cola, desembocando en que si no se producen nuevas inclusiones se obtiene el mismo valor del intervalo de envío de mensajes en ejecuciones consecutivas de la tarea cognitiva desvirtuando este valor. Necesitamos algún mecanismo que sin desfigurar los datos, refleje esta situación de no envío y por tanto evidenciar un aumento del promedio.

Para ello en el momento de la transmisión de los parámetros del entorno al nodo coordinador, obtenemos el promedio de las muestras tomadas y lo recalculamos teniendo en cuenta el tiempo actual. Este cómputo no afecta al promedio de las muestras tomadas pues no se incluye tal y como se hace con las otras muestras.

\subsubsection{Política cognitiva}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: mayTakeAdvantageOfBT() mayTakeAdvantageOfWiFi(), sendTroublingRssi(), coordinatorCognitiveTask()
%\end{files}
%\end{codeInvolved}
La política cognitiva implementada es competencia exclusiva del nodo coordinador. Esta política tiene en cuenta tanto los parámetros propios del nodo coordinador como el sensado del entorno proporcionado por los demás nodos. El análisis de los datos de sensado recae fundamentalmente en el nodo coordinador. Sin embargo para evitar situaciones de pérdida de nodos, el nodo normal puede avisar de forma activa si su \ac{RSSI} decae por debajo de un umbral.

La política implementada en el módulo \var{Políticas} es única y actúa únicamente sobre el cambio de interfaz que obedece a estos motivos:
\begin{description}
	\item[De Wi-Fi a Bluetooth] Está motivada por la pérdida de señal
en la red \wifi{}. La decisión se basa en un umbral y en una zona de
peligro. Al evaluar los datos de sensado de cierto nodo, vemos si el
último valor de la \ac{RSSI} está por debajo del umbral, en caso
afirmativo disparamos el proceso de cambio de contexto. Si no, evaluamos el valor promediado a un número
de muestras elegible, si este valor está en la zona de peligro vemos
la evolución de la señal y si decae más de lo permitido procedemos al cambio de contexto.

	\item[De Bluetooth a Wi-Fi] Incitada por el aumento de mensajes en la red. La decisión también se basa en un umbral y en una zona de peligro. Si el último dato de sensado de cierto nodo acerca del tiempo (ya promediado de manera móvil) entre mensajes está por debajo del umbral se producirá el cambio de contexto. En caso contrario vemos si la media de los últimos datos sensados está en la zona de peligro, si es así, vemos si éstos disminuyen más de lo permitido.
\end{description}

Los parámetros que utiliza esta política para basar sus decisiones son:
\begin{description}
	\item[Umbral Wi-Fi] Mínima intensidad de señal \wifi{} permitida medido en dBm
	\item[Zona de peligro Wi-Fi] Acotación entre el umbral y un valor porcentual a éste.
	\item[Máximo decaimiento en zona de peligro] Máxima pérdida de señal permitida en la zona de peligro.
	\item[Intervalo tiempo mínimo entre mensajes] Mínimo tiempo aceptado entre envío de mensajes a través de la red medido en segundos 
	\item[Zona de peligro cercano al intervalo] Acotación entre el intervalo mínimo y un valor porcentual a éste.
	\item[Máximo decrecimiento del intervalo en zona de peligro] Si en la zona de peligro el intervalo disminuye porcentualmente al umbral en más de este valor procedemos a un cambio de contexto.
\end{description}

%------------------------------
\subsection{Cambios de contexto}
Con la información recogida del entorno tanto por el mismo nodo como por sus compañeros, podemos tomar decisiones sobre la estabilidad de la red y conforme a experiencias pasadas, colocar a ésta en el lugar en el que mejor se adapte. Necesitamos una serie de protocolos que mantengan la integridad de la red y marquen los pasos a seguir cuando hay un cambio de interfaz.

\subsubsection{Cambio de contexto con interfaz destino Wi-Fi}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfWiFi(), contextChangeToWiFi(), SetupWifiInterface (asyncTask), mHandlerWF, scheduleTaskWifi(), sendEndSwitchMessage(), endContextualChange()
%\end{files}
%\end{codeInvolved}

\umlsdInit
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B}
	\callSelf{nc}{Configurar \wifi{} y obtener ip}
	
	\mess{nc}{Switch: ip, ssid}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{\shortstack{Configurar \wifi{}\\y apagar interfaz origen}}	

	\mess{b}{\bsq{HelloPacket}}{nc}	
	\mess{nc}{ACK \bsq{HelloPacket}}{b}
	\prelevel\callSelf{b}{Parar envío \bsq{HelloPacket}}\prelevel	
	\mess{a}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{a}
	\prelevel\callSelf{a}{Parar envío \bsq{HelloPacket}}\prelevel
	\postlevel
	\callSelf{nc}{Apagar interfaz origen}
	\prelevel\mess{nc}{End Switch}{a}	
	\mess{nc}{End Switch}{b}
\umlsdEnd{Ejemplo cambio de contexto hacia \wifi{}}{switchToWifi}

Cuando el nodo coordinador ejecuta su tarea cognitiva va rescatando del \var{Reposito\-rio} para cada nodo los últimos escaneos de éste, obteniendo un promedio y una tendencia de los datos de sensado. Evalúa estos datos y decide si es necesario un cambio de interfaz. Este proceso implica a los módulos \var{Políticas} y \var{Optimizador}, si el resultado es positivo, el módulo \var{Ejecutor} obtiene una lista de los nodos activos en la red, los cuales se marcan como inactivos y se informa a las aplicaciones sobre el nuevo evento (\Scst{EVENT\_INTERFACE\_SWITCHING\_TO\_WIFI}, tabla~\ref{tab:infoGatheredFromService}) desembocando en la configuración de la interfaz \wifi{}. Para ello utilizamos el mismo procedimiento usado en~\ref{subsec:configInterface} con unos pasos adicionales: una vez nos hemos conectado a la red, enviamos un mensaje de señalización (a través de la interfaz actual, aún \wifi{} no es efectiva) a la lista de nodos que sacamos informándoles del cambio y de la información necesaria para llevarla a cabo (ver tabla~\ref{itm:switchToWifi}).
%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje SWITCH hacia \wifi{}}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo.
  \item[Mensaje de señalización]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``SWITCH'' del enumerado ``SignalType''.
		\item[Mensaje de SWITCH] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Interfaz destino] Valor ``TO\_WIFI'' del enumerado ``ToInterface''.  
				\item[SSID] Una \String{} con el nombre de la red \wifi{} a la que se va a realizar el cambio.
				\item[BSSID] Una \String{} con la dirección MAC del punto de acceso para evitar cualquier equívoco.
				\item[Dirección IP coordinador] Una \String{} con la dirección IP del nodo.
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SWITCH hacia \wifi{}}{switchToWifi}
}
%%%%%%%%%%%%%%%%%%%%%%%%_ 

Al terminar de configurar la interfaz siendo ésta ya efectiva,
dejamos programado un \textit{timeout} que dispare el fin de cambio
de contexto para evitar bloqueos debido a que algún nodo no responda. A partir de
ahora esperamos a que los nodos normales configuren su interfaz
\wifi{} (antes apagarán su interfaz en curso, en este caso \bt{}) y
vayan entrando en la nueva red tal y como se contó en las
secciones~\ref{subsec:configInterface} y~\ref{subsec:enterInNetwork} de los procesos de red. 

%XXX-jblesa aqui has hecho referencia a la seccion enterInNetworks que
%es futura. XXX-cvillar no, es anterior.

El coordinador al recibir los \textit{``HelloPacket''} en vez de
seguir el flujo normal que consiste en informar a todos los nodos de la
nueva entrada y al nuevo nodo informarle sobre el mapa de red, se
limita a enviarle un mensaje de confirmación indicándole que se ha recibido el paquete para que éste pare su envío. Así evitamos enviar muchos mensajes de señalización de una situación que es probable que cambie en un corto espacio de tiempo. Estos paquetes están enviados directamente a la \ac{IP} del coordinador (recogida del mensaje de señalización de cambio) para que haya más posibilidades de recepción. En la tabla~\ref{itm:okSwitch} podemos ver detalle de este mensaje de confirmación de entrada en la red en situación de cambio de contexto.

Si por algún casual el nodo normal terminase su ráfaga y no obtuviese respuesta, él mismo entendería que el proceso de cambio de contexto ha acabado de manera insatisfactoria.\\

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje confirmación cambio de contexto}   
	\item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``SWITCH'' del enumerado ``AskType''.
	\end{description}
\protobufTableEnd{Campos del mensaje de confirmación entrada (\wifi{}) / interfaz lista (\bt{})}{okSwitch}
}
%%%%%%%%%%%%%%%%%%%%%%%%_
Si antes de que salte el \textit{timeout} programado hemos recibido todos los \textit{``HelloPacket''} de todos los nodos, procedemos a finalizar el cambio de contexto. Si no, esperaremos a que finalice el \textit{timeout}, situación en la que forzosamente habremos perdido algún nodo. Tras este evento el nodo reacciona según sea su tipo:

\paragraph{Nodo coordinador} Al dispararse el final del cambio de contexto, apagamos la interfaz \bt{} y liberamos todos los recursos. Hemos mantenido la interfaz arriba hasta el último momento para no perder mensajes de datos si algún nodo actúa de manera incorrecta y envía estos mensajes en pleno cambio de contexto. Acto seguido se envía el mapa de red por medio de señalización a todos los nodos que formen en este momento la red (idealmente todos los que la formaban antes del cambio), en la tabla~\ref{itm:endSwitch} se detalla el formato de este mensaje independiente de la interfaz de comunicación.

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje fin cambio de contexto}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo (coordinador).
  \item[Mensaje de señalización]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``TOPOLOGY'' del enumerado ``SignalType''.
		\item[Mensaje de mapa de red] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Cambio] Valor ``ALL\_END\_SWITCH'' del enumerado ``TopologyChange''.  			
					\begin{description}
						\item[Representación de un nodo] Mensaje con los cambios que sirven para representar a nodo (ver tabla~\ref{itm:infoNode}). Tendremos tantas representaciones como nodos haya en la red.
					\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje finalización cambio de contexto}{endSwitch}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Notar que este mensaje es diferente para cada nodo ya que incluye la lista de nodos, que se confecciona de manera personalizada al no incluir en cada caso al nodo que la recibe. Los últimos pasos para finalizar el cambio de contexto es intentar enviar los mensajes encolados (los mensajes que hayan entregado las aplicaciones mientras que el proceso de cambio de contexto está vigente) y publicar hacia las aplicaciones registradas en el \var{Gestor de Aplicaciones} el evento del fin de cambio de contexto que incluye la nueva interfaz, el estado de ésta y la lista de nodos que forman la red en este momento.

\paragraph{Nodo normal} Al recibir el mensaje de señalización de cambio de contexto procedemos a cancelar (tal vez en segunda instancia) el envío de \textit{``HelloPacket''} por si no hubiésemos recibido el mensaje visto en la tabla~\ref{itm:okSwitch}, informamos a las aplicaciones el evento de fin de cambio de contexto con el nuevo mapa de red leído del mensaje de señalización y procedemos al envío de los mensajes encolados.

\umlsdInitTitle[!h]{Cambio de contexto, situación problemática}
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B} \newinst[1]{c}{nodo C}
	\callSelf{nc}{Configurar \wifi{} y obtener ip}
	
	\mess{nc}{}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\mess{nc}{Switch: ip, ssid}{c}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{}
	\prelevel\prelevel\callSelf{c}{\shortstack{Configurar \wifi{}\\y apagar\\interfaz origen}}
	
	\messFail{a}{\bsq{HelloPacket}}{nc}
	\messFail{c}{\bsq{HelloPacket}}{nc}	
	\messFail{a}{\bsq{HelloPacket}}{nc}
	
	\mess{b}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{b}
	\prelevel\callSelf{b}{Parar envío \bsq{HelloPacket}}\prelevel
	
	\mess{a}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{a}
	\prelevel\callSelf{a}{Parar envío \bsq{HelloPacket}}\prelevel

	\postlevel\postlevel

	\draw[thick,->] (0.9,-8) -- (1.4,-8) node[anchor=south east] {\small\shortstack{\textit{Timeout}\\expirado\\en Coor-\\dinador}};
	\callSelf{nc}{Apagar interfaz origen}
	\prelevel\mess{nc}{End Switch}{a}
	\messFail{c}{\bsq{HelloPacket}}{nc}	
	\mess{nc}{End Switch}{b}
		
	\callSelf{c}{\small\shortstack{\textit{Timeout} expirado en\\ C: No hay respuesta\\a \bsq{HelloPacket}: no\\ en CWSN}}		
	\node[fill=blue!30, align=right] at (6,-11.7) {\small\shortstack{Situación normal de red\\ población: A, B y Coordinador}};
	%\node [draw, rotate=90] at(0,-3) (first) {Timeout};
	%\node at(-0.5,-3) (second) {a};
	%\draw[->,gray,rounded corners] (second) edge (first);
	
	%\draw[thick,->] (0.5,-4) -- (1,-4) node[anchor=south east] {Timeout expired};
\umlsdEnd{Ejemplo cambio de contexto hacia \wifi{} con pérdida de nodos}{switchToWifiFail}
~\\%ajustar espacios y que caiga por debajo de la imagen
\subsubsection{Cambio de contexto con interfaz destino Bluetooth}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfBT(), contextChangeToBT(), SetupBTinterface (asyncTask), mHandlerBt,  tellBTisUP(), scheduleEndSwitchBTRunnable (future) scheduleSetupBTRunnable (future) , sendEndSwitchMessage(), endContextualChange()
%\end{files}
%\end{codeInvolved}

\umlsdInit
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B}
	\mess{nc}{Switch}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{Configurar \bt{}}	

	\mess{a}{OK Switch}{nc}
	\mess{b}{OK Swtich}{nc}
	
	\callSelf{nc}{Configurar \bt{} y apagar interfaz origen}
	\begin{call}{nc}{connect()}{a}{conexión aceptada} \end{call}
	\begin{call}{nc}{connect()}{b}{conexión aceptada} \end{call}	
	\mess{nc}{End Switch}{a}
	\prelevel\callSelf{a}{Desconectar interfaz origen}
	\mess{nc}{End Switch}{b}
	\prelevel\callSelf{b}{Desconectar interfaz origen}
\umlsdEnd{Ejemplo cambio de contexto hacia \bt{}}{switchToBT}

Cuando se produce un cambio de interfaz a \bt{} el nodo coordinador al igual que en el otro cambio de contexto obtiene una lista de quién está en la red y los marca como inactivos. Comunicamos hacia las aplicaciones el nuevo estado de la red y procedemos a enviar un mensaje de señalización que marque a los demás nodos el evento de cambio de contexto hacia \bt{}
%Este mensaje tiene la disposición mostrada en la tabla~\ref{itm:switchToBT}\\
(ver tabla~\ref{itm:switchToBT}).

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje SWITCH hacia \bt{}}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo.
  \item[Mensaje de señalización]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``SWITCH'' del enumerado ``SignalType''.
		\item[Mensaje de SWITCH] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Interfaz destino] Valor ``TO\_BT'' del enumerado ``ToInterface''.   
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SWITCH hacia \bt{}}{switchToBT}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Una vez enviado, programamos la tarea de configurar la interfaz de
\bt{} en el coordinador con un margen de tiempo suficiente para
obtener las respuestas de los nodos normales, que al recibir la
señalización configuran su interfaz \bt{} e informan a sus
aplicaciones del nuevo estado. Una vez levantada, comunican al
nodo coordinador a través de la interfaz en curso (\bt{} aún no es efectiva para enviar mensajes, ya que entre otras cosas no hemos establecido ninguna conexión con el coordinador) que la interfaz destino está lista para aceptar conexiones. Para ello utilizamos el mensaje ya visto en la tabla~\ref{itm:okSwitch}. Reutilizamos este mensaje de confirmación que no lleva ninguna información especial y que obtiene el significado de estar preparado por el contexto (en la otra ocasión el contexto le daba el significado de confirmación de entrada en la red).\\

Este mensaje le sirve al coordinador para saber que el nodo ya está listo. Cuando recibe todas las confirmaciones (o salta el \textit{timeout} programado anteriormente) procede a configurar su interfaz de \bt{} pasándole la lista de nodos que obtuvimos. La configuración de la interfaz incluye una ronda de conexiones a los nodos que formaban la red antes del cambio, que como acabamos de comentar se pasa como parámetro. Una vez terminado, ejecuta los mismos pasos descritos en la sección anterior para terminar el cambio de contexto. Salvo que en el mensaje de señalización de fin de cambio de contexto (ver tabla~\ref{itm:endSwitch}) la representación de cada nodo no incluye el campo ``Dirección IP''.\\
%%diseño+implementacion
\comp{I+D:
Por su parte, el nodo normal, al configurar su interfaz \bt{} y después de enviar la confirmación al coordinador de que está listo, programa una tarea (implementada gracias al esquema de programación basado en \textit{Runnables} alojados en la interfaz \textit{Future} y ejecutados en hebras gestionadas por el objeto \textit{Executor}) para salir de la situación de cambio de contexto por si no recibe ninguna conexión entrante o por si no recibe el mensaje de señalización de fin de cambio de contexto. Así se garantiza que ningún nodo se quede en \textit{deadlock} y el flujo siempre se ejecuta de principio a fin.
}
%%----

Por su parte el nodo normal al configurar su interfaz \bt{} y después de enviar la confirmación al coordinador de que está listo, programa una tarea para salir de la situación de cambio de contexto por si no recibe ninguna conexión entrante o por si no recibe el mensaje de señalización de fin de cambio de contexto. Así se garantiza que ningún nodo se quede en bloqueo mutuo y el flujo siempre se ejecute de principio a fin.

\umlsdInitTitle[!h]{Cambio de contexto, situación problemática}
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B} \newinst[1]{c}{nodo C}
	\mess{nc}{Switch}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\mess{nc}{}{c}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{Configurar \bt{}}
	\callSelf{c}{\shortstack{Configurar \\\bt{}: NOK}}

	\mess{a}{OK Switch}{nc}
	\mess{b}{OK Swtich}{nc}
	\postlevel\postlevel\postlevel
	\draw[thick,->] (0.9,-6) -- (1.4,-6) node[anchor=south east] {\small\shortstack{\textit{Timeout}\\expirado\\en Coor-\\dinador}};
	\callSelf{nc}{Configurar \bt{} y apagar interfaz origen}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{b}{} \end{messcall}
	\begin{call}{nc}{connect()}{b}{conexión aceptada} \end{call}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}	
	\mess{nc}{End Switch}{b}
	\prelevel\callSelf{b}{Desconectar interfaz origen}
	\postlevel\callSelf{a}{\textit{Timeout} expirado en A y C: no en CWSN}
	\prelevel\prelevel\callSelf{c}{}
	\node[fill=blue!30, align=right] at (6,-18.3) {\small\shortstack{Situación normal de red\\ población: B y Coordinador}};
\umlsdEnd{Ejemplo cambio de contexto hacia \bt{} con pérdida de nodos}{switchToBTFail}

%-------------------------------------------------------------------
\clearpage
\section{Aplicación utilitaria servicio cognitivo}
\label{sec:app}
%-------------------------------------------------------------------
Para hacer uso y probar las características cognitivas de nuestra arquitectura se ha diseñado una aplicación que se monta sobre el módulo o servicio cognitivo. La aplicación desarrollada además de cumplir la \ac{API} en su totalidad (incluida la denominada parte oculta) permite acceder a los parámetros de la política cognitiva y los \textit{timeouts} utilizados en los procesos de red.\\

La aplicación simula el comportamiento de un sensor cuyo valor introduce el usuario y monitoriza el estado del \var{Módulo cognitivo} gracias a los mensajes de información que se envían desde éste. Se estructura en tres secciones: la principal que da cabida al objetivo de la aplicación y permite en caso de \bt{} la conexión manual al nodo. En las figuras~\ref{fig:app-data-session},~\ref{fig:app-node-list} y~\ref{fig:app-failed-connection} podemos ver capturas sobre el comportamiento de la aplicación. En una segunda sección se muestra, si el usuario lo requiere desde la configuración, unas funciones de \textit{test}. En la figuras~\ref{fig:app-test-coord} y~\ref{fig:app-test-normal} se aprecia la interfaz gráfica añadida que permite realizar estas funciones, entre las que podemos enunciar:
\begin{description} 
	\item[Petición, respuesta] Permite, dependiendo del tipo de nodo, guardar una respuesta en el caso de nodos normales o pedir esta información para los nodos coordinadores. Con esta función se habilita un mecanismo de petición de información muy útil para la arquitectura cognitiva para la compartición de datos de sensado.

	\item[Encolamiento de mensajes] Debido a que nuestra aplicación actualiza de forma instantánea la lista de nodos al recibir un evento de cambio de contexto, no es posible elaborar un mensaje de datos que entregar al \var{Módulo cognitivo} debido a que no es posible construir una lista de destinatarios válida puesto que el único valor que se le presenta al usuario es la ausencia de nodos. Al intentar entregar un mensaje de datos al \var{Gestor del Sensor} con este valor, la validación que existe en la propia aplicación impide finalmente su entrega.\\
Por este motivo no es posible generar un mensaje válido que produzca su encolamiento, la aplicación desarrollada junto con el servicio cognitivo permiten simular este comportamiento. Al pulsar el
botón diseñado a tal efecto, se nos pregunta a través de una cadena de
diálogos el mensaje a encolar y a que destinatarios debe dirigirse. El \var{Gestor del Sensor} recoge esta información por medio de una solución alternativa.

\item[Cambio de contexto forzado] Permite, si somos un nodo coordinador disparar manualmente los procesos de cambio de contexto hacia la interfaz que en ese momento este libre.

%XXX-jblesa workaround y shortcut en español XXX-cvillar, cambiaré workaround por solución alternativa.

	\item[Vaciado de la cola de mensajes] El vaciado de la cola de mensajes pendientes de envío se produce al efectuarse un cambio de contexto, una vez las funciones de red están nuevamente activas. Si se quiere forzar el vaciado de esta cola por motivos de \textit{test} se ha habilitado un botón junto al de la función anterior a tal efecto.
	\item[Envío periódico datos sensor] Una característica muy presente en redes de sensores es la que los sensores suelen enviar datos de forma periódica. Simulamos esta característica en la aplicación tras seleccionar el periodo, los datos enviados consiste en una \String{} más un número que incrementamos en cada envío. 
\end{description}
Por último, en una tercera sección que alberga la configuración. La interfaz gráfica muestra unas opciones u otras dependiendo del tipo de nodo que seamos, tal y como se refleja en las figuras~\ref{fig:app-settings-coord},~\ref{fig:app-settings-policy} y~\ref{fig:app-settings-normal}. Desde la configuración podemos realizar:
\begin{description}
	\item[Ajustes del servicio cognitivo] Tipo y nombre del nodo, periodo tarea cognitiva y valores de la política que regula los cambios de contexto (ver~\ref{subsubsec:policyImpl}).
	\item[Ajustes de la aplicación] Código de aplicación, papel del nodo y si el texto que se usa como valor del sensor debe borrarse después de su envío al \var{Módulo cognitivo}.
 \item[Ajustes de test] Toda la configuración de la segunda sección como: si ha de visualizarse en la pantalla principal, con qué interfaz debe arrancar el servicio cognitivo si la sección de \textit{test} está activada y los \textit{timeouts} utilizados para los cambios de contexto.
\end{description}

La aplicación proporciona validaciones adicionales para evitar el incumplimiento de la \ac{API} o la interacción con el \var{Gestor de Aplicaciones} si no es necesaria. No se permite:
\begin{itemize}
	\item El envío de mensajes de datos si no está establecida una \ac{CWSN}.
	\item El envío de mensajes no dirigidos a un nodo válido (tanto si es inactivo pues no se permite su selección al no estar presente entre los \textit{items} que se presentan al usuario, como si el único valor que se presenta es la ausencia de nodos).
	\item La actualización vacía de la configuración. Es decir si no hay un cambio en la configuración no se traspasan las modificaciones necesarias al \var{Módulo cognitivo} para su actualización.
\end{itemize} 

% \begin{figure}
% \begin{center}%
% 	\begin{minipage}[t]{.5\textwidth}%
% 		\centering%
% 		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/settings}%
% 		\caption{settings1}%
% %XXX-jblesa En español los captions

% 	\end{minipage}%
% 	\begin{minipage}[t]{.5\textwidth}%
% 		\centering%
% 		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/settings2}%
% 		\caption{settings2}%
% 	\end{minipage}%
% 	%\caption{settings}%
% \end{center}
% \end{figure}


% \begin{figure}
% \begin{center}%
% 	\begin{minipage}[t]{.5\textwidth}%
% 		\centering%
% 		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/listnodes}%
% 		\caption{main ui}%
% 	\end{minipage}%
% 	\begin{minipage}[t]{.5\textwidth}%
% 		\centering%
% 		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/menu}%
% 		\caption{menu}%
% 	\end{minipage}%
% 	%\caption{settings}%
% \end{center}
% \end{figure}

% \begin{figure}
% \begin{center}%
% 		\includegraphics[width=.3\linewidth]{Imagenes/Bitmap/design/uitest}%
% 		\caption{testing ui}%
% \end{center}
% \end{figure}
%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
