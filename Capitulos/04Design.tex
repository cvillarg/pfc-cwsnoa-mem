%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------

\chapter{Diseño}

\begin{resumen}
Contar qué es una arquitectura modular y comparación con una arquitectura cognitiva.
\end{resumen}


%-------------------------------------------------------------------
\section{Arquitectura cognitiva}
%-------------------------------------------------------------------
\label{sec:arquitecturaCognitiva}

Explicación de los diferentes bloques de una arquitectura cognitiva: Repositorio, ejecutor, optimizador....
                                                                                      
%-------------------------------------------------------------------
\section{Arquitectura implementada}
%-------------------------------------------------------------------
\label{sec:arquitecturaImplementada}

Características de nuestra arquitectura: modular, homogénea, escalable (hasta 7 nodos) lo que le hace especialmente compatible a cambios en el futuro ya que los procesos están fuertemente marcados e independientes.
\subsection{Comparación ambas arquitecturas}
\label{sec:comparacionArquitecturas}
Clasificar nuestros metodos en los bloques de una arquitectura cognitiva.

%-------------------------------------------------------------------
\section{Detalles de implementación}
%-------------------------------------------------------------------
\label{sec:detallesImplementacion}

Servicio vs activity.... multi app...

%-------------------------------------------------------------------
\section{Cómo montar una aplicación sobre el servicio cognitivo, definición de la API}
%-------------------------------------------------------------------
\label{sec:api}

Tipos de mensajes que se intercambian, y como tienen que ir rellenos estos.

%-------------------------------------------------------------------
\section{Procesos de red}
%-------------------------------------------------------------------
\label{sec:procesosRed}

\comp{Relatar los diferentes procesos que ocurren en el servicio, quién los dispara y como se transmiten al resto de nodos y las apps que estén montadas}
%..........
\subsection{Registro de una aplicación en el servicio cognitivo}
\label{subsec:serviceRegisterProcess}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service (manejador de mensajes entre servicio y aplicaciones)
\end{files}
\end{codeInvolved}
Para que una aplicación pueda registrarse de forma correcta en el servicio debe cumplir un cierto \emph{handshaking} consistente en el intercambio de tres mensajes, el primero servirá para que el servicio nos tenga en cuenta, el segundo para informarle de nuestros parámetros de aplicación y el tercero será una confirmación del servicio hacia la aplicación informando de todos los parámetros del servicio respecto a nuestra aplicación.

Tras la petición de \emph{bind}, que inicializará el servicio si no estuviese arracando ya, obtendremos el \emph{Messenger} del servicio, indispensable para poder comunicarnos con él. Tras esto debemos mandar un primer mensaje para registrar nuestra aplicación en el servicio, donde éste, registrará nuestro messenger para habilitar la comunicación en sentido contrario y nos incluirá en su lista de aplicaciones registradas. Los detalles de este mensaje son:\\

\messageTableInit{\appToServ}{1 =\\ \footnotesize{REGISTER\_CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje registro cliente}{registerClientMenssage}

En el siguiente mensaje que debemos enviar, informaremos acerca de nuestros parámetros de aplicación como es: nuestro papel, un entero cuyo valor 0 corresponde a papel secundario y el valor 1 corresponde al papel primario y nuestro código de aplicación, útil para que el servicio nos entregue sólo los mensajes que nos atañen.

\messageTableInit{\appToServ}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{0=secundario / 1=primario}{\nc}{\emph{null}}{\messApp{}}
\messageTableExtra{appCode}{Una string con el código de aplicación}
\messageTableEnd{Mensaje intercambio parámetros aplicación}{registerExchangeMessage}

Este mensaje ha sido separado del anterior para poder reutilizarlo e introducirlo en el flujo descrito en \ref{subsec:updateSettings}. Con esta información el servicio dependiendo del punto en que se encuentre actuará de una forma u otra.

%..........
\subsubsection{Punto de partida inicial, CWSN no establecida}
Esta situación, (la más común) es cuando nuestra petición de \emph{bind} ha arrancado el servicio y por lo tanto estamos en una situación inicial o hay aplicaciones ya montadas sobre el servicio pero no hay conectividad con otros nodos, en otras palabras, estamos solos en la red. (Hay otra forma de llegar a esta situación que veremos en \ref{subsec:updateSettings}, que no explicamos ahora para no enmarañar el texto). 

En esta situación, configuraremos de nuevo la interfaz, actualizaremos los parámetros pasados en el anterior mensaje y lanzaremos nuevamente los procesos de registro en la red para intentar establecer una CWSN. Al finalizar éstos, el servicio nos devolverá (a todas las aplicaciones montadas) información acerca de todos los parámetros y el estado actual de la red. A saber:

\begin{description}
\label{itm:serviceParamsToAll}
  \item[Estado de la interfaz] Un \integer{} que representa el estado de la interfaz 0 = Down, 1 = Idle (no en red), 2 = Idle (en red), 3 = conectando (estado visto sólo en \bt{}), 4 = Enviando, 5 = Recibiendo.
  \item[Interfaz] Un \integer{}  cuyo valor 0 representa a \bt{}, el valor 1 representa a \wifi{} y -1 representa a una interfaz desconocida (útil para casos de error y cambios de contexto)
	\item[Papel del nodo] Un \integer{} cuyo valor 0 = secundario y 1 = primario
	\item[Tipo de nodo] Un \integer{} cuyo valor 0 = normal, 1 = coordinador y 2 = coordinador temporal en \bt{} (no usado en estos momentos)
	\item[Periodo tarea cognitiva] Un \double{}  que representa los segundos que transcurren entre ejecuciones de la tarea cognitiva
	\item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red
	\item[Resultado configuración interfaz] Un valor booleano con el resutado de configurar la interfaz de comunicación de forma correcta
\end{description}

El detalle del mensaje, queda:

\messageTableInit{\servToApps}{3\\ \scriptsize{REGISTER\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{False}}{\nc{}}
\messageTableExtra{nodeRole}{Papel del nodo}
\messageTableExtraAddrow{nodeType}{Tipo de nodo}
\messageTableExtraAddrow{periodTask}{Periodo tarea cognitiva}
\messageTableExtraAddrow{nodeName}{Nombre del nodo en la red}
\messageTableExtraAddrow{errorSetupInterface}{Resultado configuración interfaz}
\messageTableEnd{Mensaje finalización de \emph{handshaking}: CWSN no establecida}{endHandshakingNotCWSNMessage}

%..........
\subsubsection{Punto de partida, CWSN previamente configurada}
Puede darse el caso que en este punto del proceso, ya haya aplicaciones montadas sobre el servicio y estén cooperando en una CWSN, en este caso el servicio no tiene que configurar nada y se limita a ver si puede satisfacer las necesidades que le acaba de transmitir la nueva aplicación que acaba de registrar, es decir, cambiará el papel del nodo a primario si este era secundario, un cambio en sentido contrario será ignorado. Una vez hecho esto nos devolverá (en exclusiva) los parámetros del servicio (ver lista página~ \pageref{itm:serviceParamsToAll}) menos el resultado de configurar la interfaz ya que no ha sido necesaria ninguna configuración pero incluye estos nuevos: 

\begin{description}
  \item[Cógigo de la aplicación] Un \String{} que representa el código de la aplicación
	\item[Lista nodos] TODO TODO TODO en el código
\end{description}

El detalle del mensaje queda \footnote{Notar que el campo del mensaje \emph{obj} viene informado con el valor booleano \emph{True} lo que nos ayuda a distinguir si previamente el servicio ya cooperaba en una red, a parte que esta respuesta es casi inmediata, a diferencia de la anterior.}:

\messageTableInit{\servToApp}{3\\ \scriptsize{REGISTER\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{True}}{\nc{}}
\messageTableExtra{nodeRole}{Papel del nodo}
\messageTableExtraAddrow{nodeType}{Tipo de nodo}
\messageTableExtraAddrow{periodTask}{Periodo tarea cognitiva}
\messageTableExtraAddrow{nodeName}{Nombre del nodo en la red}
\messageTableExtraAddrow{appCode}{Código de la aplicación}
\messageTableExtraAddrow{nodeNamesList}{Array de \String{} con los nombres de los nodos}
\messageTableExtraAddrow{nodeIdsList}{Array de \integer{}s con los identificadores de los nodos}
\messageTableEnd{Mensaje finalización de \emph{handshaking}: CWSN establecida}{endHandshakingInCWSNMessage}

%..........
\subsection{Configuración de la interfaz de comunicación}
\label{subsec:configInterface}
Tras recibir el \emph{handshaking} de registro de la aplicación, el servicio si no se encuentra colaborando en una CWSN, procede a la configuración de una interfaz de comunicación, esta configuración se realiza en una \emph{AsynTask} de \android{} que permite descargar la \emph{UI-Thread} evitando errores del tipo \emph{ANR ``Application Not Responding''} ya parte de la tarea se ejecuta en segundo plano, además este tipo de tarea habilita mecanismos de paso de información entre ambas hebras. Antes de configurar una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos (llamando a su método \emph{stop}) para  poder partir de una situación deseable.  
\subsubsection{WiFi: servicio y controlador}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: SetupWifiInterface (asynTask)\\
\textbf{WifiController}: stop(), start() / StatusReceiver\_wifi (BroadcastReceiver)
\end{files}
\end{codeInvolved}

La interfaz \wifi{} permite configurarse en varias modalidades como: Infraestructura, Tethering o Ad-hoc. En la actualidad sólo está implementado el modo infraestructura por los problemas descritos en \ref{sec:analisisWifi}. Una vez lanzada la tarea en segundo plano, lo primero que hacemos es intentar parar las hebras asociadas a la interfaz \wifi{} que cerrarán los \emph{serverSockets} y el \emph{broadcastReceiver} útil para registrarse a eventos de información relativa a la interfaz \wifi{} como son RSSI y los eventos de conexión/desconexión a un punto de acceso. Partiendo de una situación en que todos los recursos están liberados, encendemos la interfaz si no lo estuviese ya, esperamos a que se encienda mediante una espera de consulta a una variable que es modificada por  \emph{StatusReceiver\_wifi.java}, nuestro \emph{broadcastReceiver} para la interfaz \wifi{}. Si nos han pasado como parámetro el SSID, intentamos conectarnos a él desconectándonos del punto de acceso acutual si no fuese el mismo. Esperamos mediante \emph{polling} con límite de tiempo seleccionable desde las preferencias en la sección de \emph{test}. Si agotamos el tiempo y no hemos sido capaces de conectarnos, devolvemos un valor \false{} que provoca el envío de mensaje a todas las aplicaciones del tipo {\small REGISTER\_EXCHANGE} con el campo EXTRA ``errorSetupInterface'' a \true{}. Si por el contrario nuestro \emph{broadcastReceiver} ha podido capturar la acción de conexión al citado punto de acceso o ya estamos conectados a éste continuamos arrancando las hebras del controlador dependiendo del tipo de nodo que seamos:
\paragraph{Normal} Arrancamos una hebra que escuche gracias a un \emph{serverSocket} para que acepte conexiones TCP, una vez estemos escuchando en el puerto indicado, enviamos el mensaje de tipo {\small REGISTER\_EXCHANGE} con el campo {\small EXTRA} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red.

\paragraph{Coordinador} Arrancamos un par de hebras, una para tráfico TCP que admita conexiones fiables y otra para el tráfico UDP que escuche y capture paquetes, si todo se ha configurado bien enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.


\subsubsection{Bluetooth: servicio y controlador}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: SetupBTinterface (asynTask)\\
\textbf{BluetoothController}: stop(), start(), connect(), setState() / StatusReceiver\_bt (BroadcastReceiver)
\end{files}
\end{codeInvolved}

Como en el controlador de \wifi{} empezamos (en segundo plano) liberando si no estuviesen ya cada uno de los recursos, en \bt{} coexisten dependiendo del tipo de nodo 3 tipos de hebras, la que acepta conexiones (\emph{AcceptThread}), la que lanza la conexión (\emph{ConnectThread}) y la que mantiene la conexión entre el esclavo y el maestro (\emph{ConnectedThread}), de este tipo podemos tener más de una.
Encendemos la interfaz \bt{} si no estuviese encendida ya, mediante una petición al sistema \android{} y esperando mediante \emph{polling} a que \emph{StatusReceiver\_bt.java}, el \emph{broadcastReceiver} para la interfaz \bt{} modifique la variable de control de esta espera. Una vez finalizada, procedemos a configurar las hebras del controlador según el tipo de nodo.
\paragraph{Normal} Este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita arrancar una hebra para aceptar conexiones, como sólo esperamos un maestro cuando consigue una conexión (disparada sobre el mismo UUID por el que hemos registrado el socket) liberamos este recurso. Como ya hemos configurado la interfaz enviamos el mensaje final del \emph{handshaking} con las instrucciones que hemos visto ya.

\paragraph{Coordinador} Este tipo de nodo se comporta como maestro en la comunicación \bt{}, no necesita aceptar conexiones, pero si disparar éstas. Para ello, recogemos de la base de datos los nodos inactivos y para cada uno de ellos lanzamos una conexión gracias al método connect() que se ejecuta en su propia hebra para asegurarnos que no se ejecuta en la hebra de la interfaz de usuario, en este caso no hace falta ya que la estamos llamando desde el segundo plano, pero como veremos este método se llama también directamente desde la UI-thread. Este método coge como parámetros la dirección MAC con la cual queremos establecer una conexión y el número de intentos que vamos a intentar establecer esta conexión (a parte de otras constantes como el UIID), como en \bt{} es fácil que falle el establecimiento intentamos minimizar este riesgo reintentando la conexión. En el momento que conseguimos establecer la conexión, liberamos esta hebra que se volverá a crear con el siguiente intento de conexión a otro nodo y manejamos la conexión con una nueva hebra del tipo \emph{connectedThread}, al final tendremos tantas hebras como nodos activos en la red. La forma en la que sabemos cuando podemos pasar al siguiente nodo radica en 2 flags que son modificadas gracias al sistema de estados: setState(), que tienen los controladores. En esencia, cuando disparamos una conexión y ésta falla propagamos un estado de conexión fallida al servicio que aumentara el flag de conexiones fallidas (\emph{numFailConnection}), si la conexión se produce con éxito se propaga análogamente un estado de nuevo nodo en la red y modificaremos el flag de nuevo dispositivo (\emph{flagNewDevice}) saliendo de la espera en la que nos encontramos, por establecimiento de la conexión o por llegar al máximo de intentos.

 Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje del \emph{handshaking} con el formato visto en la tabla~\ref{tab:endHandshakingNotCWSNMessage}.

 
\subsection{Registro de un nodo en la red}

Según la interfaz en la que nos encontremos se alterna el papel de quién da el primer paso. Así en \bt{} el nodo normal espera una conexión entrante y en \wifi{} es el coordinador quién espera un paquete UDP enviado desde un nodo normal.
\subsubsection{WiFi}
\begin{codeInvolved}
\begin{files}
\textbf{WifiController}: SendHelloPacket (AsynTask), UDPlistener (Thread), stopSendingHelloPacket(), setState()\\
\textbf{Service}: mHandlerWf, sendInfoNewNodeOnNetwork()\\
\textbf{Database}: eventNewDeviceIPCoordinator(), newDeviceEventNormal(), modifyNode()
\end{files}
\end{codeInvolved}
Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otra \emph{AsynTask} que comienza a enviar paquetes cada 800 milisegundos hasta llegar a un máximo de 20. La razón de enviar una ráfaga de paquetes radica en que al ser trafico broadcast/multicast los puntos de acceso pueden menospreciarlo (incluso bloquearlo) y el mismo dispositivo \android{} puede que no esté escuchando siempre en este tipo de direcciones. De hecho cuando se apaga la pantalla, el driver de \wifi{} se reconfigura automáticamente para dejar de escuchar a la dirección de broadcast, por ello una ráfaga de 20 paquetes espaciados en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta el proceso de registro terminará enviando hacia el servicio el estado {\small (EVENT\_HELLO\_NOT\_REACHED)} que será interpretado por el éste quien informará a todas las aplicaciones registradas del fallo del proceso indicando que no ha sido posible establecer una CWSN {\small (EVENT\_INTERFACE\_CANT\_CONNECT)}.\\

Este tipo de paquetes lo denominamos \emph{``HelloPacket''} y su contenido es:
\begin{description}
\label{itm:helloPacket}
  \item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red
  \item[Papel del nodo] Una \String{} cuyo valor ``p'' es interpretado como primario y ``s'' como secundario (``u'' para valor desconido)
	\item[Tipo de nodo] Una \String{} cuyos valores pueden ser: ``n'' normal, ``c'' coordinador  (``t'' coordinador temporal en \bt{} [sin implementar], ``u'' para valor desconocido)
	\item[Dirección MAC] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca
\end{description}


Si por el contrario uno de los paquetes llega a destino y es manejado por el coordinador, éste interpretará el contenido dentro del mismo controlador, así evitamos propagar información al servicio de paquetes que no encajen con la estructura y campos requeridos desechando otros paquetes. Si capturamos un \emph{``HelloPacket''} generaremos un evento de nuevo nodo en la red {\small (EVENT\_ENTERED\_IN\_NETWORK)} con la información leída del paquete. 
Este evento llega al \emph{handler} de \wifi{} en el servicio, dónde lo primero que hacemos es ver si el nodo ya está registrado en la red (este paso es necesario ya que tenemos varios envíos del mismo paquete por parte del mismo nodo), si ya está registrado ignoramos este evento, pues es una copia de otro anterior durante una guarda de tiempo. La motivación de esta guarda recae en que en \wifi{} no se detecta inmediatamente que un nodo se ha caído de la red, sólo nos podemos dar cuenta cuando intentamos enviarle algo y obtenemos un error. Puede darse la situación de que un nodo se registre, se caiga e intente registrarse de nuevo. Si en este lapsus nadie ha intentado ponerse en contacto con él, el resto de nodos seguirán creyendo que el nodo está en la red, si ignorasemos este evento el nodo que está intentado cerrar su registro en la red no tiene manera de saber que en realidad a ojos de los demás nodos él ya está registrado en la red, creyendo que su \emph{``HelloPacket''} no ha llegado a destino resultando una situación de falso fallo. Si no estaba activo en la red, lo marcamos como activo (insertándolo, si no estuviese ya, en la base de datos con la información facilitada por el controlador)
Acto seguido el coordinador informará a éste nodo del resto de nodos que ya hay en la red y al resto de nodos de la red se les informará del nuevo nodo. Por su parte el coordinador informará a las aplicaciones registradas que ha habido un nuevo nuevo nodo en la red y facilitará la lista de nodos.

La información de señalización que se envía y que representa al nodo es:
\begin{table}[h]
	\begin{description}
  	\item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red
  	\item[Papel del nodo] Una \String{} cuyo valor ``p'' es interpretado como primario y ``s'' como secundario (``u'' para valor desconido)
		\item[Tipo de nodo] Una \String{} cuyos valores pueden ser: ``n'' normal, ``c'' coordinador  (``u'' para valor desconocido)
		\item[Dirección MAC] Un \String{} cuyo valor es la dirección MAC en \bt{} del nodo, clave que identifica al nodo de manera unívoca	
		\item[Dirección IP] Una \String{} cuyo valor representa la dirección IP (formato IP4) del nodo
		\item[Dirección MAC del coordinador] Una \String{} que contiene la dirección MAC de \bt{} del coordinador del nodo que estamos 	enviando la información
	\end{description}
	\caption{Representación de un nodo necesaria para recrear el mapa de red, contenido del mensaje de señalización} \label{itm:infoNode}
\end{table}
Al recibir esta información el nodo normal, su controlador ya le habrá informado al servicio que está recibiendo datos, este evento le sirve al servicio para ver que ha sido registrado en la red y genera el mismo un evento de entrada en la red {\small (EVENT\_ENTERED\_IN\_NETWORK)} que sirve para homogeneizar el flujo y que sea idéntico al de \bt{}, este evento sirve para parar el envío de ``HelloPacket''. Al terminar de recibir el mensaje de señalización antes de procesarlo, tendremos que comprobrar que el nodo coordinador ya está incluido en la base de datos y si no incluir su MAC para obtener el identificador de nodo. El esquema de base de datos nos exige conocer a priori el identificador del nodo para poder traducir las direcciones MAC de \bt{}. A medida que vamos procesando el mensaje vamos sustituyendo los valores anteriores (o de relleno si el nodo coordinador no estaba incluido en la base de datos) por los nuevos extraidos del mensajes de señalización. En este momento el nodo normal informará a las aplicaciones de que ha entrado en la red y anunciará la lista de nodos quién es el coordinador. \comp{es oportuno decir que por motivos de eficiencia, solo hacemos una pasada por el mensaje} 

\subsubsection{Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{BluetoothController}: connected(), setState()\\
\textbf{Service}: mHandlerBt, sendInfoNewNodeOnNetwork()\\
\textbf{Database}: newDeviceEventNormal(), modifyNode(), updateInfoDeviceCoordinator()
\end{files}
\end{codeInvolved}

Como hemos explicado antes, es ahora el coordinador quien tiene que dar el primer paso, de hecho cuando se congifura la interfaz, está incluida una ronda de conexión a los nodos inactivos. Al producirse esta conexión, es decir al crear una hebra del tipo \emph{ConnectedThread}, tanto el nodo coordinador como el nodo normal informan a sus respectivos servicios que se ha producido un evento de nodo nuevo {\small(EVENT\_NEW\_DEVICE)}
\paragraph{Normal} Al recibir el evento conexión al coordinador vemos si éste está en la base de datos, si no lo estuviese, incluiríamos su MAC para obtener su identificador y pospondríamos el anuncio del nuevo nodo hacia las aplicaciones hasta que no obtengamos el mensaje de señalización donde se nos informa de las características del resto de nodos en la red. Si por el contrario ya habíamos cooperado antes con este nodo, anunciaremos de inmediato hacia las aplicaciones el evento de conexión al nodo coordinador. Notar que los parámetros del nodo coordinador (nombre y papel) pueden ser valores que no se correspondan con la situación actual, no es una cosa que nos deba preocupar pues en primer lugar son parámetros cuyo cambio suele ser puntual y en segundo lugar será solventado momentos después al recibir la señalización con información sobre la población en la red.

\paragraph{Coordinador} El flujo también comienza preguntándonos si habíamos cooperado ya con el nodo al que acabamos de conectarnos. Si no estuviese en la base de datos, le enviamos un mensaje de petición de información para que nos informe de su nombre y papel, ya que su MAC y su tipo (normal) lo sabemos porque o nos lo facilita el controlador o porque es deducible por el contexto. El nodo normal al recibir este mensaje envía sus datos, que nosotros procesamos como si fuese una actualización de parámetros en la red más lo que conlleva modificar los datos del nodo que nos lo envía y la propagación de estos al resto de nodos. Además en este caso como el nodo no estaba en la red, se le envía información sobre la red cerrando el proceso de registro y se anuncia hacia las aplicaciones la entrada de un nuevo nodo.

\subsection{Salida de un nodo de la red}
La dificultad en el proceso de salida de un nodo de la red viene marcada tanto por la interfaz como por el tipo de nodo que se trate. Es un proceso que tiene dos lados, el nodo que se desregistra en la red y los nodos que se quedan.
El proceso en el lado del nodo que se va, termina con la preparación de la base de datos para una nueva instancia del servicio, estas acciones comprenden resetear las direcciones IP y el identificador del coordinador para cada nodo, así como el marcaje de éstos como inactivos, por último una indicación de que el servicio ha sido parado de forma volunaria. De tal forma que al instanciar de nuevo el servicio tengamos una situación de partida inicial. 
Estas acciones (incluidas en el método \emph{onDestroy()} del servicio) no son ejecutadas si la salida es forzosa, debido a un error no manejado que provoca el cierre o debido a la falta de memoría que provoca que el gestor de \android{} cierre la aplicación. En este caso como no se ha puesto la marca de cierre voluntario del servicio, al arrancar la aplicación de nuevo podemos hacer estas acciones para desembocar en la misma situación inicial.

La parte central de este proceso depende de la interfaz configurada en ese momento:
\subsubsection{WiFi}
\begin{codeInvolved}
\begin{files}
\textbf{WifiController}: sendbyePacket(), sendbyePacketReliable(), SendByePacket (AsyncTask)\\
\textbf{Service}: mHandlerWF, eventLostActionsNormal(), onDestroy(), onCreate()\\
\textbf{Database}: lostNode()
\end{files}
\end{codeInvolved}
En esta interfaz tenemos una conexión intermitente, que se desplega y se retrae en los momentos en los que hay comunicación. En esta situación ante eventualidades no tenemos el mismo tiempo de reacción como lo podemos tener en \bt{}. En el caso de salida voluntaria necesitamos un mecanismo que informe que un nodo va a abandonar la red.

Este mecanismo consiste en el envío de un paquete llamado ``ByePacket'' que contiene la MAC del nodo que abandona la red. El envío de este paquete puede ser sobre TCP o UDP, en el caso de que el envío sea desde el nodo coordinador, solo podremos mandarlo sobre TCP ya que los nodos normales no escuchan sobre UDP como hemos visto en \ref{subsec:configInterface}. Este envío se realiza gracias a otra asynTask que al finalizar libera los recursos del controlador cerrando la vida de la aplicación por completo.

\paragraph{Normal} Al recibir de manera fiable el mensaje por parte del coordinador, el controlador generará un evento de pérdida de nodo que llegará al servicio donde procederemos a marcar a todos los nodos como inactivos y demás información volátil de la CWSN, por otra parte informamos a las aplicaciones registradas de la pérdida del nodo y de la salida de la red.

\paragraph{Coordinador} Al recibir el mensaje se generará el evento de pérdida de nodo que se entregará al servicio. Marcaremos este nodo como inactivo y veremos si aún quedan nodos en la red, si la respuesta es afirmativa enviaremos un mensaje de señalización a cada nodo restante en la red informando de la pérdida, así ellos podrán recomponer el mapa de red e informar a sus aplicaciones, informamos también a nuestras aplicaciones registradas del evento y de la nueva lista de nodos. Si la respuesta es negativa, nos limitamos a informar a las aplicaciones registradas del evento de pérdida y del evento de salida de la red.

\subsubsection{Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{BluetoothController}: connectionLost(), setState()\\
\textbf{Service}: mHandlerBt, eventLostActionsNormal(), onDestroy(), onCreate()\\
\textbf{Database}: lostNode()
\end{files}
\end{codeInvolved}
En este caso tenemos una conexión abierta en todo momento, por lo que ante cualquier eventualidad nos daremos cuenta inmediatamente de que se ha perdido la conexión, lo que hace innecesario el mecanismo descrito en la sección anterior.

Tanto si se trata de una salida voluntaria como involuntaria, se destruye tanto la aplicación como el servicio, se liberan todos los recursos. Al cerrarse el controlador de \bt{}, las hebras que haya abiertas desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de que el \emph{socket} usado en la comunicación ha sido cerrado, lo que supone que el controlador detecte el cierre de la conexión y lance el evento de pérdida de nodo.
\paragraph{Normal} Si somos un nodo normal, significa que hemos perdido conexión con nuestro coordinador (que acaba de abandonar la red) y por tanto con toda la red, por lo tanto marcamos a todos los nodos como inactivos borrando además todos los datos relativos a la CWSN que acabamos de abandonar. Informamos a las aplicaciones registradas que hemos dejado de formar parte de la CWSN.

\paragraph {Coordinador} Si por el contrario somos un nodo coordinador, significa que hemos perdido la conexión con un nodo normal con el que teníamos comunicacion directa y debemos informar al resto de nodos de esta eventualidad enviando un mensaje de señalización con la MAC del nodo saliente para que ellos puedan rehacer el mapa de red. Marcamos también al nodo del que acabamos de perder la comunicación como inactivo e informamos a las aplicaciones registradas del evento y la nueva lista de nodos. Si todos los nodos de nuestra base de datos están marcados como inactivos, significa que acabamos de perder la comunicación con el último nodo y por tanto dejamos de estar en CWSN situación que informamos a las aplicaciones registradas de manera análoga. 

\subsection{Actualización de parámetros en la red}
\label{subsec:updateSettings}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, spreadNodeChangeOnNetwork(), updateInformationToCoordinator()
\end{files}
\end{codeInvolved}


Los parámetros del servicio se pueden dividir en dos grupos, los propios del servicio y los de las aplicaciones de los cuales uno de ellos es único y por tanto está compartido entre todas ellas.

\begin{table}[h]
\begin{center}
	\begin{tabular}{r @{\hskip 1cm} p{7cm}}
	\multicolumn{2}{c}{Parámetros exclusivos servicio}\\ \hline 
	\textbf{Nombre del nodo} & Una \String{} que represente el nombre del nodo en la red \\
	\textbf{Tipo de nodo} & Un \integer{} cuyo valor 0 se traduce por normal y cuyo valor 1 corresponde a coordinador \\
	\textbf{Periodo tarea cognitiva} & Un \double{} que expresa el número de segundos que transcurren entre ejecuciones de la tarea cognitiva\\
	\noalign{\vskip 0.25cm} 
	\multicolumn{2}{c}{Parámetros aplicación}\\ \hline 
	\textbf{Papel del nodo} & Un \integer{} para representar el papel que juega el nodo en la red, 0 = secundario mientras que 1 = primario \\
	\textbf{Código de aplicación} & Una \String{} para discernir entre mensajes enviados por distinas aplicaciones \\
	\end{tabular}
	\caption{Parámetros del servicio} \label{tab:serviceSettings}
\end{center}
\end{table}

Los primeros parámetros son ajustes del servicio que traspasan a cualquier aplicación, sin embargo los segundos si son propios de cada aplicación el primero expresa sus necesidades de comunicación y el segundo nos sirve para filtrar mensajes en el servicio y entregar el contenido que está dirigido a esa aplicación en concreto. El parámetro ``papel del nodo'' en realidad es un parámetro compartido, es decir si varias aplicaciones están registradas en el servicio cada una habrá aportado un valor distinto, como este valor es único, elegimos el que es más adecuado a las necesidades de comunicación de la aplicación mas restringida. En otras palabras si una aplicación pide ser ``nodo primario'' y otra aplicación pide ser ``nodo secundario'' el valor del parámetro será ``nodo primario''.

La primera forma de actualizar los parámetros de aplicación es con el registro de la aplicación en el servicio (ver sección~\ref{subsec:serviceRegisterProcess}) o en cualquier momento enviando un mensaje desde la aplicación al servicio del tipo {\small(REGISTER\_EXCHANGE)} (visto en la tabla~\ref{tab:registerExchangeMessage}) que desembocará en una contestación con todos los parámetros del servicio.
Con respecto a los parámetros exclusivos del servicio, la forma de actualizarlos está un poco escondida en la API, ya que son ajustes propios del servicio y no de la aplicación y por tanto sometidos a cambios poco frecuentes. Normalmente estos parámetros están guardados en base de datos y se recuperan al recibir un mensaje del tipo {\small(REGISTER\_EXCHANGE)}, sin embargo si en este mensaje viene informado el campo \emph{obj} con un valor booleano a \true{} entonces en vez de coger los parámetros de la base de datos, los extraemos del mensaje. El detalle del mensaje con todos los parámetros es el siguiente:

\messageTableInit{\appToServ}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{0=secundario / 1=primario}{0=normal / 1=coordinador}{\true{}}{\messApp{}}
\messageTableExtra{appCode}{Una \String{} con el código de aplicación}
\messageTableExtraAddrow{nodeName}{Una \String{} con el nuevo nombre del nodo en la red}
\messageTableExtraAddrow{periodTask}{Un \double{} con el nuevo periodo medido en segundos de la tarea cognitiva a ejecutar}
\messageTableEnd{Actualización de todos los parámetros del servicio}{updateAllParamsMessage}
 
La actualización de estos parámetros (tanto cuando sólo actualizamos los de aplicación o todos) viene condicionada a si estamos cooperando ya en una red o no. Si no estamos en ninguna red los valores pasados sobreescribiran los existentes. En cambio si estamos en una situación de red, los parámetros ``papel del nodo'' y ``periodo tarea cognitiva'' pueden no ser actualizados, su actualización depende por tanto del valor actual, si es más restrictivo se podrán actualizar. Es decir para el ``papel del nodo'' sólo actualizaremos si el cambio pedido es a ``nodo primario'' y para ``periodo tarea cognitiva'' sólo actualizaremos si el periodo requerido es más pequeño que el actual.  Con respecto al parámetro ``tipo de nodo'' una vez se está en una CWSN no se permiten cambios ya que dejaríamos a la red sin coordinador o añadiriamos otro coordinador, situaciones que no son de interés.\\

Con respecto a la actualización de estos parámetros al resto de nodos, una vez validados y actualizados según las reglas descritas, si son de interés general (``nombre del nodo'', ``papel del nodo'') son enviados al coordinador para que este los distribuya como una actualización más del mapa de red.

En \bt{} puede darse la situación de que si somos un nodo normal los demás nodos nos vean con parámetros antiguos, esto es debido a que si actualizamos nuestros parámetros fuera de una CWSN, estos obviamente no son propagados a la red, al ser incluidos en la red por el coordinador, que ya nos conoce de veces anteriores, no tiene manera de saber que hemos actualizado los parámetros y como para minimizar el paso de mensajes por la red no nos pregunta sino que saca una copia de su base de datos los parámetros que tiene el resto de la red son la copia desactualizada de la base de datos del coordinador y no los parámetros nuestros. Esta situación es muy poco frecuente por lo que se ha preferido minimizar el tamaño de mensajes de señalización y el número de estos antes de mantener actualizados en todo momento los parámetros del nodo (``nombre del nodo'', ``papel del nodo'' y ``tipo de nodo'' aunque este último es deducible por el contexto). Esta situación no ocurre en \wifi{} ya que la forma de registro en la red conlleva el envío de un paquete para registrarse en el que enviamos toda la información del nodo, por lo que sobre \wifi{} se puede actualizar en cualquier momento y sobre \bt{} sólo en momentos de cooperación en red. No obstante la situación de desactualización se soluciona cuando hay un cambio de contexto con interfaz destino \wifi{}.

%----------------------
\subsection{Intercambio de mensajes}
La transmisión y recepción de datos se realizan a través del intercambio de mensajes definidos en la API. Podemos destacar tres acciones, el envío, la recepción y una mezcla de ambos reservada sólo al coordinador que es el re-envío o \emph{forward} de mensajes.

\subsubsection{Recepción de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, mHandler<controlador>, incomingContentNormal(), incomingDataMessageToApp()\\
\end{files}
\end{codeInvolved}
Empezamos explicando este proceso por ser el más fácil. Cuando la hebra del controlador (no importando cual) sale de su bloqueo al recibir datos, se genera el evento de recepción de datos que es manejado en el servicio. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona nuevamente al servicio esta información que dependiendo del controlador, incluirá {\small EXTRAS} distintos.

\messageTableInit{\controllerToServ}{2 =\\ \scriptsize{MESSAGE\_READ}}{Número de \emph{bytes} leídos}{\nc{}}{\emph{bytes} leídos de la red}{\nc{}}

\messageTableExtraControllerSpecified{\wifi{}}{device\_ip\_address}{Una \String{} con la direción IP del nodo que nos envía los datos}

\messageTableExtraControllerSpecified{\bt{}}{device\_name}{Una \String{} con el nombre proporcionado por los servicios de \bt{} de \android{} (no es relevante)}
\messageTableExtraAddrow{device\_address}{Una \String{} con la dirección MAC de \bt{} del nodo que nos envía los datos}

\messageTableEnd{Mensaje recibido por la red entregado por ambos controladores al servicio}{MessageReadController}

Una vez tenemos los \emph{bytes} leídos en el servicio los procesamos. Este procesamiento puede ser tan simple como entregar el contenido del mensaje a la aplicación correspondiente o reenviar el mensaje al siguiente eslabón de la cadena (sección explicada en la página~\pageref{forwardProcess}). El tratamiento del mensaje depende del tipo de nodo. Sin embargo, la presentación del mensaje hacia la aplicación si éste está dirigido hacia nosotros es común. Para ello necesitamos obtener el ``Código de aplicación'' (ver tabla~\ref{itm:dataMessage}) que nos permite recuperar el \emph{messenger} de la aplicación. Así filtramos y entregamos a cada aplicación los mensajes que le interesan. También, gracias al campo ``Desde'' sabemos quién es el originador del mensaje. Una vez hemos recuperado la aplicación destinataria y el nodo que envío el mensaje, podemos trasladar esta información a la aplicación correspondiente. 

\messageTableInit{\servToApp}{8 =\\ \scriptsize{INCOMING\_CONTENT \_PROGRESS}}{\nc{}}{\nc{}}{\emph{payload}}{\nc{}}
\messageTableExtra{device\_id}{Un \integer{} que identifica al nodo que ha enviado el mensaje}
\messageTableEnd{Mensaje datos recibidos}{incomingContent}
 

\subsubsection{Envío de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, builtDataMessage(), getNextNodes(), send(), mHandler<controlador>, outgoingContentProgress()\\
\textbf{DataMessageQueue}: add(), hashMessage(), changeStatus(), remove()
\end{files}
\end{codeInvolved}
Para enviar datos a través del servicio cognitivo, la aplicación debe enviar un mensaje a través de la API con la siguiente estructura:

\messageTableInit{\appToServ}{4 =\\ \scriptsize{OUTGOING\_CONTENT}}{\nc{}}{\nc{}}{\emph{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{}s con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje para el envío de datos}{outgoingContent}

Asumimos que el mensaje que se quiere enviar es un contenido que se puede codificar como una \String{}, por tanto este es el tipo de dato que se espera en el campo \emph{obj} del mensaje (\emph{payload}). Una vez entregado el mensaje al servicio se empieza a procesar. En primer lugar se comprueba que todos los valores de la lista son nodos de la red y están activos, también comprobamos que estamos en una CWSN //TODO TODO TODO en el código y manejar el error de casting. o un campo adicional para selecionar tipo contenido // Si no se superase alguna de estás validaciones se entregaría a la aplicación un mensaje de error con el código y descripción pertinentes y se abortaría el proceso. Si no hay ningun problema, confeccionamos el mensaje que se va a enviar a la red cuyo formato vemos en la tabla~\ref{itm:dataMessage}.

\protobufTableInit{Estructura mensaje datos}
  \item[Tipo] Valor ``DATA'' del enumerado ``MessageType''
  \item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo
	\item[Lista destinatarios] Una lista de \String{} con la lista con las direcciones MAC de \bt{} de los nodos destinatarios
	\item[Código de aplicación] Una \String{} con el código de aplicación para filtrar el mensaje en destino 
	\item[Marca de tiempo] Un \emph{long} con la representación del momento en el cual la aplicación entregó el mensaje al servicio
	\item[Mensaje de datos] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo''
	\begin{description}
		\item[Payload] Una \String{} con el contenido del mensaje 
	\end{description}
\protobufTableEnd{Campos del mensaje de datos}{dataMessage}

Una vez tenemos el mensaje lo guardamos en una cola, lo que nos ayuda a calcular el tiempo de llegada de los mensajes de datos por parte de las aplicaciones y es necesario para ofrecer a la aplicación una confirmación positiva o negativa sobre la entrega a los nodos destinararios para cada mensaje. Como esta confirmación puede no ser inmediata, necesitamos almacenar de alguna manera el mensaje para poder recuperarlo cuando nos llegue ésta. Para guardarlo y rescatarlo cuando llegue el momento nos ayudamos de una clave, un \emph{hash} calculado en base a la marca de tiempos, el contenido del mensaje y la MAC de \bt{} del nodo que envía el mensaje. 

El siguiente punto es ver si podemos enviar el mensaje por la red, para ello debemos estar registrados en una CWSN y no estar en una situación de cambio de contexto, si se da esta situación marcamos el mensaje como ``pendiente de envío'' en la cola. Si podemos enviarlo lo marcamos como ``en envío'' y se procede al envío. Para ello necesitamos saber quién o quienes son los siguientes nodos en la cadena de envío, esto depende del tipo de nodo y del mapa de red. Aunque gracias a que cada nodo tiene información sobre cómo alcanzar a otros nodos, nuestra red está centralizada en la figura del coordinador por lo que la comunicación entre nodos no es posible siendo precisa una comunicación de saltos en los que el coordinador juega el papel central. Hay casos en que esta comunicación de saltos viene forzada por la interfaz de comunicación de uso, estamos hablando de \bt{} cuya única tipología posible es la de estrella (esclavo/maestro)

\paragraph{Normal} El siguiente eslabón de la cadena siempre es nuestro nodo coordinador, tanto si el mensaje es dirigido a él, como si lo es a otros nodos. 

\paragraph{Coordinador} El coordinador tiene comunicación directa con todos los nodos, en \wifi{} ocurre siempre y en \bt{} tenemos la restricción de hasta 7 nodos, si no introducimos la figura del ``coordinador intermedio'', nodo que se comporta como concentrador de mensajes en su piconet y que a su vez está en otra piconet donde se encuentra el coordinador. En nuestro caso como sólo hay un salto, tenemos contacto directo con cualquier nodo no importando la interfaz en la que nos encontremos. Por tanto los siguientes eslabones de la cadena de entrega son los mismos nodos que están en el campo ``Lista Destinatarios'' del mensaje a enviar.\\

Una vez tenemos éste y a quién se lo vamos a enviar, procedemos al envío (en la siguente sección veremos que necesitamos un parámetro más pero que por el momento podemos obviar). Enviar es basicamente pasar como parámetros el mensaje al método \emph{write()} del controlador traduciendo los nodos a la dirección de comunicación de la interfaz, es decir si tenemos que enviar un mensaje a una serie de nodos de los cuales tenemos sus identificadores, tendremos que traducir estos identificadores a las direcciones IP en el caso de \wifi{} o a las direcciones MAC en \bt{}. Una vez que el mensaje ha sido escrito en la red por el controlador, este mismo informa al servicio a través de un mensaje del tipo {\small(MESSAGE\_WRITE)} con resultado del envío, enviándonos el propio mensaje de vuelta más una lista de las direcciones de comunicación a las cuales no ha podido entregar el mensaje.

\messageTableInit{\controllerToServ}{3 =\\ \scriptsize{MESSAGE\_WRITE}}{número mensajes escritos OK}{número mensajes escritos NOK}{\emph{bytes} enviados a través de la red}{\nc{}}
\messageTableExtra{requester}{Una \String{} que representa el \emph{messenger} de la aplicación que origina el mensaje}
\messageTableExtraAddrow{addressNotDelivered}{Una lista de \String{} con las MAC de \bt{} o direcciones IP de los nodos a los cuales el envío del mensaje ha resultado fallido, según el controlador que nos envíe el mensaje}
\messageTableEnd{Mensaje resultado envío de datos desde el controlador al servicio}{MessageWriteController}
TODO TODO TODO

Dependiendo de quienes sean los destinatarios del mensaje, el mensaje habrá llegado a su destino (no hay saltos de por medio) y por tanto no necesitamos más confirmación de entrega que la que ya nos da TCP de por si. Si no tuviesesemos contacto directo con los nodos a los que queremos enviar el mensaje necesitamos esperar a que nos confirmen el resultado de la entrega de éste.

\paragraph{No es necesario recibir mensaje ACK} En este primer caso, al ser una entrega directa, si somos un nodo normal el mensaje tiene como único destinatario nuestro coordinador. Si somos un nodo coordinador el mensaje ha sido entregado en mano a todos los nodos. Como ya se ha terminado el flujo de envío del mensaje, procedemos a borrarlo de nuestra cola de mensajes gracias al \emph{hash} y a entregar un mensaje a la aplicación con información sobre la entrega.

\paragraph{Es necesario mensaje ACK} En el segundo caso, el mensaje envíado requiere de un salto en la red, requiere de un reenvío. La casuística de cómo se producen este tipo de mensajes será explicada en la siguiente sección, en ésta nos limitamos a ver el proceso de recepción del ACK vista desde un nodo normal. En este caso al recibir por parte del controlador el mensaje (ver tabla~\ref{tab:MessageWriteController}) procedemos a su marcaje en la cola como ``pendiente de ack'' quedando a la espera de recibir la confirmación del envío del siguiente salto. Este mensaje de señalización tiene la composición descrita en la tabla~\ref{itm:ackMessage}.

\protobufTableInit{Estructura mensaje ACK}
  \item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo''
	\begin{description}
		\item[What] Valor ``ACK'' del enumerado ``AskType''
		\item[Mensaje de ACK] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What''
			\begin{description}
				\item[Hash] Un \emph{long} con el identificador único de mensaje
				\item[Número mensajes escritos OK] Un \integer{} con el número de mensajes que han sido correctamente entregados
				\item[Lista de direcciones MAC NOK] Una lista de \String{} con las direcciones MAC de \bt{} de los nodos a los cuales no se ha podido entregar el mensaje
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje ACK}{ackMessage}
  
Al recibir la confirmación procedemos a borrar de la cola el mensaje de datos utilizando el \emph{hash} leído de la señalización y a comunicar a la aplicación el resultado del proceso de envío. (El detalle puede verse en la tabla~\ref{tab:outgoingContentResultApp})
TODO TODO TODO camviar outgoinf content progress...\\ \\
\messageTableInit{\servToApp}{9 =\\ \scriptsize{OUTGOING\_CONTENT \_PROGRESS}}{número mensajes escritos OK}{número mensajes escritos NOK}{\emph{payload}}{\nc{}}
\messageTableExtra{IdsNotDelivered}{Un array de \integer{}s con los identificadores de los nodos a los cuales no les ha llegado el mensaje}
\messageTableExtraAddrow{NamesNotDelivered}{Un array de \String{} con los nombres de los nodos a los cuales no les ha llegado el mensaje}
\messageTableEnd{Mensaje resultado envío de datos presentado a la aplicación}{outgoingContentResultApp}


 
%\newpage
\subsubsection{Forward de mensajes}
\label{forwardProcess}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: mHandler<controlador>, incomingContentCoordinator(), outgoingContentProgressCoordinator()\\
\end{files}
\end{codeInvolved}

Esta sección es una mezcla de una recepción y un envío de mensajes, reservada al papel de coordinador. Este proceso comienza con la recepción de un mensaje originario en un nodo normal cuya lista de nodos destinatarios atañe a más nodos de los dos implicados en esta comunicación. En esta lista puede estar o no incluido el coordinador, si está incluido como paso inicial presentaremos el mensaje a la aplicación como hemos descrito en la recepción de mensajes. Acto seguido procederemos al re-envío de éste, para ello como vimos en la sección anterior tenemos que conocer cuáles son los siguientes nodos a los que enviar el mensaje (prestando especial atención a que si es un mensaje dirigido a todos, no volver a enviarlo al nodo originario), el mensaje a enviar que es el mismo que acabamos de recibir (sin hacerle ningún cambio) y por último el parámetro que antes obviamos.

Esta elusión tiene como motivación haber facilitado la lectura de secciones anteriores al no añadir otra pieza más al rompecabezas. Nuestro flujo de trabajo necesita transmitir a través de todas las capas (servicio, controlador y capas inferiores, si intervienen) qué aplicación es la originaria del mensaje para poder ofrecerle una respuesta cada vez que envie datos a través del servicio. No se puede utilizar el ``Código de aplicación'' grabado en el mensaje de datos ya que puede haber dos o más aplicaciones registradas con el mismo código. El parámetro por tanto es una simple \String{} que representa el \emph{messenger} de la aplicación, que gracias a una serie de \emph{HashMap} nos relaciona ambos datos. De esta manera evitamos por tanto serializar un objeto complejo o ubicarlo en un sitio que no está pensado para ello, debido a que al estar en capas diferentes el campo (\emph{msg.replyTo}) se usaría con otro propósito lo que hace poco claro el código. Es necesario transmitir este parámetro a través de todo el flujo de envío ya que son procesos sin memoria que pueden ser disparados por distintas aplicaciones en cualquier momento donde además el preservamiento del orden entre distintos procesos de envío no está garantizado.\\

Cuando el mensaje requiere de un re-envío, no existe una aplicación para rellenar este parámetro, elegimos dos \String{} reservadas que son ``forward-me'' y ``forward-not-me'' para referirse a la situación en la que el coordinador forma parte de la lista del mensaje que se reenvía y cuando no. Nuestro flujo al reconocer estas \String{} se da cuenta que se trata de un reenvío.

Al igual que en un envío normal, almacenamos el mensaje en la cola y lo enviamos. Al recibir por parte del controlador el mensaje descrito en la tabla~\ref{tab:MessageWriteController} pero es aquí dónde en vez de trasladar el mensaje a la aplicación (dado que no existe) es dónde confeccionamos el mensaje de confirmación (ver tabla~\ref{itm:ackMessage}) que enviaremos al originario del mensaje de datos, en vez de informar a la aplicación como se hace en el envío.
%------------------------------
\subsection{Sensado del entorno}

\subsection{Cambios de contexto}
\subsubsection{Cambio de contexto con interfaz destino WiFi}
\subsubsection{Cambio de contexto con interfaz destino Bluetooth}
%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
