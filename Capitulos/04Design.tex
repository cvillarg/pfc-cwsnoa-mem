%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\chapter{Diseño}
\begin{FraseCelebre}
	\begin{Frase}
	No es pretender el triunfo,\\ es resistir a los fracasos
	\end{Frase}
	\begin{Fuente} \textit{Def.} Esperanza, {\scriptsize\sc Novena Virgen de la Salud} \end{Fuente}
\end{FraseCelebre}
\begin{resumen}
En este capítulo definimos la arquitectura del nodo cognitivo sobre la que detallamos las interfaces de programación y los procesos de red invulcrados en su funcionamiento.
\end{resumen}


%-------------------------------------------------------------------
\section{Arquitectura cognitiva}
%-------------------------------------------------------------------
\label{sec:arquitecturaCognitiva}
\figura{Vectorial/design/node}{width=.65\textwidth}{fig:architecture}{Arquitectura cognitiva}

Nuestra arquitectura se ha diseñado siguiendo pinceladas del modelo
\ac{CB} \cite{conbrok}, no se han podido seguir todas las
recomendaciones puesto que no implementamos el objeto \texttt{CompNet}
(distintas redes cooperando para por ejemplo mitigar la interferencia)
y que no tenemos acceso a otros planos que no sea el de aplicación. Al
tener \textit{hardware} sin posibilidad de cambios y al tener un
control limitado de éste (sólo las partes que \android{} nos permite)
se desvanece la posibilidad de selecionar proactivamente la
modulación, la codificación o el nivel de potencia en la
transmisión. Nos restringimos a el diseño de una arquitectura
confiando en las propias capacidades cognitivas u optimizaciones que
elige la plataforma de por sí o que son accesibles de alguna u otra
manera: \textit{reflection}, \textit{root}\ldots\\

%En este primer parrafo creo que despues de la referencia va punto:
%[1]. Sin embargo, no se han podido...

%\figura{Vectorial/design/node}{width=.65\textwidth}{fig:architecture}{Arquitectura cognitiva}

Como puede verse en la figura~\ref{fig:architecture} se ha estructurado la arquitectura en dos capas, existiendo una subdivisión de la capa inferior en otras dos. Un modelo de capas permite definir interfaces de comunicación entre las diferentes unidades, limitando el alcance y conocimiento de cada módulo independizando su propósito del resto. A saber:

\begin{enumerate}
\item \bsq{\bf Capa de aplicación}: Formada por cada una de las aplicaciones que operan sobre el servicio cognitivo que les sirve como canal de comuncaciones. Cada una de estas aplicaciones, tiene que cumplir con la interfaz definida entre esta capa y la inferior (aplicación y cognitiva). El diseño e implementación de cada aplicación excede a este proyecto y depende en cada caso del tercero que desarolle la aplicación. No obstante para probar y utilizar las capacidades de nuestro nodo cognitivo se ha desarrollado una aplicación cuyo diseño presentamos en la sección~\ref{sec:app} e implentación en~\ref{sec:appImpl} en el siguiente capítulo.
\item \bsq{\bf Capa cognitiva} El interés del proyecto se centra en el desarollo de esta capa. Es una capa compuesta por otras dos: una primera capa de control donde se recoge toda la inteligencia y propósitos cognitivos y otra capa de actuación que provee de toda la funcionalidad para recibir y enviar datos por cada una de las interfaces de comunicación presentes:
	\begin{enumerate}[i.]
		\item \bsq{\bf Módulo cognitivo} Está fuertemente
                  inspirado en los módulos que podemos ver en la
                  arquitectura cognitiva desarrollada sobre Castalia
                  \cite{castaliacwsn} con ciertas peculiaridades e
                  implementaciones que veremos a continuación.

%XXX-jblesa No diria sobre Castalia, sino sobre un simulador cognitivo
%desarrollado en el laboratorio de sistemas integrados.

		\item \bsq{\bf Controladores de interfaz} Esta capa
                  está formada por cada una de las interfaces
                  presentes en el \textit{smartphone}. La implementación final recoge la interfaz de \wifi{} y \bt{}, pero el diseño recoge un número arbitrario debido a que si construimos este módulo siguiendo la interfaz entre capas, puede ser fácilmente añadida a la arquitectura final.
	\end{enumerate}
\end{enumerate}

A continuación haremos una breve descripción de los diferentes bloques que hemos definido en la arquitectura. Al ser los procesos entidades que hacen uso más de un bloque se ha preferido dejar para más adelante (sección~\ref{sec:procesosRed}) su explicación una vez vista la arquitectura. Así se obtienen varios puntos de vista que ayudan a comprender el funcionamiento.

\subsection{Interfaz Aplicación - Módulo Cognitivo}
El apellido cognitivo supone una abstracción en el modelo de comunicaciones de tal forma que el usuario (la aplicación) sea transparente a los parámetros, tiempos o detalles de la comunicación usada para transmitir los datos. Para lograr esta abstracción necesitamos un punto de ruptura que aisle y defina solamente la información estrictamente necesaria a intercambiar entre ambos agentes para poder recrear una \ac{CWSN}. En la sección~\ref{sec:api} se expone la definición de la \ac{API} que debe cumplir el desarrollador de las distintas aplicaciones.\\

Al definir una interfaz permitimos que terceros puedan desarollar sus propias aplicaciones que usen de este servicio para montar sus comunicaciones, podemos decir que es una interfaz tipo cliente-servidor, donde se permite dar soporte simultáneo a varias aplicaciones, esto es posible gracias al \texttt{Apps Manager} que explicamos en la siguiente sección.
%----------

\subsection{Sensor Manager}
Es el punto de entrada a nuestro servicio cognitivo, el encargado de
recoger las peticiones de las distintas aplicaciones e informar tanto
de la respuesta a la aplicación que lo solicitó, como al resto de
ellas si las hubiese acerca de información común generada en la
\ac{CWSN} donde cooperan. Esto se consigue gracias al submódulo
\var{Apps Manager} que lleva un registro de cada una de las
aplicaciones y permite discernir entre peticiones de éstas. Las
peticiones entrantes son sanetizadas y codificadas para poder disparar
los procesos internos a lo largo de los diferentes módulos y
descodificadas elimando cualquier rasto cognitivo antes de ser
entregadas a la aplicación en cuestión. La presencia del submódulo
\var{Queue} permite, entre otras funciones que se detallarán, encolar
mensajes de aplicación por si estas peticiones no pudiesen ser
atendidas en el mismo momento de la recepción (fundamentalmente debido
a cambios de contexto o \textit{handovers}. Una vez que las
condiciones lo permitan se consulta a esta cola para ver si quedan
ordenes pendientes.
%XXX-jblesa Ten cuidado con las palabras en ingles. Siempre hay que
%intentar buscar palabras en español.
%----------

\subsection{Policy, optimizer, executor}
Estos tres módulos podemos considerarlos como el cerebro cognitivo, su
interacción es jerárquica. De acuerdo a unas políticas descritas en el
módulo \var{policy}, el \var{optimizer} evalua el cumplimiento de
ellas conforme a valores que recoge del módulo \var{repository} que
sirve como punto concentrador de la información. Esta evaluación puede
generar nuevos valores a almacenar en el repositorio y/o la actuación
directa gracias a el módulo \var{executor}.\\


%XXX-jblesa. Exlica lo de la interaccion jerarquica, no lo veo claro.

Para nuestro primer diseño sólo hemos definido una política cognitiva
(ver sección~\ref{subsec:senseAndPolicy}) y el módulo ejecutor sólo
realiza cambios  de cambio de contexto o \textit{handovers}, debido a
las limitaciones en la plataforma para ajustar otros parámetros que
finalmente han sido descartados del diseño.

%XXX-jblesa Dos veces seguidas la palabra cambio.


%----------

\subsection{Repositorio}
\label{subsec:repository}
La información que hemos de guardar en el repositorio es:
%XXX-jblesa. Me falta una pequeña frase introductoria.

\begin{description}
	\item[Información relativa al servicio.] Necesitamos almacenar
          la interfaz actual de comunicaciones y el estado de ésta, así como un valor que nos permita averiguar si el servicio ha sido destruido por causas ajenas para intentar reconstruir la \ac{CWSN} ante una eventualidad. Esta información necesita ser persistente. También almacenamos cuál es el peridodo con la que el optimizador y ejecutor actúan en base al tiempo. Si en vez de sobreescribir esta información hacemos un seguimiento, podemos obtener información acerca de la estabilidad y la adaptabilidad de la red.

\item[Información relativa a los nodos en la red.] Para hacer un mapa
  de la red necesitamos información acerca de qué nodos hay en la red y cómo llegar a ellos. Los datos elegidos son:
	\begin{itemize}
		\item Identificador del nodo. Un \integer{} asignado al conocer el nodo por primera vez. 
		\item Nombre del nodo. Una \String{} representando el nombre con el que se presenta a la red.
		\item Papel del nodo. Una \String{} cuya codificación es: \bsq{p} para usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconido).
		\item Tipo de nodo. Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\bsq{u} para valor desconocido).
		\item Dirección \ac{MAC} de \bt{} del nodo. Este dato identifica al nodo unívocamente
		\item Dirección \ac{IP} del nodo.
		\item Identificador de su nodo coordinador. Un \integer{} que hace referencia a un identificador de nodo previamente conocido y que nos permite alcanzar todos sus datos.
	\end{itemize}

\item[Información relativa al sensado.] Los datos recogidos por cada dispositivo los almacenamos siguiendo esta estructura:
	\begin{itemize}
		\item Identificador del nodo, un \integer{} que nos indica quién es el propietario de la información.
		\item RSSI, un \integer{} con el valor en dBm de la intensidad de señal recogida de la red \wifi{}.
		\item Tasa de envío, un \double{} con el intervalo de tiempo medio de envios en la red.
		\item Marca de tiempo, una referencia al momento en que estos datos fueron obtenidos.
	\end{itemize}
\end{description}

Estos datos son compartidos con el coordinador quién distribuye (sin
filtrar, aunque podría implementarse un filtrado ya que se han
reservado valores \textit{dummy} encaminados a el ocultamiento de la
información) esta información. Nuestro repositorio, por tanto, es
distribuido de tal forma que todos tengan la misma foto aunque no
tengan los mismos valores, ya que los identificadores de los nodos en
cada dispositivo varían, la clave que nos permite sincronizar todo el
repositorio recae en la dirección \ac{MAC} de \bt{} que se usa como
clave primaria.

%XXX-jblesa. Quita dummy y pon algo en español.
%----------

\subsection{Discovery}
Este módulo se asemeja a los ojos de nuestra arquitectura, siguiendo
con el anterior símil del cerebro, una ventana al mundo. Ambos módulos
se conectan a través del repositorio (una especie de bus). En la
sección~\ref{subsec:senseAndPolicy}, se entra en detalle sobre los
parámetros recogidos del entorno. 

%XXX-jblesa. A que modulos te refieres con ambos modulos?

Este módulo no sólo recoge parámetros, si no que monitoriza el estado de las diferentes interfaces de comunicaciones, por ello parte de este módulo está muy ligado al controlador de la interfaz, sin embargo debido a que ciertas políticas necesitan que el optimizador evalue parámetros de interfaces de comunicaciones no activas, se ha sacado del diseño del controlador esta parte para añadirla al modulo \var{discovery} y que pueda ser manejada en cualquier momento. En la sección~\ref{subsec:btControllerImpl} del siguiente capítulo completamos el por qué de ésto. 
%----------

\subsection{Interface Manager}
Este módulo es el punto de salida del módulo o servicio cognitivo hacia los controladores. En confluyen dos planos: el primero para los mensajes de aplicación provenientes del \var{Sensor Manager} (plano de datos) y el segundo para la elaboración de señalización proveniente del módulo \var{executor} o de eventos de red generados en el gestor de estados (ver~\ref{subsubsec:stateManager}) (plano de control y gestión).\\

En el se implementan todas las funciones de encaminamiento que son necesarias transmitir a los controladores pues estos no conocen nada del plano cognitivo, son meras palancas de acción. En este módulo también implementamos el submódulo \var{Access} encargado de compartir con el resto de nodos parte de nuestro repositorio que es enviado por el canal \var{VCC}. 

El diseño del canal \var{VCC} encargado de transmitir toda la información de control y gestión de la \ac{CWSN}, se hubica en la misma red por la que circulan los datos, a diferencia de otros sistemas como el \ac{SS7} \cite{ss7} por razones de simplicidad. De hecho comparten ambos tráficos el mismo canal, la manera de distinguirlos reside en el valor de la etiqueta \var{MessageType}. Sin embargo, la arquitectura no cierra las puertas a que el plano de datos y el de control estén sean transmitidos en distintas interfaces de comunicación, por ejemplo datos en \wifi{} y señalización en \bt{}.

%----------

\subsection{Interfaz Módulo Cognitivo - Controlador}
\subsubsection{Comunicación hacia controlador: invocación de métodos}
La forma de comunicarse con el controlador de la interfaz es mediante la invocación de métodos del propio controlador. Al basarse en una programación en objetos, el módulo o servicio cognitivo tiene una referencia a cada controlador que le permite invocar sus métodos declarados como públicos permitiendo disparar procesos, para homogeneizar y que el servicio interactue de forma similar con todas las interfaces, sus controladores deben implementar una serie de métodos que desencadenen un proceso que al final tenga una respuesta parecida. Estos métodos son asíncronos cuya llamada no devuelve ningún valor, es a través de la interfaz entre las capas pero en el otro sentido como obtenemos la resuesta. Entre la serie de métodos que un controlador debe implementar, los indispensables al ser comunes a todos son:
\begin{description}
	\item[start()] \hfill \\Este método nos permite configurar el controlador teniendo en cuenta los requerimientos que tenga el módulo o servicio cognitivo.
	\item[stop()]\hfill \\Gracias a él se liberan todos los recursos (menos los relacionados con el módulo \var{discovery}).
	\item[write()]\hfill \\Para escribir cualquier tipo de información sobre la red:
	\begin{itemize}
		\item\bsq{Plano de datos}: canal de datos.
		\item\bsq{Plano de control}: canal \var{VCC}.
	\end{itemize}
\end{description}
%----------

\subsubsection{Comunicación hacia módulo: Gestor de estados}
\label{subsubsec:stateManager}
O \textit{State Manager}, es una interfaz de comunicación uniderecional desde los distintos controladores hacia el servicio para expresar el estado en el que se encuentran éstas. Estos mensajes son consecuencia de procesos bien disparados por el servicio al invocar métodos del controlador (módulo ejecutor e \var{Interface Manager}) o bien originados en el propio controlador al tratarse de un evento de red.

\paragraph{WiFi} Los diferentes estados y eventos en los que pueden estar la interfaz \wifi{}:%\\
\smTableInit{\textit{WiFi State Manager}}
	\smTableRow{STATE\_none}{event\_no\_device\_changes}	
	\smTableRow{STATE\_listen}{EVENT\_ENTERED\_IN\_NETWORK}
	\smTableRow{STATE\_sending}{EVENT\_LOST\_NODE}
	\smTableRow{STATE\_receiving}{EVENT\_HELLO\_NOT\_REACHED}
\smTableEnd{Gestor de estados WiFi}{wifiStateManager}
%~\\
\paragraph{Bluetooth} De manera análoga los diferentes estados y eventos en los que pueden estar la interfaz \bt{}:
\smTableInit{\textit{Bluetooth State Manager}}
	\smTableRow{STATE\_none}{event\_no\_device\_changes}	
	\smTableRow{STATE\_listen}{EVENT\_new\_device}
	\smTableRow{STATE\_connecting}{EVENT\_device\_LOST}
	\smTableRow{STATE\_connected}{EVENT\_CONNECTING\_DEVICE\_FAILED}
	\smTableRow{STATE\_sending}{EVENT\_CONNECTION\_ALREADY\_EXISTING}
	\smTableRow{STATE\_receiving}{}
\smTableEnd{Gestor de estados Bluetooth}{btStateManager}

Esta información recibida por cada controlador se mapea con los eventos y estados que veremos en la \ac{API} (ver sección~\ref{subsec:serviceInformation}) de forma que las singularidades de cada interfaz sean ocultadas más allá del servicio.
%----------
                                                     
%-------------------------------------------------------------------
\section{API: Definición, Cómo montar una aplicación sobre el servicio cognitivo}
%-------------------------------------------------------------------
\label{sec:api}
En esta sección se explica cada detalle de la interfaz Aplicación - Módulo Cognitivo en ambos sentidos, su cumplimiento es necesario para desarollar una aplicación que interactue de forma correcta con el módulo o servicio cognitivo. La forma de interactuar con éste se basa en, como se verá en \ref{sec:detallesImplementacion}, el intercambio de mensajes a través de los objetos \textit{Messenger} y \textit{Handler} provistos por \android{}. Estos mensajes provocan el disparo de ciertos procesos en el servicio que responderá, si procede, en cuanto el resultado esté listo. Son llamadas por tanto asíncronas, de igual modo el servicio entregará mensajes a las aplicaciones en cualquier momento sin que estás hayan solicitado nada.\\

La aplicación que haga uso del modelo no necesita cumplir más requisitos que la de manejar los distintos mensajes que le entrege el servicio en cualquier instante de tiempo y la de almacenar la lista de nodos formada por el par (identificador, nombre) entregada por el servicio y modificada en cada evento que lo requiera. La confección de algunos mensajes de la \ac{API} requieren que sean informados con algunos valores de la lista de nodos, por lo que la aplicación debe tener accesible esta lista ya que no hay una manera activa de pedirla al servicio.

Los mensajes que se intercambian tienen un campo \textit{what} que resume el proposito de éste, más una serie de añadidos experesados en forma de parámetros y extras que conforman y describen el proceso que está ocurriendo.
Este campo \textit{what} es un \integer{} único que define el número diferente de mensajes tipo que se intercambian, entre éstos habrá algunos que sólo existan en un sentido de la comunicación y otros que aparezcan en ambos sentidos.

\apiTableInit{Mensajes tipo intercambiados entre Aplicación y servicio}
	\apiTableRow{register\_client}{\phantom{0}1}	
	\apiTableRow{unregister\_client}{\phantom{0}2}
	\apiTableRow{register\_exchange}{\phantom{0}3}
	\apiTableRow{OUTGOING\_CONTENT}{\phantom{0}4}
	\apiTableRowNotImplemented{OUTGOING\_CONTENT\_PROGRESS}{\phantom{0}5}
	\apiTableRow{OUTGOING\_CONTENT\_RESULT}{\phantom{0}6}
	\apiTableRowNotImplemented{INCOMING\_CONTENT\_PROGRESS}{\phantom{0}7}
	\apiTableRow{INCOMING\_CONTENT}{\phantom{0}8}
	\apiTableRow{SERVICE\_INFORMATION}{\phantom{0}9}
	\apiTableRow{ERROR\_MESSAGE}{10}
	\apiTableRow{QUEUED\_MESSAGE}{11}
	\apiTableRow{CONNECT\_TO\_VIA\_BT}{12}
	\noalign{\vskip 0.25cm}
	\apiTableRow{{\footnotesize WORKAROUND\_WHAT\_TO\_REPLY}}{20}
	\apiTableRow{{\footnotesize WORKAROUND\_ASK\_RESPONSE}}{21}
	\apiTableRow{{\footnotesize WORKAROUND\_CONTEXT\_CHANGE}}{22}
	\apiTableRow{{\footnotesize WORKAROUND\_PENDINGMESSAGE\_INJECTION}}{23}
	\apiTableRow{{\footnotesize WORKAROUND\_PENDINGMESSAGE\_DISPOSAL}}{24}
\apiTableEnd{Mensaje tipo}{apiMessages}
 Las filas en gris corresponden a mensajes reservados no implementados como son las constantes \Scst{OUTGOING\allowbreak\_CONTENT\allowbreak\_PROGRESS} (5) y \Scst{INCOMING\allowbreak\_CONTENT\allowbreak\_PROGRESS} (7). Están pensadas para una posible segmentación de los mensajes de aplicación por parte del servicio. En caso de segmentación la forma de informar a la aplicación del progreso del envío de segmentos (y de la recepción de éstos) se haría con este tipo de mensajes. Las filas precedidas por \Scst{WORKAROUND} son comportamientos necesarios para disparar procesos manualmente, corresponden por tanto a una interfaz de \textit{test} no necesario su cumplimiento para el correcto funcionamiento.
%----------
\subsection{Conectarse al servicio}
\label{subsec:apiStart}
Para poder entregar y recibir mensajes necesitamos una referencia al \textit{Messenger} del servicio, esta referencia la obtenemos tras hacer una petición de \textit{bind} llamando al método \textit{bindService()} con un \textit{Intent} a la clase:
\begin{verbatim}
es.upm.die.lsi.pfc.CWSNoA.CognitiveLayer_specific_Service.class
\end{verbatim}
En la petición de \textit{bind} también se pasa como parámetro un objeto de la clase \textit{ServiceConnection} que el sistema \android{} llama cuando ha establecido la conexión. \android{} arrancará el servicio si éste no lo estaba ya y nos devolverá como objeto \textit{IBinder} una instancia del \textit{Messenger} del servicio. 
Por motivos de seguridad la aplicación que realice la petición de \textit{bind()} requiere la declaración en su archivo \bsq{\textit{manifest}} la aceptación del permiso:
\begin{verbatim}
es.upm.die.lsi.pfc.CWSNoA.permission.COGNITIVE_SERVICE
\end{verbatim}
Este permiso informa al usuario final que usa la aplicación del uso posible de la modificación de la interfaz \bt{} y \wifi{} sin la intervención de éste.

Una vez recuperada la referencia procedemos al registro de la aplicación en el servicio, para ello iniciamos un proceso de \textit{handshaking}. El primer mensaje no lleva ningún dato adicional, dicta de esta forma (ver tabla~\ref{tab:registerClientMessage}).

\messageTableInit{\appToServ}{1 =\\ \footnotesize{REGISTER\_CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje registro cliente}{registerClientMessage}

Acto seguido debemos informar sobre parámetros de nuestra aplicación al servicio con el envío de un mensaje con la siguiente información: 
\begin{description}
\item[Papel de nodo] En el campo \textit{arg1} del mensaje. \bsq{0} para indicar que somos un nodo secundario y \bsq 1 para indicar que nuestro papel es primario.
\item[Código de aplicación] Como extra del mensaje incluimos una \String{} con la clave ``appCode'' indicando qué aplicación somos, para intercambiar mensajes cuyo código de aplicación coincida.
\end{description}
A través del mensaje descrito en la tabla~\ref{tab:registerExchangeMessage}

\messageTableInit{\appToServ}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{0=secundario / 1=primario}{\nc}{\textit{null}}{\messApp{}}
\messageTableExtra{appCode}{Una string con el código de aplicación}
\messageTableEnd{Mensaje entrega parámetros de aplicación}{registerExchangeMessage}

Tras esto el servicio nos responderá con un mensaje igual tipo \Scst{REGISTER\_EXCHANGE}, pero del que puede haber dos variantes dependiendo de cuál fuera la situación del servicio. La forma fácil de identificar el tipo de respuesta es con la información devuelta en el campo \textit{obj} del mensaje. 

Se trata de un valor booleano, si obtenemos un \false{} corresponde al caso de que no estabamos cooperando en una \ac{CWSN} cuando nos registramos en el servicio. Es probable que nos hayan llegado entre tanto otros mensajes del tipo \Scst{SERVICE\_INFORMATION} debido a procesos internos del servicio relacionados con la configuración y la entrada en la red. El detalle de éste se puede ver en la tabla~\ref{tab:endHandshakingNotCWSNMessage}

\messageTableInit{\servToApps}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{False}}{\nc{}}
\messageTableExtra{nodeRole}{Papel del nodo}
\messageTableExtraAddrow{nodeType}{Tipo de nodo}
\messageTableExtraAddrow{periodTask}{Periodo tarea cognitiva}
\messageTableExtraAddrow{nodeName}{Nombre del nodo en la red}
\messageTableExtraAddrow{errorSetupInterface}{Resultado configuración interfaz}
\messageTableEnd{Mensaje finalización de \textit{handshaking}: CWSN no establecida}{endHandshakingNotCWSNMessage}

La información de cada campo:
\begin{description}
\label{itm:serviceParamsToAll}
	\item[Arg1: Estado de la interfaz] Un entero cuyos valores corresponden a:
	\begin{enumerate}
	 \setcounter{enumi}{-1}
		\item \Scst{INTERFACE\_STATE\_DOWN}, la interfaz de comunicación no está configurada.
		\item \Scst{INTERFACE\_STATE\_IDLE}, la interfaz está configurada pero no estamos cooperando en red.
		\item \Scst{INTERFACE\_STATE\_IDLE\_NETWORKING}, situación de reposo cooperando en \ac{CWSN}.
		\item \Scst{INTERFACE\_STATE\_CONNECTING}, nos estamos conectando a otro nodo (sólo en \bt{}).
		\item \Scst{INTERFACE\_STATE\_SENDING}, estamos enviado datos a través de la interfaz.
		\item \Scst{INTERFACE\_STATE\_RECEIVING}, estamos reciviendo datos.
	\end{enumerate}
	\item[Arg2: Interfaz] Un entero cuyos valores corresponden a:
	\begin{enumerate}
		\setcounter{enumi}{-1}
		\item \bt{}.
		\item \wifi{}.
		\item \textcolor{notImplemented}{\textit{Mobile}, no implementado.}
		\setcounter{enumi}{-2}
		\item Desconocido, devuelto en el transcurso de cambio de contexto o \textit{handover}.
	\end{enumerate}
	\item[Obj: \false{}] Un valor booleano cuyo valor nos indica que no estabamos cooperando con otros nodos tras la recepción del mensaje \Scst{REGISTER\_EXCHANGE} por lo tanto el servicio ha configurado de nuevo la interfaz para disparar los procesos de entrada en la red (ver sección~\ref{subsec:configInterface}).
	\item [EXTRAS] Campos \textit{extra} con el resto de parametros cuando el valor \textit{obj} es \false{}:
	\begin{description}
		\item[Papel del nodo] Un \integer{} que representa el papel del nodo en la red, se recupera con la clave ``nodeRole'':
		\begin{enumerate}
			\setcounter{enumi}{-1}
			\item Secundario.
			\item Primario.
		\end{enumerate}
		\item[Tipo de nodo] Un \integer{} que representa el tipo de nodo, se recupera con la clave ``nodeType'':
		\begin{enumerate}
			\setcounter{enumi}{-1}
			\item Normal.
			\item Coordinador.
			\item \textcolor{notImplemented}{Coordinador temporal en \bt{}, no implementado. En todo caso este valor no es selecionable nunca por el usuario/servicio.}
			\setcounter{enumi}{-2}
			\item Desconocido, valor por defecto (si obtenemos este valor nos encontramos en situación de error).
		\end{enumerate}
		\item[Periodo tarea cognitiva] Un \double{} con el que se nos informa cada cuánto el servicio realiza la tarea cognitiva (sensado, toma de decisiones...). Se recupera con la clave ``periodTask''.
		\item[Nombre del nodo en la red] Una \String{} con la que el servicio nos informa de cómo nos conocen los otros nodos en la red. Se recupera con la clave ``nodeName''.
		\item[Resultado configuración interfaz] Un valor booleano cuya clave para obtenerlo es ``errorSetupInterface'' cuyo valor significa:
		\begin{itemize}
			\item \true{} se ha producido un error mientras la configuración de la interfaz.
			\item \false{} todo ha ido OK en el proceso de configuración.
		\end{itemize}
	\end{description}
\end{description}

Si por el contrario el valor obtenido en el campo \textit{obj} es \true{} significa que el servicio ya se encontraba cooperando en una \ac{CWSN} cuando registramos nuestra aplicación por lo que no es necesario ninguna configuración y recibimos una respuesta casi inmediata (a diferencia del caso anterior) con la siguente disposición (ver tabla~\ref{tab:endHandshakingInCWSNMessage}).

\messageTableInit{\servToApp}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{True}}{\nc{}}
\messageTableExtra{nodeRole}{Papel del nodo}
\messageTableExtraAddrow{nodeType}{Tipo de nodo}
\messageTableExtraAddrow{periodTask}{Periodo tarea cognitiva}
\messageTableExtraAddrow{nodeName}{Nombre del nodo en la red}
\messageTableExtraAddrow{appCode}{Código de la aplicación}
\messageTableExtraAddrow{nodeIdList}{Array de \integers{} con los identificadores de los nodos}
\messageTableExtraAddrow{nodeNameList}{Array de \String{} con los nombres de los nodos}
\messageTableEnd{Mensaje finalización de \textit{handshaking}: CWSN establecida}{endHandshakingInCWSNMessage}

La información recibida es prácticamente igual salvo el campo \textit{obj} que nos devuelve el valor \true{} lo que provoca que este mensaje sólo lo reciba esta aplicación en exlcusiva y un cambio en los extras, que dejan de inlcuir el \bsq{Resultado configuración interfaz} pero incluyen dos nuevos:

\begin{description}
	\item[Código de la aplicación] Un \String{} que representa el código de la aplicación. El servicio nos hace un \bsq{eco} de este valor para saber que se ha configurado bien. Se recupera con la clave ``appCode''.
	\ListaNodosItem{}
\end{description}
%------------
\subsection{Enviar datos}
El envío de datos a través de la red cognitiva consiste en la entrega al servicio de un mensaje codificado con esta información:

\begin{description}
	\item[Payload] El contenido del mensaje lo adjuntamos en el campo \textit{obj} del mensaje, debe ser o poder codificarse como una \String{}.
	\item[Lista nodos] Los nodos a quién va dirigido el mensaje se codifican como una lista de identificadores, instancia de un \textit{ArrayList<Integer>} y debe ir como un extra guardado con la clave ``addressedNodes''. El identificador del nodo nos los devuelve el propio servicio en mensajes tipo \Scst{REGISTER\_EXCHANGE} en situación de \textit{networking} y en mensajes tipo \Scst{SERVICE\_INFORMATION}. Como convención, el identificador es un número natural. El valor \bsq 0 puede ser utilizado por el programador de aplicaciones como ausencia de nodos (útil para rellenar \textit{listviews} o \textit{spinners}), el \bsq1 es un valor reservado por el servicio que sirve para enviar el mensaje a todos los nodos. Los demás números corresponden cada uno a un nodo distinto. 

Aunque no hay restricciones la manera correcta de enviar el mensaje a todos es rellenar la lista sólo con el identificador \bsq{1}.
\end{description}

El detalle del mensaje enviado al servicio es (ver tabla~\ref{tab:outgoingContent}).

\messageTableInit{\appToServ}{4 =\\ \scriptsize{OUTGOING\_CONTENT}}{\nc{}}{\nc{}}{\textit{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{}s con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje para el envío de datos}{outgoingContent}
%-------------
\subsection{Confirmación envío de datos}
\label{subsec:apiAck}
Cuando hemos enviado datos a través del servicio, la forma que tiene éste de informarnos que el proceso de envío ha terminado es con la entrega del siguiente mensaje, del que podremos obtener las estadísticas de envío (ver tabla~\ref{tab:outgoingContentResultApp}).

\messageTableInit{\servToApp}{6 =\\ \scriptsize{OUTGOING\_CONTENT \_RESULT}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{payload}}{\nc{}}
\messageTableExtra{IdsNotDelivered}{Un array de \integer{}s con los identificadores de los nodos a los cuales no les ha llegado el mensaje}
\messageTableExtraAddrow{NamesNotDelivered}{Un array de \String{} con los nombres de los nodos a los cuales no les ha llegado el mensaje}
\messageTableEnd{Mensaje resultado envío de datos presentado a la aplicación}{outgoingContentResultApp}

La información que podemos leer de este mensaje es:
\begin{description}
	\item[Arg1: número mensajes escritos OK] Un \integer{} que nos indica en cuántos nodos se ha entregado el mensaje correctamente.
	\item[Arg2: número mensajes escritos NOK] Un \integer{} con el número de nodos los cuales no han recibido el mensaje.
	\item[Obj: payload] El contenido que se ha enviado por la red, esto sirve a la aplicación para relacionar el envío con la contestación. 
	\item[EXTRAS] Si el campo \textit{arg2} es distinto de cero incluimos los siguientes extras:
	\begin{description}
	\ListaNodosNoDeliveredItem{}

	La motivación de enviar tanto el identificador como el nombre es porque si hay algún fallo en la entrega del mensaje antes de la confirmación de entrega, habremos recibido un mensaje indicándonos la pérdida de algún nodo. La aplicación entonces puede haber borrado de su lista el nodo implicado que al intentar recuperar ahora (en la recepción de la confirmación) el nombre le dará error al no encontrarse ya en su lista.
	\end{description}
\end{description}

El tiempo de entrega de esta confirmación no está acotado, depende de la complejidad en el envío y de si ha habido encolamiento en cualquiera de los segmentos de red por los que ha pasado el mensaje.


%----------
\subsection{Recibiendo datos}
En cuanto el servicio haya recibido datos que le interesen a nuestra aplicación (es decir el código de aplcación sea el mismo con el que va marcado el mensaje de datos) nos enviará un mensaje con el contenido (en el campo \textit{obj} del mensaje) y el identificador del nodo que lo envió, un extra que se recupera con la clave ``device\_id'' (ver tabla~\ref{tab:incomingContent}).

\messageTableInit{\servToApp}{8 =\\ \scriptsize{INCOMING\_CONTENT}}{\nc{}}{\nc{}}{\textit{payload}}{\nc{}}
\messageTableExtra{device\_id}{Un \integer{} que identifica al nodo que ha enviado el mensaje}
\messageTableEnd{Mensaje datos recibidos}{incomingContent}

\subsection{Recibir información del servicio}
\label{subsec:serviceInformation}
El servicio utiliza esta vía como principal para informar acerca de la evolución de sus procesos internos. Gracias a su gestor de estados entre los controladores de las interfaces y éste, los eventos y estados se codifican y aglutinan para informar a todas las aplicaciones registradas acerca de éstos y cuándo se producen. 

Aunque parte de esta información (estado de la interfaz y lista de nodos) se distribuya también en otros mensajes, es aquí dónde se plasman todos los cambios de estado que haya a lo largo de un proceso completo. En otros mensajes enviados por el servicio la información aportada tan sólo corresponde al momento final del proceso.

\apiTableInit{Diferentes estados en los que se pueden encontrar las interfaces}
	\apiTableRow{INTERFACE\_STATE\_DOWN}{0}	
	\apiTableRow{INTERFACE\_STATE\_IDLE}{1}
	\apiTableRow{INTERFACE\_STATE\_IDLE\_NETWORKING}{2}
	\apiTableRow{INTERFACE\_STATE\_CONNECTING}{3}
	\apiTableRow{INTERFACE\_STATE\_SENDING}{4}
	\apiTableRow{INTERFACE\_STATE\_RECEIVING}{5}
\apiTableEnd{Estados de la interfaz de comunicación}{states}

Los eventos se producen entre los dos nodos invulcrados directamente en el proceso. Por ejemplo, la inclusión de un nuevo nodo produce un evento en los controladores de la interfaz de los dos nodos implicados, el resto de nodos se enteran del evento con mensajes de señalización (que veremos en la sección \ref{sec:procesosRed}) que para los controladores son tratados de la misma manera que otros mensajes de red. La mayoría de eventos surgen del propio controlador de la interfaz, otros sin embargo son fruto de la interpretación de mensajes de señalización como son los cambios de contexto.

\apiTableInit{Eventos producidos en la red}
	\apiTableRow{EVENT\_INTERFACE\_NO\_CHANGES}{0}	
	\apiTableRow{EVENT\_INTERFACE\_NEW\_NODE}{1}
	\apiTableRow{EVENT\_INTERFACE\_LOST\_NODE}{2}
	\apiTableRow{EVENT\_INTERFACE\_CANNOT\_CONNECT}{3}
	\apiTableRow{EVENT\_INTERFACE\_ALREADY\_CONNECTED}{4}
	\apiTableRow{EVENT\_INTERFACE\_SWITCH\_TO\_BT}{5}
	\apiTableRow{EVENT\_INTERFACE\_SWITCH\_TO\_WIFI}{6}
	\apiTableRowNotImplemented{EVENT\_INTERFACE\_SWITCH\_TO\_MOBILE}{7}
	\apiTableRow{EVENT\_INTERFACE\_END\_SWITCHING}{8}
	\apiTableRow{EVENT\_UPDATE\_LIST\_NODES}{9}
\apiTableEnd{Eventos que se pueden producir en la red}{events}


  Estos mensajes son puramente informativos, no requieren de ningún procesamiento por parte de las aplicaciones y se presentan con esta estructura (ver tabla~\ref{tab:serviceInformation}).

\messageTableInit{\servToApps}{9 = \scriptsize{SERVICE\\\_INFORMATION}}{interfaz}{\nc{}}{modificación lista nodos}{\nc{}}
\messageTableExtra{coordinator}{Una \String{} con el nombre del nodo que es nuestro coordinador. Si somos el cooridnador este campo viene informado a \textit{null}}
\messageTableExtraAddrow{triggerNodeName}{Una \String{} con el nombre del nodo que ha disparado el evento. Si no existe tal nodo no se incluye este campo en el mensaje}
\messageTableExtraAddrow{state}{Una \integer{} con el estado de la interfaz}
\messageTableExtraAddrow{event}{Una \integer{} con el evento producido en la red}
\messageTableExtraAddrow{nodeIdList}{Un array de \integers{} con los identificadores de los nodos que forman la red en estos momentos}
\messageTableExtraAddrow{nodeNameList}{Un array de \String{} con los nombres de los nodos que forman la población actual}
\messageTableEnd{Mensaje información evento/estado por parte del servicio}{serviceInformation}

El detalle de cada uno de los campos es:
\begin{description}
\label{itm:serviceInformation}
	\item[Arg1: Interfaz] Un \integer{} cuyos valores corresponden a:
	\begin{enumerate}
		\setcounter{enumi}{-1}
		\item \bt{}.
		\item \wifi{}.
		\item \textcolor{notImplemented}{\textit{Mobile}, no implementado.}
		\setcounter{enumi}{-2}
		\item Desconocido, devuelto en el transcurso de cambio de contexto o \textit{handover}.
	\end{enumerate}
	\item[Obj: modificación lista nodos] Un valor booleano que nos indica si ha habido un cambio en la lista de nodos.
	\item [EXTRAS] Campos \textit{extra} con el resto de parámetros:
	\begin{description}
		\item[Coordinador] Una \String{} con el nombre del nodo coordinador. Informado a \textit{null} si somos nosotros el coordinador de la red.		
		\item[Nodo causante del evento] Una \String{} con el nombre del nodo que ha causado el evento. Esta información es más útil para el nodo coordinador, pues para el normal el nodo causante siempre será su coordinador.
		\item[Estado interfaz] Un \integer{} cuyos valores son los vistos en la tabla~\ref{tab:states}, se obtiene con la clave ``state'':
		\begin{enumerate}
	 		\setcounter{enumi}{-1}
				\item \Scst{INTERFACE\_STATE\_DOWN}, la interfaz de comunicación no está configurada.
				\item \Scst{INTERFACE\_STATE\_IDLE}, la interfaz está configurada pero no estamos cooperando en red.
				\item \Scst{INTERFACE\_STATE\_IDLE\_NETWORKING}, situación de reposo cooperando en \ac{CWSN}.
				\item \Scst{INTERFACE\_STATE\_CONNECTING}, nos estamos conectando a otro nodo (sólo en \bt{}).
				\item \Scst{INTERFACE\_STATE\_SENDING}, estamos enviado datos a través de la interfaz.
				\item \Scst{INTERFACE\_STATE\_RECEIVING}, estamos reciviendo datos.
		\end{enumerate}
		\item[Evento producido] Un \integer{} cuyos valores son los vistos en la tabla~\ref{tab:events}, se recupera con la clave ``event'':
		\begin{enumerate}
				\setcounter{enumi}{-1}
				\item \Scst{EVENT\_INTERFACE\_NO\_CHANGES}, este evento es la ausencia de evento. Hay cambios en el estado de la interfaz que no son provocados por un evento, para estas casuisticas el evento que le asignamos es el de \bsq{no cambio}.	
				\item \Scst{EVENT\_INTERFACE\_NEW\_NODE}, este evento surge cuando el coordinador nos conecta a la red. Se genera en ambos extremos (en el coordinador y el nodo normal que empieza a formar parte de la red).
				\item \Scst{EVENT\_INTERFACE\_LOST\_NODE}, se genera al perder la comunicación con un nodo (entre coordinador y normal, aparece este evento al igual que el anterior en ambos extremos).
				\item \Scst{EVENT\_INTERFACE\_CANNOT\_CONNECT}, surge en el nodo que ha intentado conectarse a otro y no ha podido.
				\item \Scst{EVENT\_INTERFACE\_ALREADY\_CONNECTED}, surge cuando el coordinador intenta conectarse a un nodo al cual ya está conectado (sólo en \bt{}). 
				\item \Scst{EVENT\_INTERFACE\_SWITCH\_TO\_BT}, evento que surge cuando recibimos o disparamos (coordinador) el cambio de contexto hacia \bt{}.
				\item \Scst{EVENT\_INTERFACE\_SWITCH\_TO\_WIFI}, evento que surge cuando recibimos o disparamos (coordinador) el cambio de contexto hacia \wifi{}.
				\item \textcolor{notImplemented}{\Scst{EVENT\_INTERFACE\_SWITCH\_TO\_MOBILE}, no implementado, de manera análoga cuando la interfaz de destino es la móvil.}
				\item \Scst{EVENT\_INTERFACE\_END\_SWITCHING}, se genera al terminar el cambio de contexto.
				\item \Scst{EVENT\_UPDATE\_LIST\_NODES}, cuando es necesaria una actualización de la lista de nodos que no haya sido provocada por algún evento anterior.
			\end{enumerate}
			\ListaNodosItem{}
	\end{description}
\end{description}

%---------
\subsection{No cumplimiento de la API: mensajes de error}
El servicio tiene una manera de avisar a las aplicaciones cuando éstas no cumplen con la \ac{API} o internamente surge un error cuyo resultado es conveniente comunicar para poner en conocimiento que el proceso actual se ha detenido. Este aviso se realiza mediante el envío de mensajes de error que están dirigidos a quién lo ha provocado, o puesto en conocimiento de todos según interese.

Es una sección experimental que sólo recoge los errores más importantes. No se ha hecho un estudio exhaustivo sobre el comportamiento maligno de las aplicaciones para intentar manejar y sanitizar todos los valores entregados por éstas. Algunos de los errores de los que son manejados por el servicio se listan en la tabla~\ref{tab:errors}

\apiTableInit{Mensajes de error devueltos por el servicio}
	\apiTableRow{CODE\_ERROR\_ILLEGAL\_ARGUMENT}{1}	
	\apiTableRow{CODE\_ERROR\_NODE\_NO\_EXISTS}{2}
	\apiTableRow{CODE\_ERROR\_INTERNAL}{3}
	\apiTableRow{CODE\_ERROR\_NOT\_IN\_NETWORK}{4}
	\apiTableRow{CODE\_ERROR\_MESSAGE\_NOT\_RECOGNIZED}{5}
	\apiTableRow{CODE\_ERROR\_ILLEGAL\_PAYLOAD}{6}
\apiTableEnd{Mensajes de error por el no cumplimiento de la API}{errors}

Los errores son transmitidos a la aplicación o las apliaciones por medio de este tipo de mensaje (ver tabla~\ref{tab:errorMessage}), en él se amplia la descripción del error mediante una \String{} en el campo \textit{obj}.

\messageTableInit{\servToApp}{10 =\\ \scriptsize{ERROR\_MESSAGE}}{código de error}{\nc{}}{Descripción del error}{\nc{}}
\messageTableEnd{Mensaje de error recibido del servicio}{errorMessage}

%---------
\subsection{Mensajes encolados}
Puede darse la circustancia de que al realizar el envío de datos al servicio, éste no pueda enviarlo por la red debido a que se encuentre en un cambio de contexto. En estas ocasiones los mensajes recibidos por parte de las aplicaciones son encolados siguiendo el modelo \ac{FIFO}, esto quiere decir que se respeta el orden de llegada y serán entregados en el mismo orden cuando se proceda su salida. 

Cuando el servicio retoma el envío de estos mensajes encolados, envíamos a la aplicación dueña del mensaje un informe previo a su envío, indicando cuáles de los nodos destinatarios siguen en la red y cuáles no. En el caso de haber enviado el mensaje a todos, este informe nos devuelve la lista completa de nodos a los cuales le hemos intentado enviar el mensaje, ya que puede haber cambios en la población entre el momento en el cual se envío y el momento en el que el servicio le da salida. El detalle del mensaje recibido en la aplicación es (ver tabla~\ref{tab:queuedMessage}).

\messageTableInit{\servToApp}{11= \scriptsize{QUEUED\_MESSAGE}}{número enviados}{número no enviados}{\textit{payload}}{\nc{}}
\messageTableExtra{IdsTriedToSend}{Un \textit{array} de \integers{} con los identificadores de los nodos los cuales siguen en red}
\messageTableExtraAddrow{NamesTriedToSend}{Un \textit{array} de \String{} con los nombres de los nodos siguen en red}
\messageTableExtraAddrow{IdsNotDelivered}{Un \textit{array} de \integers{} con los identificadores de los nodos que no hemos enviado el mensaje por no encontrarse en la red}
\messageTableExtraAddrow{NamesNotDelivered}{Un \textit{array} de \String{} con los nombres de los nodos que no hemos enviado el mensaje por no encontrarse en la red}
\messageTableEnd{Mensaje informe previo a la salida de mensaje encolado}{queuedMessage}

Los campos \textit{extra} son dos pares de \textit{arrays} ligados por la posición al igual que ocurre con la lista de nodos de otros mensajes. Los dos primeros nos informan de cúales son los nodos a los cuales se va a proceder al envío del mensaje y los dos últimos están rellenos de los nodos que al no encontrarse en este momento en situación de red hemos obviado su envío para evitar envíos fallidos innecesarios.

Al recibir este mensaje quedamos a la recepción del mensaje de confirmación de envío explicado en~\ref{subsec:apiAck}
%---------
\subsection{Actualización de parámetros}
\label{subsec:apiUpdateParams}
Si en algún momento queremos cambiar nuestro papel en la red o recibir la información de otras aplicaciones de la red cognitiva tan sólo necesitamos cumplir cierta parte del flujo del \textit{handshaking} para conectarse al servicio (ver~\ref{subsec:apiStart}). Empezaremos enviando directamente el segundo mensaje, con nuestos nuevos parámetros al servicio con el mensaje ya visto en la tabla~\ref{tab:registerExchangeMessage}, tras esto esperaremos la respuesta dónde veremos si realmente se han podido actualizar los valores que les entregamos. Si cuando decidimos actualizar estabamos en situación de \textit{networking} es posible que los valores no hayan podido actualizarse debido a que penalizan o entran en conflicto con las necesidades de las otras aplicaciones ya registradas. En este caso sólo se permite un cambio de papel \bsq{secundario} a \bsq{primario}, pero no al revés. El \bsq{código de aplicación} se actualiza siempre no importando la situación.
%----------
\subsection{Desconectarse del servicio}
Llegado el momento de desconectarnos de la red deberemos enviar al servicio un mensaje del tipo \textit{unregister client} para que el servicio sea informado de forma directa, ya que la mera petición de \textit{unbind} no garantiza que éste se entere y si se entera, es para su propia destrucción por parte de \android{}. La composición de este mensaje es lo podemos ver en la tabla~\ref{tab:unregisterClientMenssage}

\messageTableInit{\appToServ}{2 =\\ \footnotesize{UNREGISTER \_CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje desregistro cliente}{unregisterClientMenssage}

Tras este envío ya podemos deshacer el enlace entre aplicación y servicio de manera segura.
%---------
\subsection{Entrada de nodos en la red cuando la interfaz es \bt{}}
\label{subsec:connectViaBT}
Por motivos de implementación, si queremos introducir un nuevo nodo en la red cuando la interfaz de comunicación es \bt{}, debe ser el coordinador quién de el primer paso. Para ello en el nodo coordinador enviamos el siguente mensaje (ver tabla~\ref{tab:connectToBT}).

\messageTableInit{\appToServ}{12 = \footnotesize{CONNECT\_TO\\\_VIA\_BT}}{\nc{}}{\nc{}}{dirección MAC / identificador nodo}{\messApp{}}
\messageTableEnd{Mensaje contectar a nodo en \bt{} }{connectToBT}

El campo \textit{obj} puede recibir dos tipos de argumentos:
\begin{itemize}
 \item Una \String{} con la dirección MAC de \bt{} del nodo.
 \item Un \integer{} con el identificador el nodo, si éste no está en la base de datos enviaremos un mensaje de error a la aplicación.
\end{itemize}

Acto seguido el servicio intentará si la interfaz de comunicación actual es \bt{} conectarse al citado nodo bien por medio de su dirección \ac{MAC} o porque hemos podido recuperar ésta de la base de datos. Si la interfaz no es \bt{} devolveremos un error del tipo \Scst{CODE\_ERROR\allowbreak\_ILLEGAL\_ARGUMENT}

\paragraph{Known issue} El \textit{HashMap} del controlador de \bt{} donde guardamos las hebras de conexión pierde su contenido tras añadir un valor, la primera vez que se inicia el servicio. Instrucciones para detectar el fallo:
\begin{enumerate}
	\setcounter{enumi}{-1}
	\item Vaciar la base de datos y matar el proceso. O instalar la aplicación.
	\item Sin cerrar la aplicación (no destruir el servicio) intentar conectarse desde un coordinador a ésta.
	\item Observar que cuando el nodo intenta responder al coordinador con su información o intenta enviar un escaneo se lanza un evento de pérdida por no poder recuperar del \textit{HashMap} la hebra de conexión utilizada.
\end{enumerate}

%---------
\subsection{La API oculta: workarounds, test\ldots}
%----------
\subsubsection{Actualización de parámetros avanzada}
Un nodo cognitivo tiene mas parámetros (como se puede ver en~\ref{subsec:updateSettings}) que los expuestos en la \ac{API}, un nodo cognitivo en nuestra aplicación, se define además por:
\begin{itemize}
	\item Nombre: con el que nos conocen los demas nodos.
	\item Tipo: si somos coordinador o normal.
	\item Periodo de la tarea cognitiva: el intervalo de tiempo que transcurre entre sensados del entorno y/o toma de decisiones.
\end{itemize}
Como vemos son parámetros que no son propios de la aplicación o aplicaciones que en ese momento estén registradas. Estos valores son devueltos cuando finaliza el \textit{handshaking} para que las aplicaciones conozcan al nodo cognitivo aunque para éstas debe ser transparente. 

Sin embargo para poder configurar el nodo para que pueda cooperar en cualquier \ac{CWSN} debemos habilitar una manera de modificar estos parámetros. Bien, la forma es enviar el mismo mensaje que cuando actualizamos nuestro papel o código de aplicación pero con unos campos adicionales. En concreto el campo clave para saber si se trata de una actualización normal o avanzada recae en el campo \textit{obj}. Vimos que en una actualización normal su valor es \textit{null} y en una avanzada este valor será \bsq{no nulo} como vemos en la estructura del mensaje (ver tabla~\ref{tab:updateAllParamsMessage}). Los pormenores de este flujo los veremos en la sección~\ref{sec:procesosRed}

\messageTableInit{\appToServ}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{0=secundario / 1=primario}{0=normal / 1=coordinador}{\textbf{True}}{\messApp{}}
\messageTableExtra{appCode}{Una \String{} con el código de aplicación}
\messageTableExtraAddrow{nodeName}{Una \String{} con el nuevo nombre del nodo en la red}
\messageTableExtraAddrow{periodTask}{Un \double{} con el nuevo periodo medido en segundos de la tarea cognitiva a ejecutar}
\messageTableEnd{Actualización de todos los parámetros del servicio}{updateAllParamsMessage}


\subsubsection{Mensaje de petición y respuesta}
Un flujo interesante en redes de sensores cognitivas es la de habilitar una vía para que el coordinador pida de forma activa información a otro nodo. Aunque en nuestra arquitectura este flujo está implementado la primera vez que incluimos un nodo nuevo en \bt{} para preguntarle acerca de su nombre y su papel. Hemos preferido dejar montado, lo que en principio se montó con finalidad de \textit{test}.

La aplicación desarrollada junto al servicio incluye una interfaz de test que, entre sus funciones provee este flujo. El proceso tiene dos actores: por un lado los nodos normales que pueden guardar una respuesta (la información que posteriormente nos pedirá el coordinador) para ello enviamos un mensaje al servicio con la respuesta a enviar en el campo \textit{obj} del mensaje (ver tabla~\ref{tab:wa_reply}).

\messageTableInit{\appToServ}{20 = \footnotesize{WORKAROUND\\ \_WHAT\_TO\_REPLY}}{\nc{}}{\nc{}}{\textit{reply}}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} salvado de respuesta}{wa_reply}

El otro agente, el nodo coordinador, enviando este mensaje al servicio recupera la información del otro actor (ver tabla~\ref{tab:wa_ask}).

\messageTableInit{\appToServ}{21 = \footnotesize{WORKAROUND\\ \_ASK\_RESPONSE}}{\nc{}}{\nc{}}{Identificador nodo}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} petición de respuesta}{wa_ask}

Una vez enviada esta petición la respuesta nos vendrá encapsulada en un mensaje del mismo tipo (ver tabla~\ref{tab:wa_ask_response}). Esta respuesta se envía a todas las aplicaciones porque no viene marcada con el \bsq{código de aplicación}, se recomienda su uso sólo en test ya que puede desconcertar a otras aplicaciones que estén registradas en el servicio.

\messageTableInit{\servToApps}{21 = \footnotesize{WORKAROUND\\ \_ASK\_RESPONSE}}{\nc{}}{\nc{}}{Respuesta del nodo preguntado}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} respuesta obtenida}{wa_ask_response}


\subsubsection{Cambio de contexto forzado}
Otra función de \textit{test} es la de forzar un cambio de interfaz de comunicación en la red. Para ello si somos el coordinador podemos enviar este mensaje al servicio. No necesitamos comunicarle la interfaz destino debido a que, en estos momentos, sólo hay dos interfaces de comunicación.

\messageTableInit{\appToServ}{22=\footnotesize{WORKAROUND\_\\ CONTEXT\_CHANGE}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} cambio de interfaz de comunicación}{wa_switch}

\subsubsection{Encolar mensajes y forzar su entrega en cualquier momento}
Para probar el encolamiento de mensajes y su entrega en momentos que no corresponden pueden enviarse estos mensajes al servcio que alterará el flujo normal para producir el resultado buscado.

Para encolar un mensaje de datos entregaremos al servicio un mensaje con esta estructura (ver tabla~\ref{tab:wa_queue}).

\messageTableInit{\appToServ}{23=\scriptsize{WORKAROUND\_ PENDINGMESSAGE \_INJECTION}}{\nc{}}{\nc{}}{\textit{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{}s con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje \textit{workaround} encolamiento de mensaje de datos}{wa_queue}

Y para vaciar la cola de mensajes en cualquier momento deberemos enviar este otro (ver tabla~\ref{tab:wa_disposalqueue}).

\messageTableInit{\appToServ}{24=\scriptsize{WORKAROUND\_ PENDINGMESSAGE \_DISPOSAL}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} vaciado cola de mensajes}{wa_disposalqueue}


%-------------------------------------------------------------------
\section{Procesos de red}
%-------------------------------------------------------------------
\label{sec:procesosRed}
Cuando ocurren eventos en la red estos son manejados por los distintos nodos según sea su tipo, propagando la información necesaria para que toda la red pueda reconstruir la misma perspectiva sobre la actual situación. Veremos quién dispara y el por qué de estos eventos, cómo se informa y en qué casos a las aplicaciones montadas sobre el servicio del nodo cognitivo. Esta sección viene muy relacionada con la sección \ref{sec:api} ya que dónde empieza o finaliza la acción es con mensajes intercambiados de la \ac{API}. 

\comp{Relatar los diferentes procesos que ocurren en el servicio, quién los dispara y como se transmiten al resto de nodos y las apps que estén montadas}
%------------------------------
\subsection{Registro de una aplicación en el servicio cognitivo}
\label{subsec:serviceRegisterProcess}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service (manejador de mensajes entre servicio y aplicaciones)
\end{files}
\end{codeInvolved}
Para que una aplicación pueda registrarse de forma correcta en el servicio debe cumplir un cierto \textit{handshaking} consistente en el intercambio de tres mensajes, el primero servirá para que el servicio incluya a la aplicación en su base de clientes. El segundo para que la aplicación le informe de sus parámetros y el tercero será una confirmación por parte del servicio hacia la aplicación o aplicaciones informando de todos los parámetros de éste tras la inclusión de la nueva aplicación.

Como hemos visto ya en la \ac{API} (ver sección \ref{sec:api}), tras la petición de \textit{bind}, que inicializará el servicio si no estuviese arracando ya, obtendremos el \textit{Messenger} del servicio, indispensable para poder comunicarnos con él. A continuación debemos mandar un primer mensaje para registrar nuestra aplicación en el servicio, donde éste, registrará nuestro messenger para habilitar la comunicación en sentido contrario y nos incluirá en su lista de aplicaciones registradas. Los detalles de este mensaje pueden verse en la tabla~\ref{tab:registerClientMessage}

El siguiente mensaje (ver tabla~\ref{tab:registerExchangeMessage}) que debemos enviar, informaremos acerca de nuestros parámetros de aplicación como son: nuestro papel, un entero cuyo valor \bsq 0 corresponde a papel secundario y el valor \bsq 1 corresponde al papel primario y nuestro código de aplicación, útil para que el servicio nos entregue sólo los mensajes que nos atañen.

Este mensaje ha sido separado del anterior para poder reutilizarlo e introducirlo en el flujo descrito en~\ref{subsec:apiUpdateParams} o~\ref{subsec:updateSettings}. Con esta información el servicio dependiendo del punto en que se encuentre actuará de una forma u otra.

\subsubsection{Punto de partida inicial, CWSN no establecida}
\umlsdInit
	\newthread[gray]{srv}{Servicio} \newinst[2]{app}{Aplicación}
	\callSelf{app}{Aplicación.init()}	
	\begin{call}{app}{bind()}{srv}{messenger}
		\callSelf{srv}{Servicio.init()}
	\end{call}
	\mess{app}{Register client}{srv}
	\mess{app}{Register exchange}{srv}
	\callSelf{srv}{Configuración interfaz}
	\mess{srv}{Register exchange}{app}
\umlsdEnd{Handshake CWSN no configurada y servicio no inicilizado}{endHandshakingNotInCWSN}

Esta situación, (la más común) es cuando nuestra petición de \textit{bind} ha arrancado el servicio y por lo tanto estamos en una situación inicial o ya hay aplicaciones montadas sobre éste pero no hay conectividad con otros nodos, en otras palabras, estamos solos en la red. Un ejemplo cuando el servicio no está arrancado podemos verlo en la figura~\ref{fig:endHandshakingNotInCWSN}

En esta situación, configuraremos de nuevo la interfaz, actualizaremos los parámetros pasados en el anterior mensaje y lanzaremos nuevamente los procesos de registro en la red para intentar establecer una \ac{CWSN}. Al finalizar éstos, el servicio devolverá (a todas las aplicaciones montadas) la información acerca de todos los parámetros y el estado actual de la red (ver listas de la sección~\ref{subsec:apiStart}). Puede verse el detalle de este mensaje en la tabla~\ref{tab:endHandshakingNotCWSNMessage}

\subsubsection{Punto de partida, CWSN previamente configurada}
\umlsdInit[h!]
	\newthread[gray]{srv}{Servicio} \newinst[2]{app}{Aplicación}
	\callSelf{app}{Aplicación.init()}		
	\begin{call}{app}{bind()}{srv}{messenger}
	\end{call}
	\mess{app}{Register client}{srv}
	\mess{app}{Register exchange}{srv}
	\mess{srv}{Register exchange}{app}
\umlsdEnd{Handshake CWSN configurada}{endHandshakingInCWSN}

Puede darse el caso que, en este punto del proceso, ya haya aplicaciones montadas sobre el servicio y estén cooperando en una \ac{CWSN}. En este caso el servicio no tiene que configurar nada y se limita a ver si puede satisfacer las necesidades que le acaba de transmitir la nueva aplicación que acaba de registrar, es decir, cambiará el papel del nodo a primario si este era secundario, un cambio en sentido contrario será ignorado. Una vez hecho esto devolverá en exclusiva a la aplicación solicitante los parámetros del servicio (ver tabla~\ref{tab:serviceSettings}) y el estado de la interfaz. La estructura del mensaje devuelto puede apreciarse en la tabla~\ref{tab:endHandshakingInCWSNMessage}

%------------------------------
\subsection{Configuración de la interfaz de comunicación}
\label{subsec:configInterface}
%%diseño+implementacion
\comp{D+I: 
Tras recibir el \textit{handshaking} de registro de la aplicación, el servicio si no se encuentra colaborando en una \ac{CWSN}, procede a la configuración de una interfaz de comunicación, esta configuración se realiza en una \textit{AsyncTask} de \android{} que permite descargar la \textit{UI-Thread} evitando errores del tipo \textit{ANR ``Application Not Responding''} ya que parte de la tarea se ejecuta en segundo plano, además este tipo de tarea habilita mecanismos de paso de información entre ambas hebras. Antes de configurar una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos (llamando a su método \textit{stop}) para  poder partir de una situación deseable.
}
%%---
Tras recibir el \textit{handshaking} de registro de la aplicación, el servicio si no se encuentra colaborando en una \ac{CWSN}, procede a la configuración de una interfaz de comunicación que se realiza en segundo plano. Antes de empezar la configuración una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos (llamando a su método \textit{stop}) para partir de una situación con mínimos recursos utilizados.

 
\subsubsection{WiFi: servicio y controlador}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: SetupWifiInterface (AsyncTask)\\
\textbf{WifiController}: stop(), start() / StatusReceiver\_wifi (BroadcastReceiver)
\end{files}
\end{codeInvolved}
%%diseño+implementacion
\comp{I+D: 
La interfaz \wifi{} permite configurarse en varias modalidades como: Infraestructura, Tethering o Ad-hoc. En la actualidad sólo está implementado el modo infraestructura por los problemas descritos en \ref{sec:analisisWifi}. Una vez lanzada la tarea en segundo plano, lo primero que hacemos es intentar parar las hebras asociadas a la interfaz \wifi{} que cerrarán los \textit{serverSockets} y el \textit{broadcastReceiver} útil para registrarse a eventos de información relativa a la interfaz \wifi{} como son \ac{RSSI} y los eventos de conexión/desconexión a un punto de acceso. Partiendo de una situación en que todos los recursos están liberados, encendemos la interfaz si no lo estuviese ya, esperamos a que se encienda mediante una espera de consulta a una variable que es modificada por  \textit{StatusReceiver\_wifi.java}, nuestro \textit{broadcastReceiver} para la interfaz \wifi{}. Si nos han pasado como parámetro el SSID, intentamos conectarnos a él desconectándonos del punto de acceso acutual si no fuese el mismo. Esperamos mediante \textit{polling} con límite de tiempo seleccionable desde las preferencias en la sección de \textit{test}. Si agotamos el tiempo y no hemos sido capaces de conectarnos, devolvemos un valor \false{} que provoca el envío de mensaje a todas las aplicaciones del tipo {\small REGISTER\_EXCHANGE} con el campo EXTRA ``errorSetupInterface'' a \true{}. Si por el contrario nuestro \textit{broadcastReceiver} ha podido capturar la acción de conexión al citado punto de acceso o ya estamos conectados a éste continuamos arrancando las hebras del controlador dependiendo del tipo de nodo que seamos:

\paragraph{Normal} Arrancamos una hebra que escuche gracias a un \textit{serverSocket} para que acepte conexiones TCP, una vez estemos escuchando en el puerto indicado, enviamos el mensaje de tipo {\small REGISTER\_EXCHANGE} con el campo {\small EXTRA} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red (sección~\ref{subsec:enterInNetwork}).

\paragraph{Coordinador} Arrancamos un par de hebras, una para tráfico TCP que admita conexiones fiables y otra para el tráfico UDP que escuche y capture paquetes, si todo se ha configurado bien enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.
}
%---
La interfaz \wifi{} permite configurarse en varias modalidades como: Infraestructura, Tethering o Ad-hoc. En la actualidad sólo está implementado el modo infraestructura por los problemas descritos en \ref{sec:analisisWifi}. Una vez lanzada la tarea en segundo plano, intentamos liberar los recursos que vamos a solicitar si éstos estuvieran reservados por llamadas anteriores y no se hubiesen liberado aún.\\
La configuración comienza encendiendo la interfaz con la ayuda de la \ac{API} de \android{}, si no lo estuviese ya. Esperamos a que se encienda mediante una espera de consulta activa o \textit{polling}. Una vez levantada intentamos contectarnos a la red \wifi{} que nos hayan pasado como parámetro (mediante el \ac{SSID}), desconectándonos del punto de acceso actual si no fuese el mismo. Si no nos han pasado ningún parámetro dejamos al sistema \android{} que elija el \ac{AP} mas conveniente. Mientras se establece la conexión a un punto de acceso esperamos mediante \textit{polling} con límite de tiempo seleccionable desde las preferencias en la sección de \textit{test}. Si agotamos el tiempo y no hemos sido capaces de conectarnos, devolvemos un valor \false{} que provoca el envío de mensaje a todas las aplicaciones del tipo \Scst{REGISTER\_EXCHANGE} con el campo \Scst{EXTRA} ``errorSetupInterface'' a \true{}. Si por el contrario nuestro \textit{BroadcastReceiver} ha podido capturar la acción de conexión al citado punto de acceso o ya estamos conectados a éste continuamos estableciendo los canales de comunicación que dependen del tipo de nodo que seamos:

\paragraph{Normal} Necesitamos tener un canal de comunicación permanentemente a la espera para tráfico TCP recibido desde el coordinador. Una vez establecido terminamos la configuración enviando un mensaje de tipo \Scst{REGISTER\_EXCHANGE} con el campo \Scst{EXTRA} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red (sección~\ref{subsec:enterInNetwork}).

\paragraph{Coordinador} Necesitamos tener dos canales de comunicación, uno para tráfico proveniente de nodos ya en la red, este tráfico necesitamos que sea fiable por lo que será un canal \ac{TCP} y otro canal para recibir avisos de nuevos nodos que se quieran incorporar a la red, este tráfico por motivos de implementación no puede ser fiable por lo que tendremos que recurrir a tráfico \ac{UDP}. Al terminar de establecer los canales enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.


\subsubsection{Bluetooth: servicio y controlador}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: SetupBTinterface (AsyncTask)\\
\textbf{BluetoothController}: stop(), start(), connect(), setState() / StatusReceiver\_bt (BroadcastReceiver)
\end{files}
\end{codeInvolved}
%%diseño+implementacion
\comp{D+I:
Como en el controlador de \wifi{} empezamos (en segundo plano) liberando si no estuviesen ya cada uno de los recursos, en \bt{} coexisten, dependiendo del tipo de nodo, tres tipos de hebras: la que acepta conexiones (\textit{AcceptThread}), la que lanza la conexión (\textit{ConnectThread}) y la que mantiene la conexión entre el esclavo y el maestro (\textit{ConnectedThread}), de este tipo podemos tener más de una.
Encendemos la interfaz \bt{} si no estuviese encendida ya, mediante una petición al sistema \android{} y esperando mediante \textit{polling} a que \textit{StatusReceiver\_bt.java}, el \textit{broadcastReceiver} para la interfaz \bt{} modifique la variable de control de esta espera. Una vez finalizada, procedemos a configurar las hebras del controlador según el tipo de nodo.
\paragraph{Normal} Este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita arrancar una hebra para aceptar conexiones, como sólo esperamos un maestro cuando consigue una conexión (disparada sobre el mismo UUID por el que hemos registrado el socket) liberamos este recurso. Como ya hemos configurado la interfaz enviamos el mensaje final del \textit{handshaking} (ver tabla~\ref{tab:endHandshakingNotCWSNMessage}) con las instrucciones que hemos visto ya.

\paragraph{Coordinador} Este tipo de nodo se comporta como maestro en la comunicación \bt{}, no necesita aceptar conexiones, pero si disparar éstas. Para ello, recogemos de la base de datos los nodos inactivos y para cada uno de ellos lanzamos una conexión gracias al método connect() que se ejecuta en su propia hebra para asegurarnos que no se ejecuta en la hebra de la interfaz de usuario, en este caso no hace falta ya que la estamos llamando desde el segundo plano, pero como veremos este método se llama también directamente desde la UI-thread. Este método coge como parámetros la dirección \ac{MAC} con la cual queremos establecer una conexión y el número de intentos que vamos a intentar establecer esta conexión (a parte de otras constantes como el UIID), como en \bt{} es fácil que falle el establecimiento intentamos minimizar este riesgo reintentando la conexión. En el momento que conseguimos establecer la conexión, liberamos esta hebra que se volverá a crear con el siguiente intento de conexión a otro nodo y manejamos la conexión con una nueva hebra del tipo \textit{connectedThread}, al final tendremos tantas hebras como nodos activos en la red. La forma en la que sabemos cuando podemos pasar al siguiente nodo radica en 2 flags que son modificadas gracias al sistema de estados: setState(), que tienen los controladores. En esencia, cuando disparamos una conexión y ésta falla propagamos un estado de conexión fallida al servicio que aumentara el flag de conexiones fallidas (\textit{numFailConnection}), si la conexión se produce con éxito se propaga análogamente un estado de nuevo nodo en la red y modificaremos el flag de nuevo dispositivo (\textit{flagNewDevice}) saliendo de la espera en la que nos encontramos, por establecimiento de la conexión o por llegar al máximo de intentos.

 Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje del \textit{handshaking} con el formato visto en la tabla~\ref{tab:endHandshakingNotCWSNMessage}
}
%------

Como en la configuración del controlador de \wifi{} empezamos liberando si no estuviesen ya cada uno de los recursos. Encendemos la interfaz \bt{} si no estuviese encendida ya, mediante una petición al sistema \android{} y esperamos mediante \textit{polling} a que finalice. A continuación, procedemos a configurar las hebras del controlador según el tipo de nodo:

\paragraph{Normal} Por motivos de implementación este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita aceptar conexiones, como sólo esperamos un maestro cuando se consigue una conexión liberamos este recurso de aceptación de conexiones. Como ya hemos configurado la interfaz enviamos el mensaje final del \textit{handshaking} (ver tabla~\ref{tab:endHandshakingNotCWSNMessage}) con las instrucciones que hemos visto ya.

\paragraph{Coordinador} Por motivos de implementacion este tipo de nodo se debe comportar como maestro en la comunicación \bt{}, no necesita aceptar conexiones, pero si disparar éstas. Para ello, recogemos de la base de datos los nodos inactivos y para cada uno de ellos lanzamos una conexión gracias al método \textit{connect()}. Este método coge como parámetros la dirección \ac{MAC} con la cual queremos establecer una conexión y el número de intentos que vamos a intentar para establecer la conexión (a parte de otras constantes como el UIID).\\ 
Como en \bt{} es fácil que falle el establecimiento, intentamos minimizar este riesgo mediante el reitero de la conexión. En el momento que conseguimos establecer el canal de comnunicación trasladamos este canal al manejador de conexiones del controlador que tendrá tantos canales como nodos haya en la red. Estos canales son cifrados y fiables por diseño de \android{}.\\
Cada vez que se produce o se falla en el establecimiento del canal, el controlador comunica al servicio esta información que es utilizada para saber cuando hemos de establecer el canal de comunicación con el siguente nodo.

Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje del \textit{handshaking} con el formato visto en la tabla~\ref{tab:endHandshakingNotCWSNMessage}


%------------------------------
\subsection{Registro de un nodo en la red}
\label{subsec:enterInNetwork}

Según la interfaz en la que nos encontremos se alterna el papel de quién da el primer paso. Así en \bt{} el nodo normal espera una conexión entrante y en \wifi{} es el coordinador quién espera un paquete \ac{UDP} enviado desde un nodo normal.
\subsubsection{WiFi}
\begin{codeInvolved}
\begin{files}
\textbf{WifiController}: SendHelloPacket (AsyncTask), UDPlistener (Thread), stopSendingHelloPacket(), setState()\\
\textbf{Service}: mHandlerWf, sendInfoNewNodeOnNetwork()\\
\textbf{Database}: eventNewDeviceIPCoordinator(), newDeviceEventNormal(), modifyNode()
\end{files}
\end{codeInvolved}
%%diseño+implementación
\comp{D+I:
Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otro proceso que comienza a enviar paquetes cada 800 milisegundos hasta llegar a un máximo de 20. La razón de enviar una ráfaga de paquetes radica en que al ser trafico broadcast/multicast los puntos de acceso pueden menospreciarlo (incluso bloquearlo) y el mismo dispositivo \android{} puede que no esté escuchando siempre en este tipo de direcciones. De hecho cuando se apaga la pantalla, el driver de \wifi{} se reconfigura automáticamente para dejar de escuchar a la dirección de broadcast, por ello una ráfaga de 20 paquetes espaciados en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta el proceso de registro terminará enviando hacia el servicio el estado {\small (EVENT\_HELLO\_NOT\_REACHED)} que será interpretado por éste informando a todas las aplicaciones registradas del fallo del proceso indicando que no ha sido posible establecer una \ac{CWSN} {\small (EVENT\_INTERFACE\_CANNOT\_CONNECT)}.\\
}
%------

Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otro proceso que comienza a enviar una ráfaga de paquetes espaciados en el tiempo, la razón radica en que al ser trafico \textit{broadcast/multicast} tanto los puntos de acceso pueden menospreciarlo (incluso bloquearlo) como el mismo dispositivo \android{} puede que no esté escuchando siempre en este tipo de direcciones.\\
De hecho cuando se apaga la pantalla, el driver de \wifi{} se reconfigura automáticamente para dejar de escuchar a la dirección de \textit{broadcast}, por ello una ráfaga espaciada en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta el proceso de registro terminará enviando hacia el servicio el estado \Scst{EVENT\allowbreak\_HELLO\allowbreak\_NOT\allowbreak\_REACHED} que será interpretado por éste informando a todas las aplicaciones registradas del fallo del proceso indicando que no ha sido posible establecer una \ac{CWSN}, en este caso el evento facilitado a las aplicaciones se transforma en \Scst{EVENT\allowbreak\_INTERFACE\allowbreak\_CANNOT\allowbreak\_CONNECT} que concentra el mismo tipo de evento en distintos controladores, uniformando la respuesta.\\

Este tipo de paquetes lo denominamos \textit{``HelloPacket''} y su contenido es:

\protobufTableInit{Estructura mensaje registro en la red \wifi{}}
  \item[Tipo de paquete] Valor ``HELLO'' del enumerado ``packetType''
	\item[Hello packet] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo de paquete''
	\begin{description}
		\item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red
		\item[Papel del nodo] Una \String{} cuyo valor \bsq{p} es interpretado como primario y \bsq{s} como secundario (\bsq{u} para valor desconido)
		\item[Tipo de nodo] Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\textcolor{notImplemented}{\bsq{t} coordinador temporal en \bt{} [sin implementar]}, \bsq{u} para valor desconocido)
		\item[Dirección MAC] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca
	\end{description}
\protobufTableEnd{Campos del paquete ``HelloPacket''}{helloPacket}


Si por el contrario uno de los paquetes llega a destino y es manejado por el coordinador, éste interpretará el contenido dentro del mismo controlador. Esta ruptura del modelo de capas tiene como objetivo evitar propagar información al servicio de paquetes que no encajen con la estructura y campos requeridos desechando otros paquetes. El controlador entiende como manejar estos paquetes pero no el resto. Si capturamos un \textit{``HelloPacket''} generaremos un evento hacia el servicio de nuevo nodo en la red \Scst{EVENT\_ENTERED\_IN\_NETWORK} con la información leída del paquete. 

\figura{Vectorial/design/entradaRed-wf-coord}{width=.7\textwidth}{fig:entradaRed-wf-coord}{Flujograma de los procesos desencadenados en el coordinador al introducir un nodo en \wifi{}}

Este evento llega al \textit{handler} de \wifi{} en el servicio, dónde lo primero que hacemos es ver si el nodo ya está registrado en la red (este paso es necesario ya que tenemos varios envíos del mismo paquete por parte del mismo nodo), si ya está registrado ignoramos este evento, pues es una copia de otro anterior durante una guarda de tiempo. La motivación de esta guarda recae en que en \wifi{} no se detecta inmediatamente que un nodo se ha caído de la red, sólo nos podemos dar cuenta cuando intentamos enviarle algo y obtenemos un error. Puede darse la situación de que un nodo se registre, se caiga e intente registrarse de nuevo. Si en este lapsus nadie ha intentado ponerse en contacto con él, el resto de nodos seguirán creyendo que el nodo está en la red, si ignorasemos este evento el nodo que está intentado cerrar su registro en la red no tiene manera de saber que en realidad a ojos de los demás nodos él ya está registrado en la red, creyendo que su \textit{``HelloPacket''} no ha llegado a destino resultando una situación de falso fallo. Si no estaba activo en la red, lo marcamos como activo (insertándolo, si no estuviese ya, en la base de datos con la información facilitada por el controlador)
Acto seguido el coordinador informará a éste nodo del resto de nodos que ya hay en la red y al resto de nodos de la red se les informará del nuevo nodo. Por su parte el coordinador informará a las aplicaciones registradas que ha habido un nuevo nuevo nodo en la red y facilitará la lista de nodos.

La información de señalización que se envía y que representa\footnote{Notar que el campo ``Dirección IP'' puede no ser informado por no estar disponible en ese momento o ser inecesario} al nodo la podemos ver en la tabla~\ref{itm:infoNode}

\protobufTableInit{Estructura mensaje representación de un Nodo (serialización)}
	\item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red.
	\item[Papel del nodo] Una \String{} cuyo valor \bsq{p} es interpretado como usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconocido).
	\item[Tipo de nodo] Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador  (\textcolor{notImplemented}{\bsq{t} coordinador temporal en Bluetooth [sin implementar]}, \bsq{u} para valor desconocido).
	\item[Dirección MAC] Un \String{} cuyo valor es la dirección MAC en \bt{} del nodo, clave que identifica al nodo de manera unívoca.	
	\item[Dirección IP] Una \String{} cuyo valor representa la dirección IP (formato IP4) del nodo.
	\item[Dirección MAC del coordinador] Una \String{} que contiene la dirección MAC de \bt{} del coordinador del nodo que estamos enviando la información.
\protobufTableEnd{Representación de un nodo necesaria para recrear el mapa de red, contenido del mensaje de señalización}{infoNode}

Al recibir esta información el nodo normal, su controlador ya le habrá informado al servicio que está recibiendo datos, este evento le sirve al servicio para ver que ha sido registrado en la red y genera el mismo un evento de entrada en la red \Scst{EVENT\_ENTERED\_IN\_NETWORK} que sirve para homogeneizar el flujo y que sea idéntico al de \bt{}, este evento sirve para parar el envío de \textit{``HelloPacket''}. Al terminar de recibir el mensaje de señalización antes de procesarlo, tendremos que comprobrar que el nodo coordinador ya está incluido en la base de datos y si no incluir su dirección \ac{MAC} para obtener el identificador de nodo. El esquema de base de datos nos exige conocer a priori el identificador del nodo para poder traducir las direcciones \ac{MAC} de \bt{}. A medida que vamos procesando el mensaje vamos sustituyendo los valores anteriores (o de relleno si el nodo coordinador no estaba incluido en la base de datos) por los nuevos extraidos del mensajes de señalización. En este momento el nodo normal informará a las aplicaciones de que ha entrado en la red gracias a mensajes vistos en~\ref{subsec:serviceInformation} con el evento \Scst{EVENT\_INTERFACE\_NEW\_NODE} (visto en~\ref{tab:events}) y anunciará la lista de nodos quién es el coordinador. \comp{es oportuno decir que por motivos de eficiencia, solo hacemos una pasada por el mensaje} 

\subsubsection{Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{BluetoothController}: connected(), setState()\\
\textbf{Service}: mHandlerBt, sendInfoNewNodeOnNetwork()\\
\textbf{Database}: newDeviceEventNormal(), modifyNode(), updateInfoDeviceCoordinator()
\end{files}
\end{codeInvolved}

Como hemos explicado antes, es ahora el coordinador quien tiene que dar el primer paso, de hecho cuando se congifura la interfaz, está incluida una ronda de conexión a los nodos inactivos. Al producirse el canal de comunicaciones tanto el nodo coordinador como el nodo normal informan a sus respectivos servicios que se ha producido un evento de nodo nuevo \Scst{EVENT\_NEW\_DEVICE}.

\paragraph{Normal} Al recibir el evento conexión al coordinador vemos si éste está en la base de datos, si no lo estuviese, incluiríamos su dirección \ac{MAC} para obtener su identificador y pospondríamos el anuncio del nuevo nodo hacia las aplicaciones hasta que no obtengamos el mensaje de señalización dónde se nos informa de las características del resto de nodos en la red. Si por el contrario ya habíamos cooperado antes con este nodo, anunciaremos de inmediato hacia las aplicaciones el evento de conexión al nodo coordinador. Notar que los parámetros del nodo coordinador (nombre y papel) pueden ser valores que no se correspondan con la situación actual, no es una cosa que nos deba preocupar pues en primer lugar son parámetros cuyo cambio suele ser puntual y en segundo lugar será solventado momentos después al recibir la señalización con información sobre la población en la red.

\figura{Vectorial/design/entradaRed-bt-coord}{width=.6\textwidth}{fig:entradaRed-bt-coord}{Flujograma de los procesos desencadenados en el coordinador al introducir un nodo en \bt{}}

\paragraph{Coordinador} El flujo también comienza preguntándonos si habíamos cooperado ya con el nodo al que acabamos de conectarnos. Si no estuviese en la base de datos, le enviamos un mensaje de petición de información para que nos informe de su nombre y papel, ya que su dirección \ac{MAC} y su tipo (normal) lo sabemos porque o nos lo facilita el controlador o porque es deducible por el contexto. El nodo normal al recibir este mensaje envía sus datos, que nosotros procesamos como si fuese una actualización de parámetros en la red más, lo que conlleva modificar los datos del nodo que nos lo envía y la propagación de estos al resto de nodos. Además en este caso como el nodo no estaba en la red, se le envía información sobre la red cerrando el proceso de registro y se anuncia hacia las aplicaciones la entrada de un nuevo nodo, siguiendo la estructura de mensaje visto en la tabla~\ref{tab:serviceInformation}


%------------------------------
\subsection{Salida de un nodo de la red}
\label{subsec:salidaNodoRed}

\figura{Vectorial/design/salidaRed}{width=.6\textwidth}{fig:salidaRed}{Flujo salida red}

La dificultad en el proceso de salida de un nodo de la red viene marcada tanto por la interfaz como por el tipo de nodo que se trate. Es un proceso que tiene dos lados, el nodo que se desregistra en la red y los nodos que se quedan.
Un nodo se desregistra de la red cuando no quedan aplicaciones montadas sobre el servicio. Para que una aplicación se desregistre del servicio tiene que mandar una petición de \textit{unbind} precedida de un mensaje del tipo \textit{unregister client} (ver tabla~\ref{tab:unregisterClientMenssage}). Con el mensaje el servicio sabrá que tiene que borrar de su base de clientes a la aplicación y la petición liberará la conexión creada por \android{} entre ambos. 

El flujo que relaciona aplicación y servicio destruye a éste cuando todas las peticiones de \textit{bind} son correspondidas con sus \textit{unbind}, parecido pasa con las peticiones de \textit{start} y \textit{stop} (en este caso una única petición de \textit{stop()} destruiría el servicio). \android{} tiene este tándem para decidir si un servicio debe seguir vivo o no, como las peticiones de \textit{start} son disparadas por el propio servicio para realizar de forma periódica su tarea cognitiva, ha sido necesario modificar el ciclo de vida para que cuando el servicio deje de tener aplicaciones sobre él, se destruya a si mismo y no automáticamente como normalmente ocurriría. 

Cuando ocurre esto, los pasos a seguir son la preparación de la base de datos para una nueva instancia del servicio. Estas acciones comprenden resetear las direcciones \ac{IP} y el identificador del coordinador para cada nodo, así como el marcaje de éstos como inactivos. Por último una indicación de que el servicio ha sido parado de forma volunaria para darnos cuenta de posibles cierres forzados, de tal forma que al instanciar de nuevo el servicio siempre tengamos una situación de partida inicial. 
Estas acciones no son ejecutadas si la salida es forzosa: debido a un error no manejado que provoca el cierre o debido a la falta de memoría que provoca que el gestor de \android{} cierre la aplicación. En este caso como no se ha puesto la marca de cierre voluntario del servicio, al arrancar el servicio de nuevo podemos realizar estas acciones al comienzo para desembocar en la misma situación inicial.\\

Entre las acciones a ejecutar por el nodo que sale de la red tenemos que dependiendo de la interfaz la forma de avisar al resto de nodos que se quedan varia:
\subsubsection{WiFi}
\begin{codeInvolved}
\begin{files}
\textbf{WifiController}: sendbyePacket(), sendbyePacketReliable(), SendByePacket (AsyncTask)\\
\textbf{Service}: mHandlerWF, eventLostActionsNormal(), onDestroy(), onCreate()\\
\textbf{Database}: lostNode()
\end{files}
\end{codeInvolved}

En esta interfaz tenemos una conexión intermitente, que se desplega y se retrae en los momentos en los que hay comunicación. En esta situación ante eventualidades no tenemos el mismo tiempo de reacción como lo podemos tener en \bt{}. En el caso de salida voluntaria necesitamos un mecanismo que informe que un nodo va a abandonar la red.

Este mecanismo consiste en el envío de un paquete llamado \textit{``ByePacket''} que contiene la dirección \ac{MAC} del nodo que abandona la red. El envío de este paquete puede ser sobre \ac{TCP} o \ac{UDP}, en el caso de que el envío sea desde el nodo coordinador, sólo podremos mandarlo sobre \ac{TCP} ya que los nodos normales no escuchan sobre \ac{UDP} como hemos visto en \ref{subsec:configInterface}\\
%%diseño+impletacion
\comp{D+I:
Este envío se realiza gracias a otra \textit{AsyncTask} que al finalizar libera los recursos del controlador cerrando la vida de la aplicación por completo.
}
%%--

\protobufTableInit{Estructura mensaje desregistro en la red \wifi{}}
  \item[Tipo de paquete] Valor ``BYE'' del enumerado ``packetType''.
	\item[Bye packet] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo de paquete'':
	\begin{description}
		\item[Dirección MAC] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca.
	\end{description}
\protobufTableEnd{Campos del paquete ``ByePacket''}{byePacket}

Las acciones a ejecutar por los nodos que se quedan en la red son:

\figura{Vectorial/design/salidaRed-event}{width=.7\textwidth}{fig:salidaRed-event}{Flujo evento pérdida de nodo manejado disparado por evento del controlador desde los nodos que se quedan en la red}


\paragraph{Normal} Al recibir de manera fiable el paquete \textit{``ByePacket''} por parte del coordinador, el controlador generará un evento de pérdida de nodo que llegará al servicio donde procederemos a marcar a todos los nodos como inactivos y demás información volátil de la \ac{CWSN}, por otra parte informamos a las aplicaciones registradas de la pérdida del nodo y de la salida de la red. Si recibimos mediante señalización la pérdida de un nodo, procedemos a marcarlo como inactivo y a informar a las aplicaciones registradas del nuevo mapa de red.

\figura{Vectorial/design/salidaRed-signaling}{width=.7\textwidth}{fig:salidaRed-signaling}{Flujo evento pérdida de nodo disparado por señalización manejado desde un nodo normal}

\paragraph{Coordinador} Al recibir el paquete \textit{``ByePacket''} se generará el evento de pérdida de nodo que se entregará al servicio. Marcaremos este nodo como inactivo y veremos si aún quedan nodos en la red, si la respuesta es afirmativa enviaremos un mensaje de señalización a cada nodo restante en la red informando de la pérdida, así ellos podrán recomponer el mapa de red e informar a sus aplicaciones, informamos también a nuestras aplicaciones registradas del evento y de la nueva lista de nodos. Si la respuesta es negativa, nos limitamos a informar a las aplicaciones registradas del evento de pérdida y del evento de salida de la red.

\subsubsection{Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{BluetoothController}: connectionLost(), setState()\\
\textbf{Service}: mHandlerBt, eventLostActionsNormal(), onDestroy(), onCreate()\\
\textbf{Database}: lostNode()
\end{files}
\end{codeInvolved}

En este caso tenemos una conexión abierta en todo momento, por lo que ante cualquier eventualidad nos daremos cuenta inmediatamente de que se ha perdido la conexión, lo que hace innecesario el mecanismo descrito en la sección anterior.
%%diseño+implementacion
\comp{D+I:
Tanto si se trata de una salida voluntaria como involuntaria, se destruye tanto la aplicación como el servicio, se liberan todos los recursos. Al cerrarse el controlador de \bt{}, las hebras que haya abiertas desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de que el \textit{socket} usado en la comunicación ha sido cerrado, lo que supone que el controlador detecte el cierre de la conexión y lance el evento de pérdida de nodo.
}
%%---
Tanto si se trata de una salida voluntaria como involuntaria, se destruye tanto la aplicación como el servicio, se liberan todos los recursos. Al cerrarse el controlador de \bt{}, los canales de comunicación abiertos desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de la desaparición de éste y se lance el evento de pérdida de nodo desde ambos extremos.\\

Las acciones a ejecutar por los nodos que se quedan en la red son:
\paragraph{Normal} Si somos un nodo normal, el evento elevado hasta el servicio por el controlador significa que hemos perdido conexión con nuestro coordinador (que acaba de abandonar la red) y por tanto con toda la red, por lo tanto marcamos a todos los nodos como inactivos borrando además todos los datos relativos a la \ac{CWSN} que acabamos de abandonar. Informamos a las aplicaciones registradas que hemos dejado de formar parte de la \ac{CWSN}. Por otro lado, al recibir la señalización que indica la pérdida de un nodo seguimos el flujo visto en la figura~\ref{fig:salidaRed-signaling}

\paragraph {Coordinador} Si por el contrario somos un nodo coordinador, significa que hemos perdido la conexión con un nodo normal con el que teníamos comunicacion directa y debemos informar al resto de nodos de esta eventualidad enviando un mensaje de señalización con la dirección \ac{MAC} del nodo saliente para que ellos puedan rehacer el mapa de red. Marcamos también al nodo del que acabamos de perder la comunicación como inactivo e informamos a las aplicaciones registradas del evento y la nueva lista de nodos. Si todos los nodos de nuestra base de datos están marcados como inactivos, significa que acabamos de perder la comunicación con el último nodo y por tanto dejamos de estar en \ac{CWSN} situación que informamos a las aplicaciones registradas de manera análoga. 

%------------------------------
\subsection{Actualización de parámetros en la red}
\label{subsec:updateSettings}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, spreadNodeChangeOnNetwork(), updateInformationToCoordinator()
\end{files}
\end{codeInvolved}


Los parámetros del servicio se pueden dividir en dos grupos, los propios del servicio y los de las aplicaciones de los cuales uno de ellos es único y por tanto está compartido entre todas ellas (ver tabla~\ref{tab:serviceSettings}).

\begin{table}[h]
\begin{center}
	\begin{tabular}{r @{\hskip 1cm} p{7cm}}
	\multicolumn{2}{c}{Parámetros exclusivos servicio}\\ \hline 
	\textbf{Nombre del nodo} & Una \String{} que represente el nombre del nodo en la red.\\
	\textbf{Tipo de nodo} & Un \integer{} cuyo valor \bsq{0} se traduce por normal y cuyo valor \bsq{1} corresponde a coordinador.\\
	\textbf{Periodo tarea cognitiva} & Un \double{} que expresa el número de segundos que transcurren entre ejecuciones de la tarea cognitiva.\\
	\noalign{\vskip 0.25cm} 
	\multicolumn{2}{c}{Parámetros aplicación}\\ \hline 
	\textbf{Papel del nodo} & Un \integer{} para representar el papel que juega el nodo en la red, \bsq{0}: usuario secundario mientras que el valor \bsq{1} representa al usuario primario.\\
	\textbf{Código de aplicación} & Una \String{} para discernir entre mensajes enviados por distinas aplicaciones.\\
	\end{tabular}
	\caption{Parámetros del servicio} \label{tab:serviceSettings}
\end{center}
\end{table}

Los primeros parámetros son ajustes del servicio que traspasan a cualquier aplicación, sin embargo los segundos si son propios de cada aplicación. El primero expresa las necesidades de comunicación y el segundo nos sirve para filtrar mensajes en el servicio y entregar el contenido que está dirigido a esa aplicación en concreto. El parámetro ``papel del nodo'' en realidad es un parámetro compartido, es decir si varias aplicaciones están registradas en el servicio cada una habrá aportado un valor distinto, como este valor es único, elegimos el que es más adecuado a las necesidades de comunicación de la aplicación más restrictiva. En otras palabras si una aplicación pide ser ``usuario primario'' y otra aplicación pide ser ``usuario secundario'' el valor del parámetro será ``usuario/nodo primario''.

La primera forma de actualizar los parámetros de aplicación es con el registro de la aplicación en el servicio (ver sección~\ref{subsec:serviceRegisterProcess}) o en cualquier momento enviando un mensaje desde la aplicación al servicio del tipo \Scst{REGISTER\_EXCHANGE} (visto en la tabla~\ref{tab:registerExchangeMessage}) que desembocará en una contestación con todos los parámetros del servicio.
Con respecto a los parámetros exclusivos del servicio, la forma de actualizarlos está un poco escondida en la \ac{API}, ya que son ajustes propios del servicio y no de la aplicación y por tanto sometidos a cambios poco frecuentes. Normalmente estos parámetros están guardados en base de datos y se recuperan al recibir un mensaje del tipo \Scst{REGISTER\_EXCHANGE}, sin embargo si en este mensaje viene informado el campo \textit{obj} con un valor booleano a \true{} entonces en vez de coger los parámetros de la base de datos, los extraemos del mensaje. El detalle del mensaje ya se definió en la tabla~\ref{tab:updateAllParamsMessage}.

 
La actualización de estos parámetros (tanto cuando sólo actualizamos los de aplicación o todos) viene condicionada a si estamos cooperando ya en una red o no. Si no estamos en ninguna red los valores pasados sobreescribiran los existentes. En cambio si estamos en una situación de red, los parámetros ``papel del nodo'' y ``periodo tarea cognitiva'' pueden no ser actualizados, su actualización depende por tanto del valor actual, si es más restrictivo se podrán actualizar. Es decir para el ``papel del nodo'' sólo actualizaremos si el cambio pedido es a ``nodo primario'' y para ``periodo tarea cognitiva'' sólo actualizaremos si el periodo requerido es más pequeño que el actual.  Con respecto al parámetro ``tipo de nodo'' una vez se está en una \ac{CWSN} no se permiten cambios ya que dejaríamos a la red sin coordinador o añadiriamos otro coordinador, situaciones que no son de interés. Lo anterior no aplica, salvo el cambio de tipo de nodo, en la situación en que sólo hay una aplicación registrada, situación en la que actualizaremos los parámetros al no haber conflicto. \\

Con respecto a la actualización de estos parámetros al resto de nodos, una vez validados y actualizados según las reglas descritas, si son de interés general (``nombre del nodo'', ``papel del nodo'') son enviados al coordinador para que este los distribuya como una actualización más del mapa de red.

En \bt{} puede darse la situación de que si somos un nodo normal los demás nodos nos vean con parámetros antiguos, esto es debido a que si actualizamos nuestros parámetros fuera de una \ac{CWSN}, estos obviamente no son propagados a la red, al ser incluidos en la red por el coordinador, que ya nos conoce de veces anteriores, no tiene manera de saber que hemos actualizado los parámetros. Como impera la minimización del número de mensajes pasados por la red, éste no nos preguntará, sino que sacará una copia de los parámetros de su base de datos, que serán los mismos que tendrá el resto de la red, pues son la copia desactualizada y distribuida del coordinador. Esta situación es muy poco frecuente por lo que teniendo en mente la minimización del tamaño de mensajes y el número de éstos, se ha preferido no implementar mecanismos que hagan mantener actualizados en todo momento los parámetros del nodo (``nombre del nodo'', ``papel del nodo'' y ``tipo de nodo'' aunque este último es deducible por el contexto) en favor de una mayor eficiencia de red. Esta situación no ocurre en \wifi{} ya que la forma de registro en la red conlleva el envío de un paquete para registrarse en el que enviamos toda la información del nodo, por lo que sobre \wifi{} se puede actualizar en cualquier momento y sobre \bt{} sólo en momentos de cooperación en red. No obstante la situación de desactualización se soluciona cuando hay un cambio de contexto con interfaz destino \wifi{}.

%------------------------------
\subsection{Intercambio de mensajes}
La transmisión y recepción de datos se realizan a través del intercambio de mensajes definidos en la \ac{API}. Podemos destacar tres acciones: el envío, la recepción y una mezcla de ambos reservada sólo al coordinador que es el re-envío o \textit{forward} de mensajes.

\subsubsection{Recepción de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, mHandler<controlador>, incomingContentNormal(), incomingDataMessageToApp()\\
\end{files}
\end{codeInvolved}
%%diseño+implementación
\comp{D+I:
Empezamos explicando este proceso por ser el más fácil. Cuando la hebra del controlador (no importando cual) sale de su bloqueo al recibir datos, se genera el evento de recepción de datos que es manejado en el servicio. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona nuevamente al servicio esta información que dependiendo del controlador, incluirá {\small EXTRAS} distintos (ver tabla~\ref{tab:messageReadController}).
}
%%--
Empezamos explicando este proceso por ser el menos complejo y nos que nos ayuda a introducir algunas de las piezas que veremos en el proceso de envío. Al recibir datos se genera el evento \Scst{INTERFACE\_STATE\_RECEIVING} que es manejado en el servicio, para que este informe a las aplicaciones. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona nuevamente al servicio esta información que dependiendo del controlador, incluirá \Scst{EXTRAS} distintos (ver tabla~\ref{tab:messageReadController}).

\messageTableInit{\controllerToServ}{2 =\\ \scriptsize{MESSAGE\_READ}}{Número de \textit{bytes} leídos}{\nc{}}{\textit{bytes} leídos de la red}{\nc{}}

\messageTableExtraControllerSpecified{\wifi{}}{device\_ip\_address}{Una \String{} con la direción IP del nodo que nos envía los datos}

\messageTableExtraControllerSpecified{\bt{}}{device\_name}{Una \String{} con el nombre proporcionado por los servicios de \bt{} de \android{} (no es relevante)}
\messageTableExtraAddrow{device\_address}{Una \String{} con la dirección MAC de \bt{} del nodo que nos envía los datos}

\messageTableEnd{Mensaje recibido por la red entregado por ambos controladores al servicio}{messageReadController}

Una vez tenemos los \textit{bytes} leídos en el servicio los procesamos. Este procesamiento puede ser tan simple como entregar el contenido del mensaje a la aplicación correspondiente o reenviar el mensaje al siguiente eslabón de la cadena (sección explicada en la página~\pageref{forwardProcess}). El tratamiento del mensaje depende del tipo de nodo. Sin embargo, la presentación del mensaje hacia la aplicación si éste está dirigido hacia nosotros es común. Para ello necesitamos obtener el ``Código de aplicación'' (ver tabla~\ref{itm:dataMessage}) que nos permite recuperar el \textit{Messenger} de la aplicación. Así filtramos y entregamos a cada aplicación los mensajes que le interesan. También, gracias al campo ``Desde'' sabemos quién es el originador del mensaje. Una vez hemos recuperado la aplicación destinataria y el nodo que envío el mensaje, podemos trasladar esta información a la aplicación correspondiente (ver tabla~\ref{tab:incomingContent}).

\subsubsection{Envío de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, builtDataMessage(), getNextNodes(), send(), mHandler<controlador>, outgoingContentProgress()\\
\textbf{DataMessageQueue}: add(), hashMessage(), changeStatus(), remove()
\end{files}
\end{codeInvolved}

Para enviar datos a través del servicio cognitivo, la aplicación debe enviar un mensaje a través de la \ac{API} con la siguiente estructura (ver tabla~\ref{tab:outgoingContent}).

Una vez entregado el mensaje al servicio se empieza a procesar. Asumimos que el mensaje que se quiere enviar es de un contenido que se puede codificar como una \String{}, por tanto éste es el tipo de dato que se espera en el campo \textit{obj} del mensaje (\textit{payload}), si no el servicio devolverá un mensaje de error a la aplicación explicando que el contenido no puede manejarlo. En segundo lugar se comprueba que todos los valores de la lista son nodos de la red y están activos, también comprobamos que estamos en una \ac{CWSN}. Si no se superase alguna de estas otras validaciones se entregaría al igual que antes un mensaje de error a la aplicación con el código y descripción pertinentes abortándose el proceso en curso. Si no hay ningun problema, confeccionamos el mensaje que se va a enviar a la red cuyo formato vemos en la tabla~\ref{itm:dataMessage}

\protobufTableInit{Estructura mensaje datos}
  \item[Tipo] Valor ``DATA'' del enumerado ``MessageType''.
  \item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo.
	\item[Lista destinatarios] Una lista de \String{} con la lista con las direcciones MAC de \bt{} de los nodos destinatarios.
	\item[Código de aplicación] Una \String{} con el código de aplicación para filtrar el mensaje en destino. 
	\item[Marca de tiempo] Un \textit{long} con la representación del momento en el cual la aplicación entregó el mensaje al servicio.
	\item[Mensaje de datos] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Payload] Una \String{} con el contenido del mensaje. 
	\end{description}
\protobufTableEnd{Campos del mensaje de datos}{dataMessage}

Una vez tenemos el mensaje lo guardamos en una cola, lo que nos ayuda a calcular el tiempo de llegada de los mensajes de datos por parte de las aplicaciones y es necesario para ofrecer a la aplicación una confirmación positiva o negativa sobre la entrega a los nodos destinararios para cada mensaje. Como esta confirmación puede no ser inmediata, necesitamos almacenar de alguna manera el mensaje para poder recuperarlo cuando nos llegue ésta. Para guardarlo y rescatarlo cuando llegue el momento nos ayudamos de una clave, un \textit{hash} calculado en base a la marca de tiempo, el contenido del mensaje y la dirección \ac{MAC} de \bt{} del nodo que envía el mensaje. 

El siguiente punto es ver si podemos enviar el mensaje por la red, para ello debemos estar registrados en una \ac{CWSN} y no estar en una situación de cambio de contexto, si se da esta situación marcamos el mensaje como ``pendiente de envío'' en la cola. Si podemos enviarlo lo marcamos como ``en envío'' y se procede al envío. Para ello necesitamos saber quién o quienes son los siguientes nodos en la cadena de envío. Aunque gracias a que cada nodo tiene información sobre cómo alcanzar a otros nodos, nuestra red está centralizada en la figura del coordinador, por lo que la comunicación entre nodos no es posible siendo precisa una comunicación de saltos en los que el coordinador juega el papel central, siguendo la recomendación vista en \ac{CB} (\cite{conbrok}) para incrementar la eficiencia. No obstante, hay casos en que esta comunicación de saltos viene forzada por la interfaz de comunicación de uso, estamos hablando de \bt{} cuya única tipología posible es la de estrella (esclavo/maestro). El encaminamiento por tanto depende del tipo de nodo: 

\paragraph{Normal} El siguiente eslabón de la cadena siempre es nuestro nodo coordinador, tanto si el mensaje es dirigido a él, como si lo es a otros nodos. 

\paragraph{Coordinador} El coordinador tiene comunicación directa con todos los nodos, en \wifi{} ocurre siempre y en \bt{} tenemos la restricción de hasta siete nodos, si no introducimos la figura del ``coordinador intermedio'', nodo que se comporta como concentrador de mensajes en su \textit{piconet} y que a su vez está en otra \textit{piconet} donde se encuentra el coordinador. En estos momentos como sólo hay un salto, tenemos contacto directo con cualquier nodo no importando la interfaz en la que nos encontremos. Por tanto los siguientes eslabones de la cadena de entrega son los mismos nodos que están en el campo ``Lista Destinatarios'' del mensaje a enviar.\\

Una vez tenemos éste y a quién se lo vamos a enviar, procedemos al envío (en la siguente sección veremos que necesitamos un parámetro más pero que por el momento podemos obviar). Enviar es basicamente pasar como parámetros el mensaje al método \textit{write()} del controlador traduciendo los nodos a la dirección de comunicación de la interfaz, es decir si tenemos que enviar un mensaje a una serie de nodos de los cuales tenemos sus identificadores, tendremos que traducir estos identificadores a las direcciones \ac{IP} en el caso de \wifi{} o a las direcciones \ac{MAC} en \bt{}. Una vez que el mensaje ha sido escrito en la red por el controlador, este mismo informa al servicio a través de un mensaje del tipo \Scst{MESSAGE\_WRITE} con resultado del envío, enviándonos el propio mensaje de vuelta más una lista de las direcciones de comunicación a las cuales no ha podido entregar el mensaje (ver tabla~\ref{tab:messageWriteController}).

\messageTableInit{\controllerToServ}{3 =\\ \scriptsize{MESSAGE\_WRITE}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{bytes} enviados a través de la red}{\nc{}}
\messageTableExtra{requester}{Una \String{} que representa el \textit{messenger} de la aplicación que origina el mensaje}
\messageTableExtraAddrow{addressNotDelivered}{Una lista de \String{} con las direcciones \ac{MAC} de \bt{} o direcciones IP de los nodos a los cuales el envío del mensaje ha resultado fallido, según el controlador que nos envíe el mensaje}
\messageTableEnd{Mensaje resultado envío de datos desde el controlador al servicio}{messageWriteController}

Dependiendo de quienes sean los destinatarios del mensaje, el mensaje habrá llegado a su destino (no hay saltos de por medio) y por tanto no necesitamos más confirmación de entrega que la que ya nos da \ac{TCP} de por si. Si no tuviesesemos contacto directo con los nodos a los que queremos enviar el mensaje necesitamos esperar a que nos confirmen el resultado de la entrega de éste.

\paragraph{No es necesario recibir mensaje ACK} En este primer caso, al ser una entrega directa, si somos un nodo normal el mensaje tiene como único destinatario nuestro coordinador. Si somos un nodo coordinador el mensaje ha sido entregado en mano a todos los nodos. Como ya se ha terminado el flujo de envío del mensaje, procedemos a borrarlo de nuestra cola de mensajes gracias al \textit{hash} y a entregar un mensaje a la aplicación con información sobre la entrega (ver tabla~\ref{tab:outgoingContentResultApp}).

\paragraph{Es necesario mensaje ACK} En el segundo caso, el mensaje envíado requiere de un salto en la red, requiere de un reenvío. La casuística de cómo se producen este tipo de mensajes será explicada en la siguiente sección, en ésta nos limitamos a ver el proceso de recepción del \ac{ACK} vista desde un nodo normal. En este caso al recibir por parte del controlador el mensaje (ver tabla~\ref{tab:messageWriteController}) procedemos a su marcaje en la cola como ``pendiente de ack'' quedando a la espera de recibir la confirmación del envío del siguiente salto. Este mensaje de señalización tiene la composición descrita en la tabla~\ref{itm:ackMessage}

\protobufTableInit{Estructura mensaje ACK}
  \item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``ACK'' del enumerado ``AskType''.
		\item[Mensaje de ACK] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':
			\begin{description}
				\item[Hash] Un \textit{long} con el identificador único de mensaje.
				\item[Número mensajes escritos OK] Un \integer{} con el número de mensajes que han sido correctamente entregados.
				\item[Lista de direcciones MAC NOK] Una lista de \String{} con las direcciones MAC de \bt{} de los nodos a los cuales no se ha podido entregar el mensaje.
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje ACK}{ackMessage}
  
Al recibir la confirmación procedemos a borrar de la cola el mensaje de datos utilizando el \textit{hash} leído de la señalización y a comunicar a la aplicación el resultado del proceso de envío. (El detalle puede verse en la tabla~\ref{tab:outgoingContentResultApp})

\umlsdInitTitle{Envío desde nodo A, a los nodos B y C}
	\newinst{a}{nodo A} \newthread[black!30]{nc}{nodo Coordinador} \newinst[1]{b}{nodo B} \newinst{c}{nodo C}
	\begin{call}{a}{Envío datos}{nc}{} \end{call}
	\prelevel\callSelf{a}{Marcar mensaje en la cola como \bsq{pendiente de ACK}}
	\begin{messcall}{nc}{Re-envío datos A}{b} \end{messcall}
		\prelevel\prelevel\callSelf{b}{Entrega datos a la app} \postlevel
	\begin{messcall}{nc}{Re-envío datos A}{c} \end{messcall}
		\prelevel\prelevel\callSelf{c}{Entrega datos a la app}
	%\mess{nc}{ACK}{a}
	%\begin{messcall}{nc}{\shortstack {ACK\\ \texttt{(Entrega datos enviados} \\ \texttt{y estadísticas a la app)}}}{a} \end{messcall}
	\begin{messcall}{nc}{ACK}{a} \end{messcall}
	%\callSelf{a}{borrado mensaje de la cola}
	\node[align=right,text width=5cm] at (0.9,-7.6){\texttt{Entrega datos enviados, borrado del mensaje en la cola y envío de estadísticas a la app}};
\umlsdEnd{Ejemplo envío con necesidad de ACK}{sendNeededACK}
 
%\newpage
\subsubsection{Forward de mensajes}
\label{forwardProcess}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: mHandler<controlador>, incomingContentCoordinator(), outgoingContentProgressCoordinator()\\
\end{files}
\end{codeInvolved}

Este proceso es una mezcla de una recepción y un envío de mensajes, reservada al papel de coordinador. Este proceso comienza con la recepción (en el nodo coordinador) de un mensaje originario en un nodo normal cuya lista de nodos destinatarios atañe a más nodos de los dos implicados en esta comunicación. En esta lista puede estar o no incluido el coordinador, si está incluido como paso inicial presentaremos el mensaje a la aplicación como hemos descrito en la recepción de mensajes. Acto seguido procederemos al re-envío de éste, para ello como vimos en la sección anterior tenemos que conocer cuáles son los siguientes nodos a los que enviar el mensaje (prestando especial atención a que si es un mensaje dirigido a todos, no volver a enviarlo al nodo originario de la comunicación), el mensaje a enviar que es el mismo que acabamos de recibir (sin hacerle ningún cambio) y por último el parámetro que antes obviamos.

Esta elusión tiene como motivación haber facilitado la lectura de secciones anteriores al no añadir otra pieza más al rompecabezas. Nuestro flujo de trabajo necesita transmitir a través de todas las capas (servicio, controlador y capas inferiores, si intervienen) qué aplicación es la originaria del mensaje para poder ofrecerle una respuesta cada vez que envie datos a través del servicio. En el caso de un re-envío no hay aplicación originaria del mensaje en el nodo que acaba de recibir un mensaje que tiene que retransmitir, por ello no se puede utilizar el ``Código de aplicación'' grabado en el mensaje de datos, además su uso implica que no podría haber dos aplicaciones registradas a la vez con el mismo código. El parámetro por tanto es una simple \String{} que representa, o al \textit{messenger} de la aplicación o si ésta no existe, una \String{} especial que marque la situación de reenvío.\\
De esta manera uniformamos el valor de este campo al tratarse en ambos casos de \Strings{} e indirectamente evitamos serializar un objeto complejo como es el \textit{Messenger} de \android{} o ubicarlo en un sitio que no está pensado para él. Al intervenir en este proceso varias capas de la arquitectura si hubicasemos el objeto en el campo (\textit{msg.replyTo}) se usaría con otro propósito al pensado por la plataforma \android{}, lo que hace poco claro el código.\\
Es necesario transmitir este parámetro a través de todo el flujo de envío ya que son procesos que pueden no resolverse en la misma petición, además son sin memoria y pueden ser disparados por distintas aplicaciones en cualquier momento donde además el preservamiento del orden entre distintos procesos de envío no está garantizado.\\

Las \Strings{} especiales que representan la situación de reenvío y que son claves para que el flujo del proceso actue en conseguencia son: \var{``forward-me''} y \var{``forward-not-me''} para referirse tanto a la situación en la que el coordinador forma parte de la lista del mensaje que se reenvía, tanto a cuando no.

Al igual que en un envío normal, almacenamos el mensaje en la cola y lo enviamos. Al recibir por parte del controlador el mensaje descrito en la tabla~\ref{tab:messageWriteController} en vez de trasladar el mensaje a la aplicación (dado que no existe) como se hace en el envío, es aquí dónde confeccionamos el mensaje de confirmación (ver tabla~\ref{itm:ackMessage}) que enviaremos al nodo originario del mensaje de datos.


%------------------------------
\subsection{Sensado del entorno compartido y política cognitiva}
\label{subsec:senseAndPolicy}
Los parámetros del entorno que son de nuestro interés son el  \ac{RSSI} (intensidad de señal) de la red \wifi{} a la cual estamos conectados y la tasa de envío de mensajes de datos. El sensado del entorno se realiza en varios puntos de la arquitectura y son compartidos mediante señalización (ver tabla~\ref{itm:scanMessage}) con el coordinador de forma periódica. Éste al recibirlos dependiendo de la prioridad con la que vengan marcados se limita a guardarlos en su base de datos o a hacer un análisis rápido de la situación que desemboque en la toma de ciertas decisiones.

\protobufTableInit{Estructura mensaje SCAN}
  \item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``SCAN'' del enumerado ``AskType''.
		\item[Mensaje de SCAN] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':
			\begin{description}
				\item[Prioridad] Un enumerado (Priority) con la urgencia del sensado, toma dos valores {\small Priority.TASK} para sensados normales y {\small Priority.URGENT} para marcar que la información del entorno es sensible.  
				\item[RSSI] Un \integer{} con el nivel de señal de la red \wifi{} a la que estamos conectados (-9999 si no estamos en ninguna).
				\item[Intervalo promedio envío de mensajes] Un \double{} con el resultado promedio móvil del intervalo medido en segundos entre la llegada de mensajes de datos por parte de las aplicaciones.  
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SCAN}{scanMessage}


\subsubsection{Parámetro del entorno: RSSI}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: normalCognitiveTask(), mWifiAdapter.getConnectionInfo()\\
\end{files}
\end{codeInvolved}

Para medir la intensidad de señal podemos utilizar de manera activa la \ac{API} de \android{} obteniendo el valor de la fuerza de la señal medida en dBm. También de una manera indirecta, aprovechamos los mensajes que lanza el sistema \android{} con información acerca de este parámetro. El registro se efectúa cuando se inicializa el servicio y nos desregistramos (para no dejar \textit{memory leaks}) al finalizar el servicio. Así las diferentes políticas cognitivas tienen disponible este parámetro a lo largo de toda la vida del servicio.
 
En nuestra arquitectura utlizamos estos dos puntos de medida para este parámetro, el primero está localizado en la tarea cognitiva dónde lo guardamos en la base de datos para usos futuros. El otro punto reside en las notificaciones, éstas nos ayudan a actuar con el menor tiempo de respuesta, ya que si detectamos una situación que entrañe riesgo podemos compartir esta información sin esperar a la tarea cognitiva donde realizamos entre otras cosas el sensado del entorno.

\subsubsection{Parámetro del entorno: Intervalo promedio envío de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: normalCognitiveTask()\\
\textbf{DataMessageQueue}: getAvgArrivalRateUpdateTillNow()
\end{files}
\end{codeInvolved}

En este caso la medición se va confeccionado cada vez que una aplicación entrega un mensaje de datos al servicio para su envío, al añadirlo a la cola registramos el tiempo que ha pasado desde la última vez, si tenemos suficientes registros olvidamos el último antes de añadir este nuevo, esto nos permite realizar promedios móviles que se centren en una situación cercana al momento actual para extraer información reciente y no condicionada excesivamente por eventos pasados.\\

En la tarea cognitiva (que recordamos que es periódica) calculamos la media de estos valores. Se da la situación de que el promedio sólo cambia al incluir nuevos mensajes en la cola, desembocando en que si no se producen nuevas inclusiones se obtiene el mismo valor del intervalo de envío de mensajes en ejecuciones consecutivas de la tarea cognitiva, desvirtuando este valor. Necesitamos algún mecanismo que sin desfigurar los datos, refleje esta situación de no envío y por tanto evidenciar un aumento del promedio.

Para ello en el momento de la transmisión de los parámetros del entorno al cooridnador, obtenemos el promedio y registramos de nuevo el tiempo así podemos re-calculamos el intervalo tal y como si hicieramos un falso envío pero sin incluir a éste en los datos para no desfigurar el resultado en sucesivos envíos (que se hayan producido realmente).

\subsubsection{Política cognitiva}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: mayTakeAdvantageOfBT() mayTakeAdvantageOfWiFi(), sendTroublingRssi(), coordinatorCognitiveTask()
\end{files}
\end{codeInvolved}
La política cognitiva implementada es competencia del nodo coordinador. Esta política tiene en cuenta tanto los parámetros propios del nodo coordinador como el sensado del entorno de los demás nodos. El análisis de los datos de sensado recae fundamentalmente en el nodo coordinador, sin embargo para evitar situaciones de pérdida de nodos, el nodo normal avisa de forma activa si su \ac{RSSI} decae por debajo de un umbral.\\
El cambio de interfaz obedece a estos motivos:
\begin{description}
	\item[De WiFi a Bluetooth] Por pérdida de la señal.
	\item[De Bluetooth a WiFi] Por el aumento de la tasa de envío de mensajes de datos en la red.
\end{description}

%------------------------------
\subsection{Cambios de contexto}
Con la información recogida del entorno tanto por el mismo nodo como por sus compañeros podemos tomar decisiones sobre la estabilidad de la red y conforme a experiencias pasadas colocar a ésta en el lugar que mejor se adapte. Necesitamos una serie de protocolos que mantengan la integridad de la red y marquen los pasos a seguir cuando hay un cambio de interfaz.

\subsubsection{Cambio de contexto con interfaz destino WiFi}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfWiFi(), contextChangeToWiFi(), SetupWifiInterface (asyncTask), mHandlerWF, scheduleTaskWifi(), sendEndSwitchMessage(), endContextualChange()
\end{files}
\end{codeInvolved}

\umlsdInit
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B}
	\callSelf{nc}{Configurar \wifi{} y obtener ip}
	
	\mess{nc}{Switch: ip, ssid}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{\shortstack{Configurar \wifi{}\\y apagar interfaz origen}}	

	\mess{b}{\bsq{HelloPacket}}{nc}	
	\mess{nc}{ACK \bsq{HelloPacket}}{b}
	\prelevel\callSelf{b}{Parar envío \bsq{HelloPacket}}\prelevel	
	\mess{a}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{a}
	\prelevel\callSelf{a}{Parar envío \bsq{HelloPacket}}\prelevel
	\postlevel
	\callSelf{nc}{Apagar interfaz origen}
	\prelevel\mess{nc}{End Switch}{a}	
	\mess{nc}{End Switch}{b}
\umlsdEnd{Ejemplo cambio de contexto hacia \wifi{}}{switchToWifi}

Cuando el coordinador ejecuta su tarea cognitiva va rescatando de su base de datos para cada nodo los últimos escaneos de éste obteniendo un promedio y una tendencia de los datos de sensado. Evalúa estos datos y decide si es necesario un cambio de interfaz. En caso positivo, obtenemos una lista de los nodos activos en la red, los marcamos como inactivos e informamos a las aplciaciones sobre el nuevo evento (ver mensaje en la \ac{API}) y configuramos la interfaz de \wifi{}. Para ello utilizamos el mismo prodecimiento usado en~\ref{subsec:configInterface} con unos pasos extras: una vez nos hemos conectado a la red enviamos un mensaje de señalización (a través de la interfaz actual, aún \wifi{} no es efectiva) a la lista de nodos que sacamos informandoles del cambio y de la información necesaria para llevarla a cabo, (ver tabla~\ref{itm:switchToWifi})

\protobufTableInit{Estructura mensaje SWITCH hacia \wifi{}}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la direción MAC de \bt{} del nodo.
  \item[Mensaje de señalizacion]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``SWITCH'' del enumerado ``SignalType''.
		\item[Mensaje de SWITCH] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Interfaz destino] Valor ``TO\_WIFI'' del enumerado ``ToInterface''.  
				\item[SSID] Una \String{} con el nombre de la red \wifi{} a la que se va a realizar el cambio.
				\item[BSSID] Una \String{} con la dirección MAC del punto de acceso para evitar cualquier equívoco.
				\item[Dirección IP coordinador] Una \String{} con la dirección IP del nodo.
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SWITCH hacia \wifi{}}{switchToWifi}
 
Al terminar de configurar la interfaz (siendo ésta ya efectiva), dejamos programado un \textit{timeout} que dispare el fin de cambio contextual para evitar bloqueos porque algún no responda. A partir de ahora esperamos a que los nodos normales configuren su interfaz de \wifi{} (antes apagarán su interfaz en curso, en este caso \bt{}) y vayan entrando en la nueva red tal y como se contó en las secciones~\ref{subsec:configInterface} y~\ref{subsec:enterInNetwork}

El coordinador al recibir los \textit{``HelloPacket''} en vez de seguir el flujo normal que consiste informar a todos los nodos de la nueva entrada y al nuevo nodo informarle sobre el mapa de red, nos limitamos a enviarle un mensaje de confirmación indicándole que hemos recibido el \textit{``HelloPacket''} para que éste pare su envío, así evitamos enviar muchos mensajes de señalización de una situación que es probable que cambie. Estos paquetes están enviados directamente a la IP del coordinador (recogida del mensaje de señalización de cambio) para que haya más posibilidades de recepción. Si por algún casual el nodo normal terminase su ráfaga y no obtuviese respuesta el mismo entendería que el proceso de cambio de contexto ha acabado de manera insatisfactoria. El detalle de este mensaje de confirmación de entrada en la red en situación de cambio se ve en la tabla~\ref{itm:okSwitch}

\protobufTableInit{Estructura mensaje confirmación cambio de contexto}   
	\item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``SWITCH'' del enumerado ``AskType''.
	\end{description}
\protobufTableEnd{Campos del mensaje de confirmación entrada (\wifi{}) / interfaz lista (\bt{})}{okSwitch}

Si antes de que salte el \textit{timeout} programado, hemos recibido todos los \textit{``HelloPacket''} de todos los nodos que estaban formando la red, procedemos a finalizar el cambio de contexto, si no esperamos a que finalice el \textit{timeout}, situación en la que habremos perdido algún nodo.

\paragraph{Coordinador} Al dispararse el final del cambio de contexto, apagamos la interfaz \bt{} y liberamos todos los recursos. Hemos mantenido la interfaz arriba hasta el último momento para no perder mensajes de datos si algún nodo actúa de manera incorrecta y envía estos mensajes en pleno cambio de conexto. Acto seguido se envía el mapa de red por medio de señalización a todos los nodos que formen ahora la red (idealmente todo los que la formaban antes del cambio), cuyo detalle se aprecia en la tabla~\ref{itm:endSwitch}

\protobufTableInit{Estructura mensaje fin cambio de contexto}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la direción MAC de \bt{} del nodo (coordinador).
  \item[Mensaje de señalizacion]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``TOPOLOGY'' del enumerado ``SignalType''.
		\item[Mensaje de mapa de red] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Cambio] Valor ``ALL\_END\_SWITCH'' del enumerado ``TopologyChange''.  			
					\begin{description}
						\item[Representación de un nodo] Mensaje con los cambios que sirven para representar a nodo (ver tabla~\ref{itm:infoNode}). Tendremos tantas representaciones como nodos haya en la red.
					\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje finalización cambio de contexto}{endSwitch}

Notar que este mensaje es diferente para cada nodo ya que lista de nodos vista desde cada nodo difiere en que él mismo no se encuentra en ésta pero el resto sí. Los últimos pasos para finalizar el cambio de contexto es intentar enviar los mensajes encolados (los mensajes que hayan entregado las aplicaciones mientras que el proceso de cambio de contexto esté vigente) y publicar hacia las aplicaciones registradas en el servicio el evento del fin de cambio de contexto que incluye la nueva interfaz, el estado de ésta y la lista de nodos que forman la red en este momento. Así como el vaciado de la cola de mensajes pendientes de envío.

\paragraph{Normal} Al recibir el mensaje de señalización de cambio de contexto, procedemos a cancelar (de nuevo) el envío de \textit{``HelloPacket''} por si no hubiesemos recibido el mensaje visto en la tabla~\ref{itm:okSwitch}, informar a las aplicaciones el evento de fin de cambio de contexto con el nuevo mapa de red leído del mensaje de señalización y proceder al envío de los mensajes encolados mientras haya durado este proceso.

\umlsdInitTitle[h!]{Cambio de contexto, situación problemática}
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B} \newinst[1]{c}{nodo C}
	\callSelf{nc}{Configurar \wifi{} y obtener ip}
	
	\mess{nc}{}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\mess{nc}{Switch: ip, ssid}{c}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{}
	\prelevel\prelevel\callSelf{c}{\shortstack{Configurar \wifi{}\\y apagar\\interfaz origen}}
	
	\messFail{a}{\bsq{HelloPacket}}{nc}
	\messFail{c}{\bsq{HelloPacket}}{nc}	
	\messFail{a}{\bsq{HelloPacket}}{nc}
	
	\mess{b}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{b}
	\prelevel\callSelf{b}{Parar envío \bsq{HelloPacket}}\prelevel
	
	\mess{a}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{a}
	\prelevel\callSelf{a}{Parar envío \bsq{HelloPacket}}\prelevel

	\postlevel\postlevel

	\draw[thick,->] (0.9,-8) -- (1.4,-8) node[anchor=south east] {\small\shortstack{\textit{Timeout}\\expirado\\en Coor-\\dinador}};
	\callSelf{nc}{Apagar interfaz origen}
	\prelevel\mess{nc}{End Switch}{a}
	\messFail{c}{\bsq{HelloPacket}}{nc}	
	\mess{nc}{End Switch}{b}
		
	\callSelf{c}{\small\shortstack{\textit{Timeout} expirado en\\ C: No hay respuesta\\a \bsq{HelloPacket}: no\\ en CWSN}}		
	\node[fill=blue!30, align=right] at (6,-11.7) {\small\shortstack{Situación normal de red\\ población: A, B y Coordinador}};
	%\node [draw, rotate=90] at(0,-3) (first) {Timeout};
	%\node at(-0.5,-3) (second) {a};
	%\draw[->,gray,rounded corners] (second) edge (first);
	
	%\draw[thick,->] (0.5,-4) -- (1,-4) node[anchor=south east] {Timeout expired};
\umlsdEnd{Ejemplo cambio de contexto hacia \wifi{} con pérdida de nodos}{switchToWifiFail}
~\\%ajustar espacios y que caiga por debajo de la imagen
\subsubsection{Cambio de contexto con interfaz destino Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfBT(), contextChangeToBT(), SetupBTinterface (asyncTask), mHandlerBt,  tellBTisUP(), scheduleEndSwitchBTRunnable (future) scheduleSetupBTRunnable (future) , sendEndSwitchMessage(), endContextualChange()
\end{files}
\end{codeInvolved}

\umlsdInit
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B}
	\mess{nc}{Switch}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{Configurar \bt{}}	

	\mess{a}{OK Switch}{nc}
	\mess{b}{OK Swtich}{nc}
	
	\callSelf{nc}{Configurar \bt{} y apagar interfaz origen}
	\begin{call}{nc}{connect()}{a}{conexión aceptada} \end{call}
	\begin{call}{nc}{connect()}{b}{conexión aceptada} \end{call}	
	\mess{nc}{End Switch}{a}
	\prelevel\callSelf{a}{Desconectar interfaz origen}
	\mess{nc}{End Switch}{b}
	\prelevel\callSelf{b}{Desconectar interfaz origen}
\umlsdEnd{Ejemplo cambio de contexto hacia \bt{}}{switchToBT}

Cuando se produce un cambio de interfaz a \bt{} el coordinador al igual que en el otro cambio de contexto obtiene una lista de quién está en la red y se marcan como inactivos. Comunicamos hacia las aplicaciones el nuevo estado de la red y procedemos a enviar un mensaje de señalización que marque a los demás nodos el evento de cambio de contexto hacia \bt{}, este mensaje tiene la disposición mostrada en la tabla~\ref{itm:switchToBT}\\

\protobufTableInit{Estructura mensaje SWITCH hacia \bt{}}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la direción MAC de \bt{} del nodo.
  \item[Mensaje de señalizacion]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``SWITCH'' del enumerado ``SignalType''.
		\item[Mensaje de SWITCH] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Interfaz destino] Valor ``TO\_BT'' del enumerado ``ToInterface''.   
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SWITCH hacia \bt{}}{switchToBT}

Una vez enviado, programamos la tarea de configurar la interfaz de \bt{} en el coordinador con un margen de tiempo suficiente para obtener las respuestas de los nodos normales, que al recibir la señalización configuran su interfaz \bt{} e informan a sus aplicaciones del nuevo estado. Una vez levantada, comunican al coordinador través de la interfaz en curso (\bt{} aún no es efectiva para envíar mensajes, ya que entre otras cosas no hemos establecido ninguna conexión con el coordinador) que la interfaz destino está lista para aceptar conexiones, para ello utilizamos el mensaje ya visto en la tabla~\ref{itm:okSwitch}, reutilizamos este mensaje de confirmación que no lleva ninguna información especial y que por el contexto le damos el significado de estar preparado (en la otra ocasión el contexto le daba el significado de confirmación de entrada en la red).\\

Este mensaje le sirve al coordinador para saber que el nodo ya está listo y cuando recibe todas las confirmaciones (o salta el timeout programado anteriormente) procede a configurar su interfaz de \bt{} pasándole la lista de nodos que obtuvimos. La configuración de la interfaz incluye una ronda de conexiones a los nodos que formaban la red antes del cambio, que es pasada como parámetro. Una vez terminado ejecuta los mismos pasos descritos en la sección anterior para terminar el cambio de contexto. Salvo que en el mensaje de señalización de fin de cambio de contexto (ver tabla~\ref{itm:endSwitch}) la representación de cada nodo no incluye el campo ``Dirección IP''.\\
%%diseño+implementacion
\comp{I+D:
Por su parte el nodo normal al configurar su interfaz \bt{} y después de enviar la confirmación al coordinador de que está listo, programa una tarea (implementada gracias al esquema de programación basado en \textit{Runnables} alojados en la interfaz \textit{Future} y ejecutados en hebras gestionadas por el objeto \textit{Executor}) para salir de la situación de cambio de contexto por si no recibe ninguna conexión entrante o por si no recibe el mensaje de señalización de fin de cambio de contexto. Así se garantiza que ningún nodo se quede en \textit{deadlock} y el flujo siempre se ejecuta de principio a fin.
}
%%----

Por su parte el nodo normal al configurar su interfaz \bt{} y después de enviar la confirmación al coordinador de que está listo, programa una tarea para salir de la situación de cambio de contexto por si no recibe ninguna conexión entrante o por si no recibe el mensaje de señalización de fin de cambio de contexto. Así se garantiza que ningún nodo se quede en \textit{deadlock} y el flujo siempre se ejecuta de principio a fin.



\umlsdInitTitle[h!]{Cambio de contexto, situación problemática}
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B} \newinst[1]{c}{nodo C}
	\mess{nc}{Switch}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\mess{nc}{}{c}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{Configurar \bt{}}
	\callSelf{c}{\shortstack{Configurar \\\bt{}: NOK}}

	\mess{a}{OK Switch}{nc}
	\mess{b}{OK Swtich}{nc}
	\postlevel\postlevel\postlevel
	\draw[thick,->] (0.9,-6) -- (1.4,-6) node[anchor=south east] {\small\shortstack{\textit{Timeout}\\expirado\\en Coor-\\dinador}};
	\callSelf{nc}{Configurar \bt{} y apagar interfaz origen}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{b}{} \end{messcall}
	\begin{call}{nc}{connect()}{b}{conexión aceptada} \end{call}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}	
	\mess{nc}{End Switch}{b}
	\prelevel\callSelf{b}{Desconectar interfaz origen}
	\postlevel\callSelf{a}{\textit{Timeout} expirado en A y C: no en CWSN}
	\prelevel\prelevel\callSelf{c}{}
	\node[fill=blue!30, align=right] at (6,-18.3) {\small\shortstack{Situación normal de red\\ población: B y Coordinador}};
\umlsdEnd{Ejemplo cambio de contexto hacia \bt{} con pérdida de nodos}{switchToBTFail}

%-------------------------------------------------------------------
\clearpage
\section{Aplicación utilitaria servicio cognitivo}
\label{sec:app}
%-------------------------------------------------------------------
Para hacer uso y probar las características cognitivas de nuestra arquitectura se ha diseñado una aplicación que se monta sobre el módulo o servicio cognitivo. La aplicación desarrollada además de cumplir la \ac{API} en su totalidad (incluida la denominada parte oculta) permite acceder a los parámetros de la politica cognitiva y los timeouts utilizados en los procesos de red.\\

La aplicación simula el comportamiento de un sensor cuyo valor lo introduce el usuario y monitoriza el estado del servicio gracias a los mensajes de información que se envían desde el propio servicio o módulo cognitivo. Se estrutura en tres secciones: la principal que da cabida al objetivo de la aplicación y permite en caso de \bt{} la conexión manual al nodo. En una segunda sección se muestra (si el usuario lo requiere desde la configuración) unas funciones de \textit{test} entre las que podemos enumerar:
\begin{description} 
	\item[Petición, respuesta] Permite dependiendo del tipo de nodo, guardar una respuesta en el caso de nodos normales o pedir esta información para los nodos coordinadores. Con esta función se habilita un mecanismo de petición de información muy útil para la arquitectura cognitiva para la compartición de datos de sensado.
	\item[Encolamiento de mensajes] Debido a que la aplicación actualiza de forma instantánea la lista de nodos al recibir un evento de cambio de contexto, se inabilita la elaboración de mensajes de datos que entregar al servicio debido a que no es posible construir una lista de destinatarios válida puesto que el único valor seleccionable por el usuario es \bsq{0} cuyo significado es la ausencia de nodos. Al intentar entregar un mensaje de datos al servicio con este valor, la validación que existe en la aplicación impide finalmente su entrega.\\
Por este motivo no es posible generar un mensaje válido que se entrege al servicio en el momento que produzca su encolamiento, por lo que la aplicación permite gracias a un \textit{shortcut} \textit{(workaround)} el forzado para el encolamiento. Al pulsar el botón diseñado a tal efecto, se nos pregunta a través de una cadena de diálogos el mensaje a encolar y a que destinatarios debe dirigirse.
	\item[Vaciado de la cola de mensajes] El vaciado de la cola de mensajes pendientes de envío se produce al efectuarse un cambio de conexto, una vez las funciones de red están nuevamente activas, si se quiere forzar el vaciado de esta cola por motivos de \textit{test} se ha habilitado un botón junto al de la función anterior a tal efecto.
	\item[Envío periódico datos sensor] Una característica muy presente en redes de sensores es la que los sensores suelen enviar datos de forma periódica. Simulamos esta característica en la aplicación tras selecionar el periodo, los datos enviados consiste en una \String{} más un número que incrementamos en cada envio. 
\end{description}
Por último, en una tercera sección que alberga la configuración. En ella podemos elegir:
\begin{description}
	\item[Ajustes del servicio] Tipo y nombre del nodo, periodo tarea cognitiva y valores de la política que regula los cambios de contexto (ver~\ref{subsubsec:policyImpl}).
	\item[Ajustes de la aplicación] Código de aplicación, papel del nodo y si el texto que se usa como valor del sensor debe borrarse después de su envío al servicio.
 \item[Ajustes de test] Toda la configuración de la segunda sección como: si ha de visualizarse en la pantalla principal, con qué interfaz debe arrancar el servicio si la sección de \textit{test} está activada y los \textit{timeouts} utilizados para los \textit{handovers}.
\end{description}

La aplicación proporciona validaciones adicionales para evitar el incumplimiento de la \ac{API} o la interacción con el servicio si no es necesaria. No se permite:
\begin{itemize}
	\item El envío de mensajes de datos si no está establecida una \ac{CWSN}.
	\item El envío de mensajes no dirigidos a un nodo válido (tanto si es inactivo pues no se permite su selección al no estar presente entre los \textit{items} que se presentan al usuario, como si el único valor que se presenta es la ausencia de nodos).
	\item La actualización vacía de la configuración. Es decir si no hay un cambio en la configuración no se traspasan las modificaciones necesarias al servicio para su actualización.
\end{itemize} 

\begin{figure}
\begin{center}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/settings}%
		\caption{settings1}%
	\end{minipage}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/settings2}%
		\caption{settings2}%
	\end{minipage}%
	%\caption{settings}%
\end{center}
\end{figure}


\begin{figure}
\begin{center}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/listnodes}%
		\caption{main ui}%
	\end{minipage}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/menu}%
		\caption{menu}%
	\end{minipage}%
	%\caption{settings}%
\end{center}
\end{figure}

\begin{figure}
\begin{center}%
		\includegraphics[width=.3\linewidth]{Imagenes/Bitmap/design/uitest}%
		\caption{testing ui}%
\end{center}
\end{figure}

%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
