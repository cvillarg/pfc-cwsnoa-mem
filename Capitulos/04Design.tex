%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\chapter{Diseño}
\begin{FraseCelebre}
	\begin{Frase}
	No es pretender el triunfo,\\ es resistir a los fracasos
	\end{Frase}
	\begin{Fuente} \textit{Def.} Esperanza, {\scriptsize\sc Novena Virgen de la Salud} \end{Fuente}
\end{FraseCelebre}
\begin{resumen}
En este capítulo definimos la arquitectura del nodo cognitivo sobre la que detallamos las interfaces de programación y los procesos de red invulcrados en su funcionamiento.
\end{resumen}


%-------------------------------------------------------------------
\section{Arquitectura cognitiva}
%-------------------------------------------------------------------
\label{sec:arquitecturaCognitiva}
\figura{Vectorial/design/node}{width=.65\textwidth}{fig:architecture}{Arquitectura cognitiva}

Nuestra arquitectura se ha diseñado siguiendo pinceladas del modelo
\ac{CB} \cite{conbrok}. Sim embargo, no se han podido seguir todas las
recomendaciones puesto que no implementamos el objeto \texttt{CompNet}
(distintas redes cooperando para por ejemplo mitigar la interferencia)
y que no tenemos acceso a otros planos que no sea el de aplicación. Al
tener un \textit{hardware} fijo, sin posibilidad de cambios y tener un
control limitado de éste (sólo las partes que \android{} nos permite)
se desvanece la posibilidad de selecionar proactivamente la
modulación, la codificación o el nivel de potencia en la
transmisión. Nos restringimos al diseño de una arquitectura
confiando en las propias capacidades cognitivas u optimizaciones que
elige la plataforma de por sí o que son accesibles de alguna u otra
manera: \textit{reflection}, superusuario\ldots\\

%En este primer parrafo creo que despues de la referencia va punto:
%[1]. Sin embargo, no se han podido... %XXX-cvillar OK

%\figura{Vectorial/design/node}{width=.65\textwidth}{fig:architecture}{Arquitectura cognitiva}

Como puede verse en la figura~\ref{fig:architecture} se ha estructurado la arquitectura en dos capas, existiendo una subdivisión de la capa inferior en otras dos. Un modelo de capas permite definir interfaces de comunicación entre las diferentes unidades, limitando el alcance y conocimiento de cada módulo independizando su propósito del resto. A saber:

\begin{enumerate}
\item \bsq{\bf Capa de aplicación}: Formada por cada una de las aplicaciones que operan sobre el servicio cognitivo que les sirve como canal de comuncaciones. Cada una de estas aplicaciones, tiene que cumplir con la interfaz definida entre esta capa y la inferior (aplicación y cognitiva). El diseño e implementación de cada aplicación excede a este proyecto y depende en cada caso del tercero que desarolle la aplicación. No obstante para probar y utilizar las capacidades de nuestro nodo cognitivo se ha desarrollado una aplicación cuyo diseño presentamos en la sección~\ref{sec:app} e implentación en~\ref{sec:appImpl} del siguiente capítulo.
\item \bsq{\bf Capa cognitiva} El interés del proyecto se centra en el desarollo de esta capa. Es una capa compuesta por otras dos: una primera capa de control donde se recoge toda la inteligencia y propósitos cognitivos y otra capa de actuación que provee de toda la funcionalidad para recibir y enviar datos por cada una de las interfaces de comunicación presentes:
	\begin{enumerate}[i.]
		\item \bsq{\bf Módulo radio cognitiva} Está fuertemente inspirado en los módulos presentes en 
la arquitectura del simulador cognitivo \cite{castaliacwsn} desarrollado en el laboratorio de sistemas
integrados en la \ac{ETSIT} escrito para dotar de estas capacidades a la plataforma \bsq{Castalia}. La 
implementación cuenta con con ciertas peculiaridades que veremos a continuación.

%XXX-jblesa No diria sobre Castalia, sino sobre un simulador cognitivo
%desarrollado en el laboratorio de sistemas integrados. %XXX-cvillar OK.

		\item \bsq{\bf Controladores de interfaz} Esta capa está formada por cada una de las interfaces
presentes en el \sphone{}. La implementación final recoge la interfaz de \wifi{} y \bt{}, 
pero el diseño recoge un número arbitrario debido a que si construimos este módulo siguiendo la interfaz
entre capas, puede ser fácilmente añadida a la arquitectura final.
	\end{enumerate}
\end{enumerate}

A continuación haremos una breve descripción de los diferentes bloques que hemos definido en la arquitectura que conforman el nodo cognitivo. Al ser los procesos entidades que hacen uso más de un bloque, se ha preferido dejar para más adelante (sección~\ref{sec:procesosRed}) su explicación una vez vista la arquitectura. Así se obtienen varios puntos de vista que ayudan a comprender el funcionamiento del nodo.

\subsection{Interfaz Aplicación - Módulo cognitivo}
El apellido cognitivo supone una abstracción en el modelo de comunicaciones de tal forma que el usuario (la aplicación) sea transparente a los parámetros, tiempos o detalles de la comunicación usada para transmitir los datos. Para lograr esta abstracción necesitamos un punto de ruptura que aisle y defina solamente la información estrictamente necesaria a intercambiar entre ambos agentes para poder recrear una \ac{CWSN}. En la sección~\ref{sec:api} se expone la definición de la \ac{API} que debe cumplir el desarrollador de las distintas aplicaciones.\\

Al definir una interfaz permitimos que terceros puedan desarrollar sus propias aplicaciones que usen de este servicio para montar sus comunicaciones, podemos decir que es una interfaz tipo cliente-servidor, donde se permite dar soporte simultáneo a varias aplicaciones. Esto es posible gracias al \var{Gestor de Aplicaciones} que explicamos en la siguiente sección.
%----------

%\subsection{Sensor Manager}
\subsection{Gestor del sensor}
Es el punto de entrada a nuestro servicio cognitivo, el encargado de
recoger las peticiones de las distintas aplicaciones e informar tanto
de la respuesta a la aplicación que lo solicitó, como al resto de
ellas si las hubiese acerca de información común generada en la
\ac{CWSN} donde cooperan. Esto se consigue gracias al submódulo
\var{Gestor de Aplicaciones} que lleva un registro de cada una de las
aplicaciones y permite discernir entre peticiones de éstas. Las
peticiones entrantes son sanetizadas y codificadas para poder disparar
los procesos internos a lo largo de los diferentes módulos y
descodificadas elimando cualquier rasto cognitivo antes de ser
entregadas a la aplicación en cuestión. La presencia del submódulo
\var{Cola} permite, entre otras funciones que se detallarán, encolar
mensajes de aplicación por si estas peticiones no pudiesen ser
atendidas en el mismo momento de la recepción (fundamentalmente debido
a cambios de contexto). Una vez que las
condiciones lo permitan se consulta a esta cola para ver si quedan
ordenes pendientes.
%XXX-jblesa Ten cuidado con las palabras en ingles. Siempre hay que
%intentar buscar palabras en español.
%----------

\subsection{Políticas, optimizador, ejecutor}
Estos tres módulos podemos considerarlos como el cerebro cognitivo, su
interacción es encadenada: la salida de uno es la entrada del siguiente. 
De acuerdo a unas políticas descritas en el módulo \var{Políticas}, el \var{Optimizador}
evalúa el cumplimiento de ellas conforme a valores que recoge del módulo \var{Repositorio}
que sirve como punto concentrador de la información. Esta evaluación puede
generar nuevos valores a almacenar en el \var{Repositorio} y/o la actuación
directa gracias al módulo \var{Ejecutor}.\\


%XXX-jblesa. Exlica lo de la interaccion jerarquica, no lo veo claro.
%XXX-cvillar Quería decir que La politica es quien gobierna al optimizador
% que utiliza al ejecutor para actuar y cumplir así lo que dice la politica.

Para nuestro primer diseño sólo hemos definido una política cognitiva
(ver sección~\ref{subsec:senseAndPolicy}). El módulo \var{Ejecutor} sólo
realiza cambios de contexto, debido a
las limitaciones en la plataforma para ajustar otros parámetros que
finalmente han sido descartados del diseño.

%XXX-jblesa Dos veces seguidas la palabra cambio. XXX-cvillar done.
%----------

\subsection{Repositorio}
\label{subsec:repository}
Este módulo hace las labores de concentración, estructuración y perseverancia de la información. Los demás módulos a menudo se comunican con otros a través del éste, para ello necesitamos almacenar:
%La información que hemos de guardar en el repositorio es:
%XXX-jblesa. Me falta una pequeña frase introductoria. XXX-cvillar done.

\begin{description}
	\item[Información relativa al servicio:] Necesitamos almacenar
          la interfaz actual de comunicaciones y el estado de ésta, así como un valor que nos permita averiguar si el servicio ha sido destruido por causas ajenas para intentar reconstruir la \ac{CWSN} ante una eventualidad. Esta información necesita ser persistente. También almacenamos cuál es el peridodo con la que el optimizador y ejecutor actúan en base al tiempo. Si en vez de sobreescribir esta información hacemos un seguimiento, podemos obtener información acerca de la estabilidad y la adaptabilidad de la red.

\item[Información relativa a los nodos en la red:] Para hacer un mapa
  de la red necesitamos información acerca de qué nodos hay en la red y cómo llegar a ellos. Los datos elegidos son:
	\begin{itemize}
%		\item Identificador del nodo. Un \integer{} asignado al conocer el nodo por primera vez. 
		\item Identificador del nodo, asignado al conocer el nodo por primera vez. 
%		\item Nombre del nodo. Una \String{} representando el nombre con el que se presenta a la red.
		\item Nombre del nodo, sirve para nombrar a un nodo con un lenguaje humano.
%		\item Papel del nodo. Una \String{} cuya codificación es: \bsq{p} para usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconido).
		\item Papel del nodo, para distinguir usuarios primarios y secundarios.
%		\item Tipo de nodo. Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\bsq{u} para valor desconocido).
		\item Tipo de nodo, nos permite clasificar el nodo entre normal, coordinador y otros.
		\item Dirección \ac{MAC} de \bt{} del nodo, este dato identifica al nodo unívocamente.
		\item Dirección \ac{IP} del nodo.
		\item Identificador de su nodo coordinador, Una referencia a un identificador de nodo previamente conocido y que nos permite alcanzar todos sus datos.
	\end{itemize}

\item[Información relativa al sensado:] Los datos recogidos por cada dispositivo los almacenamos siguiendo esta estructura:
	\begin{itemize}
%		\item Identificador del nodo, un \integer{} que nos indica quién es el propietario de la información.
		\item Identificador del nodo, que nos indica quién es el propietario de la información.
%		\item RSSI, un \integer{} con el valor en dBm de la intensidad de señal recogida de la red \wifi{}.
		\item RSSI, el valor en dBm de la intensidad de señal recogida de la red \wifi{}.
%		\item Tasa de envío, un \double{} con el intervalo de tiempo medio de envios en la red.
		\item Tasa de envío, el intervalo de tiempo medio de envios en la red.
		\item Marca de tiempo, una referencia al momento en que estos datos fueron obtenidos.
	\end{itemize}
\end{description}

Estos datos son compartidos con el coordinador quien distribuye esta información sin alteraciones.
El módulo \var{Acceso} no hace ningún filtro de esta información, no obstante el diseño contempla valores por defecto que ocultan la información, por si se quisiese implementar sin demasiados problemas un módulo más complejo. Como veremos la compartición de información es completa salvo los datos de sensado que no son compartidos entre todos los nodos, a excepción de ello el resto de información está distribuida, de tal forma que todos tengan la misma foto aunque no
tengan los mismos valores: los identificadores de los nodos en
cada dispositivo varían, la clave que nos permite sincronizar los diferentes repositorios de los
diferentes nodos recae en la dirección \ac{MAC} de \bt{}.

%XXX-jblesa. Quita dummy y pon algo en español. XXX-cvillar ok, reestructurado un poquito.
%----------

\subsection{Sensado}
Este módulo se asemeja a los ojos de nuestra arquitectura, siguiendo
con el anterior símil del cerebro, una ventana al mundo. Ambos módulos (\var{Sensado} y la tripla formada por: \var{Políticas/Optimizador/Ejecutor})
se conectan a través del \var{Repositorio} que actúa como una especie de bus.

%XXX-jblesa. A que modulos te refieres con ambos modulos? XXX-cvillar discovery & policy/optimizer/executor

Este módulo no sólo recoge parámetros (ver sección~\ref{subsec:senseAndPolicy} para conocer en detalle qué datos son sensados), si no que monitoriza el estado de las diferentes interfaces de comunicaciones. Por esta razón parte de este módulo está muy ligado al controlador de la interfaz. Sin embargo debido a que ciertas políticas necesitan que el optimizador evalue parámetros relativos a interfaces de comunicaciones no activas, se ha sacado del diseño del controlador esta parte para añadirla al modulo \var{Sensado} y que pueda ser manejada en cualquier momento. En la sección~\ref{subsec:btControllerImpl} del siguiente capítulo completamos el por qué de ésto. 
%----------

\subsection{Gestor de Interfaces}
Este módulo es el punto de salida del módulo o servicio cognitivo hacia los controladores. En él confluyen dos planos: el primero para los mensajes de aplicación provenientes del \var{Gestor del Sensor} (plano de datos) y el segundo para la elaboración de señalización proveniente del módulo \var{Ejecutor} o de eventos de red generados en el \var{Gestor de Estados} (ver sección~\ref{subsubsec:stateManager}) (plano de control y gestión).\\

En él se implementan todas las funciones de encaminamiento que son necesarias transmitir a los controladores pues estos no conocen nada del plano cognitivo, son meras palancas de acción. En este módulo también implementamos el submódulo \var{Acceso} encargado de compartir con el resto de nodos parte de nuestro \var{Repositorio} que es enviado por el canal \var{VCC}. 

El diseño del canal \var{VCC} encargado de transmitir toda la información de control y gestión de la \ac{CWSN}, se hubica en la misma red por la que circulan los datos, a diferencia de otros sistemas como el \ac{SS7} \cite{ss7} por razones de simplicidad. De hecho el mismo canal comparte ambos tráficos, la manera de distinguirlos recae en el etiquetado con la que van codificados los distintos mensajes de red. Sin embargo, la arquitectura no cierra las puertas a que el plano de datos y el de control sean transmitidos en distintas interfaces de comunicación, por ejemplo datos en \wifi{} y señalización en \bt{}.

%----------

\subsection{Interfaz Módulo Cognitivo - Controlador}
\subsubsection{Comunicación hacia controlador: invocación de métodos}
La forma de comunicarse con el controlador de la interfaz de comunicación es mediante la invocación directa de métodos del propio controlador. Para homogeneizar la interacción entre servicio y controlador haciendo que ésta se produzca de forma similar con todas las interfaces, sus respectivos controladores deben implementar una serie de métodos cuya funcionalidad se adecue a las singularidades pero que mantenga unos puntos de entrada y salida a poder ser iguales. Se ha dedicido que estos métodos sean llamadas asíncronas que no devuelvan ningún valor. La respuesta se obtiene en el \var{Gestor de Interfaces} una vez el proceso desencadenado en el controlador decide comunicar algo gracias su \var{Gestor de Estados}. Los métodos que un controlador debe implementar para cumplir con la interfaz en este sentido son:
\begin{description}
	\item[start()]\hfill {\sc Método de inicialización}\\[7pt]Este método nos permite configurar el controlador teniendo en cuenta los requerimientos que tenga el módulo o servicio cognitivo.
	\item[stop()]\hfill{\sc Método de destrucción}\\[7pt]Gracias a él se liberan todos los recursos (menos los relacionados con el módulo \var{Sensado} para permitir que aunque no este activa se sigan obteniendo datos de sensado del espectro).
	\item[write()]\hfill{\sc Método para enviar datos o señalización}\\[7pt]Para escribir cualquier tipo de información sobre la red:
	\begin{itemize}
		\item\bsq{Plano de datos}: canal de datos.
		\item\bsq{Plano de control}: canal \var{VCC}.
	\end{itemize}
\end{description}
%----------

\subsubsection{Comunicación hacia módulo: Gestor de estados}
\label{subsubsec:stateManager}
Permite establecer una comunicación uniderecional basada en mensajes desde los distintos controladores hacia el servicio en cualquier momento de tiempo. Estos mensajes son consecuencia de procesos bien disparados por el servicio al invocar métodos del controlador (desde el módulo \var{Ejecutor} y/o \var{Gestor de Interfaces}) o bien originados en el propio controlador al tratarse de un evento de red, reflejando el estado en el que se encuentra el controlador.

\paragraph{WiFi} Los diferentes estados y eventos en los que pueden estar la interfaz \wifi{}:%\\
\smTableInit{\textit{Wi-Fi State Manager}}
	\smTableRow{STATE\_none}{event\_no\_device\_changes}	
	\smTableRow{STATE\_listen}{EVENT\_ENTERED\_IN\_NETWORK}
	\smTableRow{STATE\_sending}{EVENT\_LOST\_NODE}
	\smTableRow{STATE\_receiving}{EVENT\_HELLO\_NOT\_REACHED}
\smTableEnd{Gestor de estados WiFi}{wifiStateManager}
%~\\
\paragraph{Bluetooth} De manera análoga los diferentes estados y eventos en los que pueden estar la interfaz \bt{}:
\smTableInit{\textit{Bluetooth State Manager}}
	\smTableRow{STATE\_none}{event\_no\_device\_changes}	
	\smTableRow{STATE\_listen}{EVENT\_new\_device}
	\smTableRow{STATE\_connecting}{EVENT\_device\_LOST}
	\smTableRow{STATE\_connected}{EVENT\_CONNECTING\_DEVICE\_FAILED}
	\smTableRow{STATE\_sending}{EVENT\_CONNECTION\_ALREADY\_EXISTING}
	\smTableRow{STATE\_receiving}{}
\smTableEnd{Gestor de estados Bluetooth}{btStateManager}

Esta información recibida por cada controlador se mapea con los eventos y estados que veremos en la \ac{API} (ver sección~\ref{subsec:serviceInformation}) de forma que las singularidades de cada interfaz sean ocultadas más allá del servicio.
%----------
                                                     
%-------------------------------------------------------------------
\section{API: Definición, Cómo montar una aplicación sobre el servicio cognitivo}
%-------------------------------------------------------------------
\label{sec:api}
En esta sección se explica cada detalle de la interfaz Aplicación - Módulo cognitivo en ambos sentidos. Su cumplimiento es necesario para desarollar una aplicación que interactue de forma correcta con el módulo o servicio cognitivo. La forma de interactuar con éste se basa en, como se verá en \ref{sec:detallesImplementacion}, el intercambio de mensajes a través de los objetos \textit{Messenger} y \textit{Handler} provistos por \android{}. Estos mensajes provocan el disparo de ciertos procesos en el servicio que responderá, si procede, en cuanto el resultado esté listo. Son llamadas por tanto asíncronas. De igual modo, el servicio entregará mensajes a las aplicaciones en cualquier momento sin que estás hayan solicitado nada.\\

La aplicación que haga uso del modelo no necesita cumplir más requisitos que la de manejar los distintos mensajes que le entrege el servicio en cualquier instante de tiempo y la de almacenar la lista de nodos formada por el par (identificador, nombre) entregada por el servicio y modificada en cada evento que lo requiera. La confección de algunos mensajes de la \ac{API} requieren que sean informados con algunos valores de la lista de nodos, por lo que la aplicación debe tener accesible esta lista ya que no hay una manera activa de pedirla al servicio.

Los mensajes que se intercambian tienen un campo llamado \textit{what} que resume el proposito de éste, más una serie de añadidos experesados en forma de parámetros y extras que conforman y describen el proceso que está ocurriendo.
Este campo \textit{what} es un \integer{} único que define el número diferente de mensajes tipo que se intercambian, entre éstos habrá algunos que sólo existan en un sentido de la comunicación y otros que aparezcan en ambos sentidos.

\apiTableInit{Mensajes tipo intercambiados entre Aplicación y servicio}
	\apiTableRow{register\_client}{\phantom{0}1}	
	\apiTableRow{unregister\_client}{\phantom{0}2}
	\apiTableRow{register\_exchange}{\phantom{0}3}
	\apiTableRow{OUTGOING\_CONTENT}{\phantom{0}4}
	\apiTableRowNotImplemented{OUTGOING\_CONTENT\_PROGRESS}{\phantom{0}5}
	\apiTableRow{OUTGOING\_CONTENT\_RESULT}{\phantom{0}6}
	\apiTableRowNotImplemented{INCOMING\_CONTENT\_PROGRESS}{\phantom{0}7}
	\apiTableRow{INCOMING\_CONTENT}{\phantom{0}8}
	\apiTableRow{SERVICE\_INFORMATION}{\phantom{0}9}
	\apiTableRow{ERROR\_MESSAGE}{10}
	\apiTableRow{QUEUED\_MESSAGE}{11}
	\apiTableRow{CONNECT\_TO\_VIA\_BT}{12}
	\noalign{\vskip 0.25cm}
	\apiTableRow{{\footnotesize WORKAROUND\_WHAT\_TO\_REPLY}}{20}
	\apiTableRow{{\footnotesize WORKAROUND\_ASK\_RESPONSE}}{21}
	\apiTableRow{{\footnotesize WORKAROUND\_CONTEXT\_CHANGE}}{22}
	\apiTableRow{{\footnotesize WORKAROUND\_PENDINGMESSAGE\_INJECTION}}{23}
	\apiTableRow{{\footnotesize WORKAROUND\_PENDINGMESSAGE\_DISPOSAL}}{24}
\apiTableEnd{Mensaje tipo}{apiMessages}
 Las filas en gris corresponden a mensajes reservados no implementados como son las constantes \Scst{OUTGOING\allowbreak\_CONTENT\allowbreak\_PROGRESS} (5) y \Scst{INCOMING\allowbreak\_CONTENT\allowbreak\_PROGRESS} (7). Están pensadas para una posible segmentación de los mensajes de aplicación por parte del servicio. En caso de segmentación la forma de informar a la aplicación del progreso del envío de segmentos (y de la recepción de éstos) se haría con este tipo de mensajes. Las filas precedidas por \Scst{WORKAROUND} son comportamientos necesarios para disparar procesos manualmente, corresponden por tanto a una interfaz de \textit{test} no necesario su cumplimiento para el correcto funcionamiento.
%----------
\subsection{Conectarse al servicio}
\label{subsec:apiStart}
Para poder entregar y recibir mensajes necesitamos una referencia al
\textit{Messenger} del servicio, esta referencia la obtenemos tras
hacer una petición de unión o atadura (\textit{bind}) llamando al método \textit{bindService()} con un \textit{Intent} a la clase:
\begin{verbatim}
es.upm.die.lsi.pfc.CWSNoA.CognitiveLayer_specific_Service.class
\end{verbatim}
En la petición de \textit{bind} también se pasa como parámetro un objeto de la clase \textit{ServiceConnection} que el sistema \android{} llama cuando ha establecido la conexión. \android{} arrancará el servicio si éste no lo estaba ya y nos devolverá como objeto \textit{IBinder} una instancia del \textit{Messenger} del servicio. 
Por motivos de seguridad la aplicación que realice la petición de \textit{bind()} requiere la declaración en su archivo \bsq{\textit{manifest}} la aceptación del permiso:
\begin{verbatim}
es.upm.die.lsi.pfc.CWSNoA.permission.COGNITIVE_SERVICE
\end{verbatim}
Este permiso informa al usuario final que usa la aplicación del uso posible de la modificación de la interfaz \bt{} y \wifi{} sin la intervención de éste.

Una vez recuperada la referencia procedemos al registro de la aplicación en el servicio, para ello iniciamos un proceso de \textit{handshaking}. El primer mensaje no lleva ningún dato adicional, dicta de esta forma (ver tabla~\ref{tab:registerClientMessage}).

\messageTableInit{\appToServ}{1 =\\ \footnotesize{REGISTER\_CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje registro cliente}{registerClientMessage}

Acto seguido debemos informar sobre parámetros de nuestra aplicación al servicio con el envío de un mensaje con la siguiente información: 
\begin{description}
\item[Papel de nodo] En el campo \textit{arg1} del mensaje. \bsq{0} para indicar que somos un nodo secundario y \bsq 1 para indicar que nuestro papel es primario.
\item[Código de aplicación] Como extra del mensaje incluimos una \String{} con la clave ``appCode'' indicando qué aplicación somos, para intercambiar mensajes cuyo código de aplicación coincida.
\end{description}
A través del mensaje descrito en la tabla~\ref{tab:registerExchangeMessage}

\messageTableInit{\appToServ}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{0=secundario / 1=primario}{\nc}{\textit{null}}{\messApp{}}
\messageTableExtra{appCode}{Una string con el código de aplicación}
\messageTableEnd{Mensaje entrega parámetros de aplicación}{registerExchangeMessage}

Tras esto el servicio nos responderá con un mensaje igual tipo \Scst{REGISTER\_EXCHANGE}, pero del que puede haber dos variantes dependiendo de cuál fuera la situación del servicio. La forma fácil de identificar el tipo de respuesta es con la información devuelta en el campo \textit{obj} del mensaje. 

Se trata de un valor booleano, si obtenemos un \false{} corresponde al caso de que no estabamos cooperando en una \ac{CWSN} cuando nos registramos en el servicio. Es probable que nos hayan llegado entre tanto otros mensajes del tipo \Scst{SERVICE\_INFORMATION} debido a procesos internos del servicio relacionados con la configuración y la entrada en la red. El detalle de éste se puede ver en la tabla~\ref{tab:endHandshakingNotCWSNMessage}

\messageTableInit{\servToApps}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{False}}{\nc{}}
\messageTableExtra{nodeRole}{Papel del nodo}
\messageTableExtraAddrow{nodeType}{Tipo de nodo}
\messageTableExtraAddrow{periodTask}{Periodo tarea cognitiva}
\messageTableExtraAddrow{nodeName}{Nombre del nodo en la red}
\messageTableExtraAddrow{errorSetupInterface}{Resultado configuración interfaz}
\messageTableEnd{Mensaje finalización de \textit{handshaking}: CWSN no establecida}{endHandshakingNotCWSNMessage}

La información de cada campo:
\begin{description}
\label{itm:serviceParamsToAll}
	\item[Arg1: Estado de la interfaz] Un entero cuyos valores corresponden a:
	\begin{enumerate}
	 \setcounter{enumi}{-1}
		\item \Scst{INTERFACE\_STATE\_DOWN}, la interfaz de comunicación no está configurada.
		\item \Scst{INTERFACE\_STATE\_IDLE}, la interfaz está configurada pero no estamos cooperando en red.
		\item \Scst{INTERFACE\_STATE\_IDLE\_NETWORKING}, situación de reposo cooperando en \ac{CWSN}.
		\item \Scst{INTERFACE\_STATE\_CONNECTING}, nos estamos conectando a otro nodo (sólo en \bt{}).
		\item \Scst{INTERFACE\_STATE\_SENDING}, estamos enviado datos a través de la interfaz.
		\item \Scst{INTERFACE\_STATE\_RECEIVING}, estamos reciviendo datos.
	\end{enumerate}
	\item[Arg2: Interfaz] Un entero cuyos valores corresponden a:
	\begin{enumerate}
		\setcounter{enumi}{-1}
		\item \bt{}.
		\item \wifi{}.
		\item \textcolor{notImplemented}{\textit{Mobile}, no implementado.}
		\setcounter{enumi}{-2}
		\item Desconocido, devuelto en el transcurso de cambio de contexto.
	\end{enumerate}
	\item[Obj: \false{}] Un valor booleano cuyo valor nos indica que no estabamos cooperando con otros nodos tras la recepción del mensaje \Scst{REGISTER\_EXCHANGE} por lo tanto el servicio ha configurado de nuevo la interfaz para disparar los procesos de entrada en la red (ver sección~\ref{subsec:configInterface}).
	\item [EXTRAS] Campos \textit{extra} con el resto de parametros cuando el valor \textit{obj} es \false{}:
	\begin{description}
		\item[Papel del nodo] Un \integer{} que representa el papel del nodo en la red, se recupera con la clave ``nodeRole'':
		\begin{enumerate}
			\setcounter{enumi}{-1}
			\item Secundario.
			\item Primario.
		\end{enumerate}
		\item[Tipo de nodo] Un \integer{} que representa el tipo de nodo, se recupera con la clave ``nodeType'':
		\begin{enumerate}
			\setcounter{enumi}{-1}
			\item Normal.
			\item Coordinador.
			\item \textcolor{notImplemented}{Coordinador temporal en \bt{}, no implementado. En todo caso este valor no es selecionable nunca por el usuario/servicio.}
			\setcounter{enumi}{-2}
			\item Desconocido, valor por defecto (si obtenemos este valor nos encontramos en situación de error).
		\end{enumerate}
		\item[Periodo tarea cognitiva] Un \double{} con el que se nos informa cada cuánto el servicio realiza la tarea cognitiva (sensado, toma de decisiones...). Se recupera con la clave ``periodTask''.
		\item[Nombre del nodo en la red] Una \String{} con la que el servicio nos informa de cómo nos conocen los otros nodos en la red. Se recupera con la clave ``nodeName''.
		\item[Resultado configuración interfaz] Un valor booleano cuya clave para obtenerlo es ``errorSetupInterface'' cuyo valor significa:
		\begin{itemize}
			\item \true{} se ha producido un error mientras la configuración de la interfaz.
			\item \false{} todo ha ido OK en el proceso de configuración.
		\end{itemize}
	\end{description}
\end{description}

Si por el contrario el valor obtenido en el campo \textit{obj} es \true{} significa que el servicio ya se encontraba cooperando en una \ac{CWSN} cuando registramos nuestra aplicación por lo que no es necesario ninguna configuración y recibimos una respuesta casi inmediata (a diferencia del caso anterior) con la siguente disposición (ver tabla~\ref{tab:endHandshakingInCWSNMessage}).

\messageTableInit{\servToApp}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{True}}{\nc{}}
\messageTableExtra{nodeRole}{Papel del nodo}
\messageTableExtraAddrow{nodeType}{Tipo de nodo}
\messageTableExtraAddrow{periodTask}{Periodo tarea cognitiva}
\messageTableExtraAddrow{nodeName}{Nombre del nodo en la red}
\messageTableExtraAddrow{appCode}{Código de la aplicación}
\messageTableExtraAddrow{nodeIdList}{Array de \integers{} con los identificadores de los nodos}
\messageTableExtraAddrow{nodeNameList}{Array de \String{} con los nombres de los nodos}
\messageTableEnd{Mensaje finalización de \textit{handshaking}: CWSN establecida}{endHandshakingInCWSNMessage}

La información recibida es prácticamente igual salvo el campo \textit{obj} que nos devuelve el valor \true{} lo que provoca que este mensaje sólo lo reciba esta aplicación en exlcusiva y un cambio en los extras, que dejan de inlcuir el \bsq{Resultado configuración interfaz} pero incluyen dos nuevos:

\begin{description}
	\item[Código de la aplicación] Un \String{} que representa el código de la aplicación. El servicio nos hace un \bsq{eco} de este valor para saber que se ha configurado bien. Se recupera con la clave ``appCode''.
	\ListaNodosItem{}
\end{description}
%------------
\subsection{Enviar datos}
El envío de datos a través de la red cognitiva consiste en la entrega al servicio de un mensaje codificado con esta información:

\begin{description}
	\item[Payload] El contenido del mensaje lo adjuntamos en el campo \textit{obj} del mensaje, debe ser o poder codificarse como una \String{}.
	\item[Lista nodos] Los nodos a quién va dirigido el mensaje se codifican como una lista de identificadores, instancia de un \textit{ArrayList<Integer>} y debe ir como un extra guardado con la clave ``addressedNodes''. El identificador del nodo nos los devuelve el propio servicio en mensajes tipo \Scst{REGISTER\_EXCHANGE} en situación de \textit{networking} y en mensajes tipo \Scst{SERVICE\_INFORMATION}. Como convención, el identificador es un número natural. El valor \bsq 0 puede ser utilizado por el programador de aplicaciones como ausencia de nodos (útil para rellenar \textit{listviews} o \textit{spinners}), el \bsq1 es un valor reservado por el servicio que sirve para enviar el mensaje a todos los nodos. Los demás números corresponden cada uno a un nodo distinto. 

Aunque no hay restricciones la manera correcta de enviar el mensaje a todos es rellenar la lista sólo con el identificador \bsq{1}.
\end{description}

El detalle del mensaje enviado al servicio es (ver tabla~\ref{tab:outgoingContent}).

\messageTableInit{\appToServ}{4 =\\ \scriptsize{OUTGOING\_CONTENT}}{\nc{}}{\nc{}}{\textit{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{}s con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje para el envío de datos}{outgoingContent}
%-------------
\subsection{Confirmación envío de datos}
\label{subsec:apiAck}
Cuando hemos enviado datos a través del servicio, la forma que tiene éste de informarnos que el proceso de envío ha terminado es con la entrega del siguiente mensaje, del que podremos obtener las estadísticas de envío (ver tabla~\ref{tab:outgoingContentResultApp}).

\messageTableInit{\servToApp}{6 =\\ \scriptsize{OUTGOING\_CONTENT \_RESULT}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{payload}}{\nc{}}
\messageTableExtra{IdsNotDelivered}{Un array de \integer{}s con los identificadores de los nodos a los cuales no les ha llegado el mensaje}
\messageTableExtraAddrow{NamesNotDelivered}{Un array de \String{} con los nombres de los nodos a los cuales no les ha llegado el mensaje}
\messageTableEnd{Mensaje resultado envío de datos presentado a la aplicación}{outgoingContentResultApp}

La información que podemos leer de este mensaje es:
\begin{description}
	\item[Arg1: número mensajes escritos OK] Un \integer{} que nos indica en cuántos nodos se ha entregado el mensaje correctamente.
	\item[Arg2: número mensajes escritos NOK] Un \integer{} con el número de nodos los cuales no han recibido el mensaje.
	\item[Obj: payload] El contenido que se ha enviado por la red, esto sirve a la aplicación para relacionar el envío con la contestación. 
	\item[EXTRAS] Si el campo \textit{arg2} es distinto de cero incluimos los siguientes extras:
	\begin{description}
	\ListaNodosNoDeliveredItem{}

	La motivación de enviar tanto el identificador como el nombre es porque si hay algún fallo en la entrega del mensaje antes de la confirmación de entrega, habremos recibido un mensaje indicándonos la pérdida de algún nodo. La aplicación entonces puede haber borrado de su lista el nodo implicado que al intentar recuperar ahora (en la recepción de la confirmación) el nombre le dará error al no encontrarse ya en su lista.
	\end{description}
\end{description}

El tiempo de entrega de esta confirmación no está acotado, depende de la complejidad en el envío y de si ha habido encolamiento en cualquiera de los segmentos de red por los que ha pasado el mensaje.

%----------
\subsection{Recibiendo datos}
En cuanto el servicio haya recibido datos que le interesen a nuestra aplicación (es decir el código de aplcación sea el mismo con el que va marcado el mensaje de datos) nos enviará un mensaje con el contenido (en el campo \textit{obj} del mensaje) y el identificador del nodo que lo envió, un extra que se recupera con la clave ``device\_id'' (ver tabla~\ref{tab:incomingContent}).

\messageTableInit{\servToApp}{8 =\\ \scriptsize{INCOMING\_CONTENT}}{\nc{}}{\nc{}}{\textit{payload}}{\nc{}}
\messageTableExtra{device\_id}{Un \integer{} que identifica al nodo que ha enviado el mensaje}
\messageTableEnd{Mensaje datos recibidos}{incomingContent}

\subsection{Recibir información del servicio}
\label{subsec:serviceInformation}
El servicio utiliza esta vía como principal para informar acerca de la evolución de sus procesos internos. Gracias a su gestor de estados entre los controladores de las interfaces y éste, los eventos y estados se codifican y aglutinan para informar a todas las aplicaciones registradas acerca de éstos y cuándo se producen. 

Aunque parte de esta información (estado de la interfaz y lista de nodos) se distribuya también en otros mensajes, es aquí dónde se plasman todos los cambios de estado que haya a lo largo de un proceso completo. En otros mensajes enviados por el servicio la información aportada tan sólo corresponde al momento final del proceso.

\apiTableInit{Diferentes estados en los que se pueden encontrar las interfaces}
	\apiTableRow{INTERFACE\_STATE\_DOWN}{0}	
	\apiTableRow{INTERFACE\_STATE\_IDLE}{1}
	\apiTableRow{INTERFACE\_STATE\_IDLE\_NETWORKING}{2}
	\apiTableRow{INTERFACE\_STATE\_CONNECTING}{3}
	\apiTableRow{INTERFACE\_STATE\_SENDING}{4}
	\apiTableRow{INTERFACE\_STATE\_RECEIVING}{5}
\apiTableEnd{Estados de la interfaz de comunicación}{states}

Los eventos se producen entre los dos nodos invulcrados directamente en el proceso. Por ejemplo, la inclusión de un nuevo nodo produce un evento en los controladores de la interfaz de los dos nodos implicados, el resto de nodos se enteran del evento con mensajes de señalización (que veremos en la sección \ref{sec:procesosRed}) que para los controladores son tratados de la misma manera que otros mensajes de red. La mayoría de eventos surgen del propio controlador de la interfaz, otros sin embargo son fruto de la interpretación de mensajes de señalización como son los cambios de contexto.

\apiTableInit{Eventos producidos en la red}
	\apiTableRow{EVENT\_INTERFACE\_NO\_CHANGES}{0}	
	\apiTableRow{EVENT\_INTERFACE\_NEW\_NODE}{1}
	\apiTableRow{EVENT\_INTERFACE\_LOST\_NODE}{2}
	\apiTableRow{EVENT\_INTERFACE\_CANNOT\_CONNECT}{3}
	\apiTableRow{EVENT\_INTERFACE\_ALREADY\_CONNECTED}{4}
	\apiTableRow{EVENT\_INTERFACE\_SWITCH\_TO\_BT}{5}
	\apiTableRow{EVENT\_INTERFACE\_SWITCH\_TO\_WIFI}{6}
	\apiTableRowNotImplemented{EVENT\_INTERFACE\_SWITCH\_TO\_MOBILE}{7}
	\apiTableRow{EVENT\_INTERFACE\_END\_SWITCHING}{8}
	\apiTableRow{EVENT\_UPDATE\_LIST\_NODES}{9}
\apiTableEnd{Eventos que se pueden producir en la red}{events}


  Estos mensajes son puramente informativos, no requieren de ningún procesamiento por parte de las aplicaciones y se presentan con esta estructura (ver tabla~\ref{tab:serviceInformation}).

\messageTableInit{\servToApps}{9 = \scriptsize{SERVICE\\\_INFORMATION}}{interfaz}{\nc{}}{modificación lista nodos}{\nc{}}
\messageTableExtra{coordinator}{Una \String{} con el nombre del nodo que es nuestro coordinador. Si somos el cooridnador este campo viene informado a \textit{null}}
\messageTableExtraAddrow{triggerNodeName}{Una \String{} con el nombre del nodo que ha disparado el evento. Si no existe tal nodo no se incluye este campo en el mensaje}
\messageTableExtraAddrow{state}{Una \integer{} con el estado de la interfaz}
\messageTableExtraAddrow{event}{Una \integer{} con el evento producido en la red}
\messageTableExtraAddrow{nodeIdList}{Un array de \integers{} con los identificadores de los nodos que forman la red en estos momentos}
\messageTableExtraAddrow{nodeNameList}{Un array de \String{} con los nombres de los nodos que forman la población actual}
\messageTableEnd{Mensaje información evento/estado por parte del servicio}{serviceInformation}

El detalle de cada uno de los campos es:
\begin{description}
\label{itm:serviceInformation}
	\item[Arg1: Interfaz] Un \integer{} cuyos valores corresponden a:
	\begin{enumerate}
		\setcounter{enumi}{-1}
		\item \bt{}.
		\item \wifi{}.
		\item \textcolor{notImplemented}{\textit{Mobile}, no implementado.}
		\setcounter{enumi}{-2}
		\item Desconocido, devuelto en el transcurso de cambio de contexto.
	\end{enumerate}
	\item[Obj: modificación lista nodos] Un valor booleano que nos indica si ha habido un cambio en la lista de nodos.
	\item [EXTRAS] Campos \textit{extra} con el resto de parámetros:
	\begin{description}
		\item[Coordinador] Una \String{} con el nombre del nodo coordinador. Informado a \textit{null} si somos nosotros el coordinador de la red.		
		\item[Nodo causante del evento] Una \String{} con el nombre del nodo que ha causado el evento. Esta información es más útil para el nodo coordinador, pues para el normal el nodo causante siempre será su coordinador.
		\item[Estado interfaz] Un \integer{} cuyos valores son los vistos en la tabla~\ref{tab:states}, se obtiene con la clave ``state'':
		\begin{enumerate}
	 		\setcounter{enumi}{-1}
				\item \Scst{INTERFACE\_STATE\_DOWN}, la interfaz de comunicación no está configurada.
				\item \Scst{INTERFACE\_STATE\_IDLE}, la interfaz está configurada pero no estamos cooperando en red.
				\item \Scst{INTERFACE\_STATE\_IDLE\_NETWORKING}, situación de reposo cooperando en \ac{CWSN}.
				\item \Scst{INTERFACE\_STATE\_CONNECTING}, nos estamos conectando a otro nodo (sólo en \bt{}).
				\item \Scst{INTERFACE\_STATE\_SENDING}, estamos enviado datos a través de la interfaz.
				\item \Scst{INTERFACE\_STATE\_RECEIVING}, estamos reciviendo datos.
		\end{enumerate}
		\item[Evento producido] Un \integer{} cuyos valores son los vistos en la tabla~\ref{tab:events}, se recupera con la clave ``event'':
		\begin{enumerate}
				\setcounter{enumi}{-1}
				\item \Scst{EVENT\_INTERFACE\_NO\_CHANGES}, este evento es la ausencia de evento. Hay cambios en el estado de la interfaz que no son provocados por un evento, para estas casuisticas el evento que le asignamos es el de \bsq{no cambio}.	
				\item \Scst{EVENT\_INTERFACE\_NEW\_NODE}, este evento surge cuando el coordinador nos conecta a la red. Se genera en ambos extremos (en el coordinador y el nodo normal que empieza a formar parte de la red).
				\item \Scst{EVENT\_INTERFACE\_LOST\_NODE}, se genera al perder la comunicación con un nodo (entre coordinador y normal, aparece este evento al igual que el anterior en ambos extremos).
				\item \Scst{EVENT\_INTERFACE\_CANNOT\_CONNECT}, surge en el nodo que ha intentado conectarse a otro y no ha podido.
				\item \Scst{EVENT\_INTERFACE\_ALREADY\_CONNECTED}, surge cuando el coordinador intenta conectarse a un nodo al cual ya está conectado (sólo en \bt{}). 
				\item \Scst{EVENT\_INTERFACE\_SWITCH\_TO\_BT}, evento que surge cuando recibimos o disparamos (coordinador) el cambio de contexto hacia \bt{}.
				\item \Scst{EVENT\_INTERFACE\_SWITCH\_TO\_WIFI}, evento que surge cuando recibimos o disparamos (coordinador) el cambio de contexto hacia \wifi{}.
				\item \textcolor{notImplemented}{\Scst{EVENT\_INTERFACE\_SWITCH\_TO\_MOBILE}, no implementado, de manera análoga cuando la interfaz de destino es la móvil.}
				\item \Scst{EVENT\_INTERFACE\_END\_SWITCHING}, se genera al terminar el cambio de contexto.
				\item \Scst{EVENT\_UPDATE\_LIST\_NODES}, cuando es necesaria una actualización de la lista de nodos que no haya sido provocada por algún evento anterior.
			\end{enumerate}
			\ListaNodosItem{}
	\end{description}
\end{description}

%---------
\subsection{No cumplimiento de la API: mensajes de error}
El servicio tiene una manera de avisar a las aplicaciones cuando éstas no cumplen con la \ac{API} o internamente surge un error cuyo resultado es conveniente comunicar para poner en conocimiento que el proceso actual se ha detenido. Este aviso se realiza mediante el envío de mensajes de error que están dirigidos a quién lo ha provocado, o puesto en conocimiento de todos según interese.

Es una sección experimental que sólo recoge los errores más importantes. No se ha hecho un estudio exhaustivo sobre el comportamiento maligno de las aplicaciones para intentar manejar y sanitizar todos los valores entregados por éstas. Algunos de los errores de los que son manejados por el servicio se listan en la tabla~\ref{tab:errors}

\apiTableInit{Mensajes de error devueltos por el servicio}
	\apiTableRow{CODE\_ERROR\_ILLEGAL\_ARGUMENT}{1}	
	\apiTableRow{CODE\_ERROR\_NODE\_NO\_EXISTS}{2}
	\apiTableRow{CODE\_ERROR\_INTERNAL}{3}
	\apiTableRow{CODE\_ERROR\_NOT\_IN\_NETWORK}{4}
	\apiTableRow{CODE\_ERROR\_MESSAGE\_NOT\_RECOGNIZED}{5}
	\apiTableRow{CODE\_ERROR\_ILLEGAL\_PAYLOAD}{6}
\apiTableEnd{Mensajes de error por el no cumplimiento de la API}{errors}

Los errores son transmitidos a la aplicación o las apliaciones por medio de este tipo de mensaje (ver tabla~\ref{tab:errorMessage}), en él se amplia la descripción del error mediante una \String{} en el campo \textit{obj}.

\messageTableInit{\servToApp}{10 =\\ \scriptsize{ERROR\_MESSAGE}}{código de error}{\nc{}}{Descripción del error}{\nc{}}
\messageTableEnd{Mensaje de error recibido del servicio}{errorMessage}

%---------
\subsection{Mensajes encolados}
Puede darse la circustancia de que al realizar el envío de datos al servicio, éste no pueda enviarlo por la red debido a que se encuentre en un cambio de contexto. En estas ocasiones los mensajes recibidos por parte de las aplicaciones son encolados siguiendo el modelo \ac{FIFO}, esto quiere decir que se respeta el orden de llegada y serán entregados en el mismo orden cuando se proceda su salida. 

Cuando el servicio retoma el envío de estos mensajes encolados, envíamos a la aplicación dueña del mensaje un informe previo a su envío, indicando cuáles de los nodos destinatarios siguen en la red y cuáles no. En el caso de haber enviado el mensaje a todos, este informe nos devuelve la lista completa de nodos a los cuales le hemos intentado enviar el mensaje, ya que puede haber cambios en la población entre el momento en el cual se envío y el momento en el que el servicio le da salida. El detalle del mensaje recibido en la aplicación es (ver tabla~\ref{tab:queuedMessage}).

\messageTableInit{\servToApp}{11= \scriptsize{QUEUED\_MESSAGE}}{número enviados}{número no enviados}{\textit{payload}}{\nc{}}
\messageTableExtra{IdsTriedToSend}{Un \textit{array} de \integers{} con los identificadores de los nodos los cuales siguen en red}
\messageTableExtraAddrow{NamesTriedToSend}{Un \textit{array} de \String{} con los nombres de los nodos siguen en red}
\messageTableExtraAddrow{IdsNotDelivered}{Un \textit{array} de \integers{} con los identificadores de los nodos que no hemos enviado el mensaje por no encontrarse en la red}
\messageTableExtraAddrow{NamesNotDelivered}{Un \textit{array} de \String{} con los nombres de los nodos que no hemos enviado el mensaje por no encontrarse en la red}
\messageTableEnd{Mensaje informe previo a la salida de mensaje encolado}{queuedMessage}

Los campos \textit{extra} son dos pares de \textit{arrays} ligados por la posición al igual que ocurre con la lista de nodos de otros mensajes. Los dos primeros nos informan de cúales son los nodos a los cuales se va a proceder al envío del mensaje y los dos últimos están rellenos de los nodos que al no encontrarse en este momento en situación de red hemos obviado su envío para evitar envíos fallidos innecesarios.

Al recibir este mensaje quedamos a la recepción del mensaje de confirmación de envío explicado en~\ref{subsec:apiAck}
%---------
\subsection{Actualización de parámetros}
\label{subsec:apiUpdateParams}
Si en algún momento queremos cambiar nuestro papel en la red o recibir la información de otras aplicaciones de la red cognitiva tan sólo necesitamos cumplir cierta parte del flujo del \textit{handshaking} para conectarse al servicio (ver~\ref{subsec:apiStart}). Empezaremos enviando directamente el segundo mensaje, con nuestos nuevos parámetros al servicio con el mensaje ya visto en la tabla~\ref{tab:registerExchangeMessage}, tras esto esperaremos la respuesta dónde veremos si realmente se han podido actualizar los valores que les entregamos. Si cuando decidimos actualizar estabamos en situación de \textit{networking} es posible que los valores no hayan podido actualizarse debido a que penalizan o entran en conflicto con las necesidades de las otras aplicaciones ya registradas. En este caso sólo se permite un cambio de papel \bsq{secundario} a \bsq{primario}, pero no al revés. El \bsq{código de aplicación} se actualiza siempre no importando la situación.
%----------
\subsection{Desconectarse del servicio}
Llegado el momento de desconectarnos de la red deberemos enviar al servicio un mensaje del tipo \textit{unregister client} para que el servicio sea informado de forma directa, ya que la mera petición de \textit{unbind} no garantiza que éste se entere y si se entera, es para su propia destrucción por parte de \android{}. La composición de este mensaje es lo podemos ver en la tabla~\ref{tab:unregisterClientMenssage}

\messageTableInit{\appToServ}{2 =\\ \footnotesize{UNREGISTER \_CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje desregistro cliente}{unregisterClientMenssage}

Tras este envío ya podemos deshacer el enlace entre aplicación y servicio de manera segura.
%---------
\subsection{Entrada de nodos en la red cuando la interfaz es \bt{}}
\label{subsec:connectViaBT}
Por motivos de implementación, si queremos introducir un nuevo nodo en la red cuando la interfaz de comunicación es \bt{}, debe ser el coordinador quién de el primer paso. Para ello en el nodo coordinador enviamos el siguente mensaje (ver tabla~\ref{tab:connectToBT}).

\messageTableInit{\appToServ}{12 = \footnotesize{CONNECT\_TO\\\_VIA\_BT}}{\nc{}}{\nc{}}{dirección MAC / identificador nodo}{\messApp{}}
\messageTableEnd{Mensaje contectar a nodo en \bt{} }{connectToBT}

El campo \textit{obj} puede recibir dos tipos de argumentos:
\begin{itemize}
 \item Una \String{} con la dirección MAC de \bt{} del nodo.
 \item Un \integer{} con el identificador el nodo, si éste no está en la base de datos enviaremos un mensaje de error a la aplicación.
\end{itemize}

Acto seguido el servicio intentará si la interfaz de comunicación actual es \bt{} conectarse al citado nodo bien por medio de su dirección \ac{MAC} o porque hemos podido recuperar ésta de la base de datos. Si la interfaz no es \bt{} devolveremos un error del tipo \Scst{CODE\_ERROR\allowbreak\_ILLEGAL\_ARGUMENT}

\paragraph{Fallo conocido} El \textit{HashMap} del controlador de \bt{} donde guardamos las hebras de conexión pierde su contenido tras añadir un valor, la primera vez que se inicia el servicio. Instrucciones para detectar el fallo:
\begin{enumerate}
	\setcounter{enumi}{-1}
	\item Vaciar la base de datos y matar el proceso. O instalar la aplicación.
	\item Sin cerrar la aplicación (no destruir el servicio) intentar conectarse desde un coordinador a ésta.
	\item Observar que cuando el nodo intenta responder al coordinador con su información o intenta enviar un escaneo se lanza un evento de pérdida por no poder recuperar del \textit{HashMap} la hebra de conexión utilizada.
\end{enumerate}

%---------
\subsection{La API oculta: workarounds, test\ldots}
%----------
\subsubsection{Actualización de parámetros avanzada}
Un nodo cognitivo tiene mas parámetros (como se puede ver en~\ref{subsec:updateSettings}) que los expuestos en la \ac{API}. Un nodo cognitivo en nuestra aplicación, se define además por:
\begin{itemize}
	\item Nombre: con el que nos conocen los demas nodos.
	\item Tipo: si somos coordinador o normal.
	\item Periodo de la tarea cognitiva: el intervalo de tiempo que transcurre entre sensados del entorno y/o toma de decisiones.
\end{itemize}
Como vemos, son parámetros que no son propios de la aplicación o aplicaciones que en ese momento estén registradas. Estos valores son devueltos cuando finaliza el \textit{handshaking} para que las aplicaciones conozcan al nodo cognitivo aunque para éstas debe ser transparente. 

Sin embargo, para poder configurar el nodo para que pueda cooperar en
cualquier \ac{CWSN} debemos habilitar una manera de modificar estos
parámetros. Para llevar a cabo esto se envia el mismo mensaje que cuando actualizamos nuestro papel o código de aplicación pero con unos campos adicionales. En concreto, el campo clave para saber si se trata de una actualización normal o avanzada recae en el campo \textit{obj}. Vimos que en una actualización normal su valor es \textit{null} y en una avanzada este valor será \bsq{no nulo} como vemos en la estructura del mensaje (ver tabla~\ref{tab:updateAllParamsMessage}). Los pormenores de este flujo los veremos en la sección~\ref{sec:procesosRed}

\messageTableInit{\appToServ}{3 =\\ \scriptsize{REGISTER\_EXCHANGE}}{0=secundario / 1=primario}{0=normal / 1=coordinador}{\textbf{True}}{\messApp{}}
\messageTableExtra{appCode}{Una \String{} con el código de aplicación}
\messageTableExtraAddrow{nodeName}{Una \String{} con el nuevo nombre del nodo en la red}
\messageTableExtraAddrow{periodTask}{Un \double{} con el nuevo periodo medido en segundos de la tarea cognitiva a ejecutar}
\messageTableEnd{Actualización de todos los parámetros del servicio}{updateAllParamsMessage}


\subsubsection{Mensaje de petición y respuesta}
Un flujo interesante en redes de sensores cognitivas es la de
habilitar una vía para que el coordinador pida de forma activa
información a otro nodo. En nuestra arquitectura, este flujo está
implementado la primera vez que incluimos un nodo nuevo en \bt{} para
preguntarle acerca de su nombre y su papel. Este sistema, que en
principio se montó con finalidad de \textit{test} se ha decidido dejar
operativo.

La aplicación desarrollada junto al servicio incluye una interfaz de test que, entre sus funciones, provee este flujo. El proceso tiene dos actores: por un lado los nodos normales que pueden guardar una respuesta (la información que posteriormente nos pedirá el coordinador). Para ello enviamos un mensaje al servicio con la respuesta a enviar en el campo \textit{obj} del mensaje (ver tabla~\ref{tab:wa_reply}).

\messageTableInit{\appToServ}{20 = \footnotesize{WORKAROUND\\ \_WHAT\_TO\_REPLY}}{\nc{}}{\nc{}}{\textit{reply}}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} salvado de respuesta}{wa_reply}

El otro agente, el nodo coordinador, enviando este mensaje al servicio, recupera la información del otro actor (ver tabla~\ref{tab:wa_ask}).

\messageTableInit{\appToServ}{21 = \footnotesize{WORKAROUND\\ \_ASK\_RESPONSE}}{\nc{}}{\nc{}}{Identificador nodo}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} petición de respuesta}{wa_ask}

Una vez enviada esta petición la respuesta nos vendrá encapsulada en un mensaje del mismo tipo (ver tabla~\ref{tab:wa_ask_response}). Esta respuesta se envía a todas las aplicaciones porque no viene marcada con el \bsq{código de aplicación}. Se recomienda su uso sólo en test ya que puede desconcertar a otras aplicaciones que estén registradas en el servicio.

\messageTableInit{\servToApps}{21 = \footnotesize{WORKAROUND\\ \_ASK\_RESPONSE}}{\nc{}}{\nc{}}{Respuesta del nodo preguntado}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} respuesta obtenida}{wa_ask_response}


\subsubsection{Cambio de contexto forzado}
Otra función de \textit{test} es la de forzar un cambio de interfaz de comunicación en la red. Para ello si somos el coordinador podemos enviar este mensaje al servicio. No necesitamos comunicarle la interfaz destino debido a que, en estos momentos, sólo hay dos interfaces de comunicación.

\messageTableInit{\appToServ}{22=\footnotesize{WORKAROUND\_\\ CONTEXT\_CHANGE}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} cambio de interfaz de comunicación}{wa_switch}

\subsubsection{Encolar mensajes y forzar su entrega en cualquier momento}
Para probar el encolamiento de mensajes y su entrega en momentos que no corresponden pueden enviarse estos mensajes al servicio que alterará el flujo normal para producir el resultado buscado.

Para encolar un mensaje de datos entregaremos al servicio un mensaje con esta estructura (ver tabla~\ref{tab:wa_queue}).

\messageTableInit{\appToServ}{23=\scriptsize{WORKAROUND\_ PENDINGMESSAGE \_INJECTION}}{\nc{}}{\nc{}}{\textit{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{}s con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje \textit{workaround} encolamiento de mensaje de datos}{wa_queue}

Y para vaciar la cola de mensajes en cualquier momento deberemos enviar este otro (ver tabla~\ref{tab:wa_disposalqueue}).

\messageTableInit{\appToServ}{24=\scriptsize{WORKAROUND\_ PENDINGMESSAGE \_DISPOSAL}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \textit{workaround} vaciado cola de mensajes}{wa_disposalqueue}


%XXX-jblesa Esta seccion es implementacion claramente. Los detalles de
%implementacion pasalos a implementacion. Aqui en diseño solo comentar
%diagrama de bloques, se enviaran mensajes, etc. pero sin definir
%detalles. Hay subapartados mejor enfocados a diseño, ya que hablan de
%funcionalidades y no de detalles. Por ejemplo, todas las tablas con
%campos son claramente implementacion. Los mensajes concretos son
%implementacion. En diseño lo importante son diagramas de bloques,
%UML, etc. Para que se vean las interfaces pero no los detalles.

%XXX-jblesa. Cuida los puntos y comas. Tienes muchos fallos de
%puntuacion. Cuida los alglicismos, pon en castellano todo lo que se
%pueda.


%-------------------------------------------------------------------
\section{Procesos de red}
%-------------------------------------------------------------------
\label{sec:procesosRed}
Cuando ocurren eventos en la red estos son manejados por los distintos nodos según sea su tipo, propagando la información necesaria para que toda la red pueda reconstruir la misma perspectiva sobre la actual situación. Veremos quién dispara y el por qué de estos eventos, cómo se informa y en qué casos a las aplicaciones montadas sobre el servicio del nodo cognitivo. Como ya se comentó, los procesos atañen a más de un bloque de la arquitectura, lo que ayuda a comprender las relaciones entre los distintos módulos. A menudo la \ac{API} del servicio  (sección~\ref{sec:api}: interfaz Aplicación - Módulo cognitivo) se ve invulcrada pues es donde empieza o finaliza la acción de estos procesos.
%------------------------------
\subsection{Registro de una aplicación en el servicio cognitivo}
\label{subsec:serviceRegisterProcess}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service (manejador de mensajes entre servicio y aplicaciones)
%\end{files}
%\end{codeInvolved}
Para que una aplicación pueda registrarse de forma correcta en el servicio debe cumplir una cierta inicialización consistente en el intercambio de tres mensajes. El primero (\Scst{REGISTER\_CLIENT}) servirá para que el servicio incluya a la aplicación en su base de clientes. El segundo (\Scst{REGISTER\_EXCHANGE}) para que la aplicación le informe de sus parámetros y el tercero (también denominado \Scst{REGISTER\_EXCHANGE}) será una confirmación por parte del servicio hacia la aplicación o aplicaciones informando de todos los parámetros de éste tras la inclusión de la nueva aplicación.

%XXX-jblesa quita handshaking y ponlo en español. XXX-cvillar handshaking = inicialización??

%Como hemos visto ya en la \ac{API} (ver sección \ref{sec:api}), tras
%la petición de atadura al servicio, que inicializará a éste si no
%estuviese arracando ya, obtendremos el \textit{Messenger} del
%servicio, indispensable para poder comunicarnos con él. A continuación
%debemos mandar un primer mensaje para registrar nuestra aplicación en
%el servicio, donde éste, registrará nuestro messenger para habilitar
%la comunicación en sentido contrario y nos incluirá en su lista de
%aplicaciones registradas. Los detalles de este mensaje pueden verse en
%la tabla~\ref{tab:registerClientMessage}

%XXX-jblesa pon bind en español XXX-cvillar ... sí y cómo? atadura??

%El siguiente mensaje (ver tabla~\ref{tab:registerExchangeMessage}) que debemos enviar, informaremos acerca de nuestros parámetros de aplicación como son: nuestro papel, un entero cuyo valor \bsq 0 corresponde a papel secundario y el valor \bsq 1 corresponde al papel primario y nuestro código de aplicación, útil para que el servicio nos entregue sólo los mensajes que nos atañen.

La petición de atadura junto al envío de estos mensajes arrancarán y configuran el módulo cognitivo. Los dos primeros mensajes están separados para poder reutilizar el segundo mensaje para incluirlo en el flujo descrito en~\ref{subsec:apiUpdateParams} o~\ref{subsec:updateSettings} de manera aislada. Con la información enviada el servicio  actuará de una forma u otra dependiendo del punto en que se encuentre: %Al terminar nos responderá con el tercer mensaje que refleja la situación la que se encontraba el servicio antes de recibir la información por parte de la aplicación.

\subsubsection{CWSN no establecida}
\umlsdInit
	\newthread[gray]{srv}{Servicio} \newinst[2]{app}{Aplicación}
	\callSelf{app}{Aplicación.init()}	
	\begin{call}{app}{bind()}{srv}{messenger}
		\callSelf{srv}{Servicio.init()}
	\end{call}
	\mess{app}{Register client}{srv}
	\mess{app}{Register exchange}{srv}
	\callSelf{srv}{Configuración interfaz}
	\mess{srv}{Register exchange}{app}
\umlsdEnd{Handshake CWSN no configurada y servicio no inicializado}{endHandshakingNotInCWSN}

Esta situación, la más común, es cuando la petición de atadura ha arrancado el módulo cognitivo y por tanto estamos en una situación inicial o ya hay aplicaciones montadas sobre éste pero no hay conectividad con otros nodos, en otras palabras, estamos solos en la red. En la figura~\ref{fig:endHandshakingNotInCWSN} se ilustra un ejemplo de cuando el servicio no está arrancado.

En esta situación configuraremos la interfaz no importando si la estuviese ya. Actualizaremos los parámetros pasados en el anterior mensaje y lanzaremos nuevamente los procesos de registro en la red para intentar establecer una \ac{CWSN}. Al finalizar éstos (ver sección~\ref{subsec:configInterface}) el servicio devolverá a todas las aplicaciones registradas la información acerca de los parámetros y el estado actual de la red (ver listas de la sección~\ref{subsec:apiStart}). En la tabla~\ref{tab:endHandshakingNotCWSNMessage} puede verse el detalle de este tercer mensaje que finaliza el proceso de inicialización y que nos permite conocer el estado en el que se encontraba el servicio antes de recibir la información por parte de la aplicación.

\subsubsection{CWSN previamente configurada}
\umlsdInit[h!]
	\newthread[gray]{srv}{Servicio} \newinst[2]{app}{Aplicación}
	\callSelf{app}{Aplicación.init()}		
	\begin{call}{app}{bind()}{srv}{messenger}
	\end{call}
	\mess{app}{Register client}{srv}
	\mess{app}{Register exchange}{srv}
	\mess{srv}{Register exchange}{app}
\umlsdEnd{Handshake CWSN configurada}{endHandshakingInCWSN}

Puede darse el caso que, en este punto del proceso, ya haya aplicaciones montadas sobre el servicio y estén cooperando en una \ac{CWSN}. En este caso el servicio no tiene que configurar nada y se limita a ver si puede satisfacer las necesidades que le acaba de transmitir la nueva aplicación que acaba de registrar, es decir, cambiará el papel del nodo a primario si este era secundario, un cambio en sentido contrario será ignorado. Una vez hecho esto devolverá en exclusiva a la aplicación solicitante los parámetros del servicio (ver tabla~\ref{tab:serviceSettings}) y el estado de la interfaz. En la tabla~\ref{tab:endHandshakingInCWSNMessage} se observa la estructura del tercer mensaje que completa la configuración.

%------------------------------
\subsection{Configuración de la interfaz de comunicación}
\label{subsec:configInterface}
%%diseño+implementacion
\comp{D+I: 
Tras recibir el \textit{handshaking} de registro de la aplicación, el servicio si no se encuentra colaborando en una \ac{CWSN}, procede a la configuración de una interfaz de comunicación, esta configuración se realiza en una \textit{AsyncTask} de \android{} que permite descargar la \textit{UI-Thread} evitando errores del tipo \textit{ANR ``Application Not Responding''} ya que parte de la tarea se ejecuta en segundo plano, además este tipo de tarea habilita mecanismos de paso de información entre ambas hebras. Antes de configurar una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos (llamando a su método \textit{stop}) para  poder partir de una situación deseable.
}
%%---
Tras recibir el segundo mensaje de la negociación entre aplicación y módulo cognitivo, si éste no se encuentra colaborando en una \ac{CWSN} procede a la configuración de la última interfaz de comunicación usada, por defecto \bt{} \comp{que se realiza en segundo plano}. Antes de empezar la configuración una interfaz pediremos a los controladores de las otras interfaces que liberen los recursos para que el proceso use la menor cantidad de memoria posible.
 
\subsubsection{Wi-Fi: servicio y controlador}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: SetupWifiInterface (AsyncTask)\\
%\textbf{WifiController}: stop(), start() / StatusReceiver\_wifi (BroadcastReceiver)
%\end{files}
%\end{codeInvolved}
%%diseño+implementacion
\comp{I+D: 
La interfaz \wifi{} permite configurarse en varias modalidades como:
Infraestructura, Tethering o Ad-hoc. En la actualidad sólo está
implementado el modo infraestructura por los problemas descritos en
\ref{sec:analisisWifi}. Una vez lanzada la tarea en segundo plano, lo
primero que hacemos es intentar parar las hebras asociadas a la
interfaz \wifi{} que cerrarán los \textit{serverSockets} y el
\textit{broadcastReceiver} útil para registrarse a eventos de
información relativa a la interfaz \wifi{} como son \ac{RSSI} y los
eventos de conexión/desconexión a un punto de acceso. Partiendo de una
situación en que todos los recursos están liberados, encendemos la
interfaz si no lo estuviese ya, esperamos a que se encienda mediante
una espera de consulta a una variable que es modificada por
\textit{StatusReceiver\_wifi.java}, nuestro \textit{broadcastReceiver}
para la interfaz \wifi{}. Si nos han pasado como parámetro el SSID,
intentamos conectarnos a él desconectándonos del punto de acceso
acutual si no fuese el mismo. Esperamos mediante \textit{polling} con
límite de tiempo seleccionable desde las preferencias en la sección de
\textit{test}. Si agotamos el tiempo y no hemos sido capaces de
conectarnos, devolvemos un valor \false{} que provoca el envío de
mensaje a todas las aplicaciones del tipo {\small REGISTER\_EXCHANGE}
con el campo EXTRA ``errorSetupInterface'' a \true{}. Si por el
contrario nuestro \textit{broadcastReceiver} ha podido capturar la
acción de conexión al citado punto de acceso o ya estamos conectados a
éste continuamos arrancando las hebras del controlador dependiendo del
tipo de nodo que seamos:

%XXX-jblesa No funciona la referencia sec:analisisWifi XXX-cvillar aún no está escrita, aún así esto es un compentario, el texto está abajo.

\paragraph{Nodo normal} Arrancamos una hebra que escuche gracias a un \textit{serverSocket} para que acepte conexiones TCP, una vez estemos escuchando en el puerto indicado, enviamos el mensaje de tipo {\small REGISTER\_EXCHANGE} con el campo {\small EXTRA} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red (sección~\ref{subsec:enterInNetwork}).

\paragraph{Nodo coordinador} Arrancamos un par de hebras, una para tráfico TCP que admita conexiones fiables y otra para el tráfico UDP que escuche y capture paquetes, si todo se ha configurado bien enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.
}
%---
La interfaz \wifi{} permite configurarse en varias modalidades como: Infraestructura, \textit{Tethering} o \adhoc{}. Aunque sólo está implementado el modo infraestructura debido a los problemas descritos en \ref{sec:analisisWifi} que complican la implementación del modelo en distintos terminales. 

Una vez lanzada la tarea intentamos liberar los recursos que vamos a solicitar por si éstos estuvieran reservados por llamadas anteriores y no se hubiesen liberado aún. La configuración comienza encendiendo la interfaz con la ayuda de la \ac{API} de \android{}, si no lo estuviese ya. Una vez terminada la espera para levantar la interfaz, intentamos contectarnos a la red \wifi{} que nos hayan pasado como parámetro (mediante el \ac{SSID}), desconectándonos del punto de acceso actual si no fuese el mismo. Si por el contrario, no nos han pasado ningún parámetro dejamos al sistema \android{} que elija el \ac{AP} más conveniente. Esperamos mientras se establece la conexión al punto de acceso, sin embargo esta espera está limitada para evitar un retraso excesivo (seleccionable desde el menú de preferencias: sección~\ref{sec:app}). Si agotamos el tiempo y no hemos sido capaces de conectarnos, devolvemos un valor \false{} que provoca el envío de un mensaje del tipo \Scst{REGISTER\_EXCHANGE} a todas las aplicaciones con el campo \Scst{EXTRA} ``errorSetupInterface'' a \true{}. Si por el contrario nuestro \textit{BroadcastReceiver} ha podido capturar la acción de conexión al citado punto de acceso o ya estamos conectados a éste continuamos estableciendo los canales de comunicación que dependen del tipo de nodo que seamos:

\paragraph{Nodo normal} Necesitamos tener un canal de comunicación permanentemente a la escucha para tráfico \ac{TCP} recibido desde el coordinador. Una vez establecido terminamos la configuración enviando un mensaje de tipo \Scst{REGISTER\_EXCHANGE} con el campo \Scst{EXTRA} ``errorSetupInterface'' a \false{} y el resto de campos descritos en la tabla~\ref{tab:endHandshakingNotCWSNMessage} y lanzamos el proceso de registro en la red (sección~\ref{subsec:enterInNetwork}).

\paragraph{Nodo coordinador} Necesitamos tener dos canales de comunicación, uno para tráfico proveniente de nodos ya en la red, este tráfico necesitamos que sea fiable por lo que será un canal \ac{TCP} y otro canal para recibir avisos de nuevos nodos que se quieran incorporar a la red, este tráfico por motivos de implementación no puede ser fiable por lo que tendremos que recurrir a tráfico \ac{UDP}. Al terminar de establecer los canales enviamos un mensaje análogo al párrafo anterior y quedamos a la espera de capturar paquetes.


\subsubsection{Bluetooth: servicio y controlador}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: SetupBTinterface (AsyncTask)\\
%\textbf{BluetoothController}: stop(), start(), connect(), setState() / StatusReceiver\_bt (BroadcastReceiver)
%\end{files}
%\end{codeInvolved}
%%diseño+implementacion
\comp{D+I:
Como en el controlador de \wifi{} empezamos (en segundo plano) liberando si no estuviesen ya cada uno de los recursos, en \bt{} coexisten, dependiendo del tipo de nodo, tres tipos de hebras: la que acepta conexiones (\textit{AcceptThread}), la que lanza la conexión (\textit{ConnectThread}) y la que mantiene la conexión entre el esclavo y el maestro (\textit{ConnectedThread}), de este tipo podemos tener más de una.
Encendemos la interfaz \bt{} si no estuviese encendida ya, mediante una petición al sistema \android{} y esperando mediante \textit{polling} a que \textit{StatusReceiver\_bt.java}, el \textit{broadcastReceiver} para la interfaz \bt{} modifique la variable de control de esta espera. Una vez finalizada, procedemos a configurar las hebras del controlador según el tipo de nodo.
\paragraph{Nodo normal} Este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita arrancar una hebra para aceptar conexiones, como sólo esperamos un maestro cuando consigue una conexión (disparada sobre el mismo UUID por el que hemos registrado el socket) liberamos este recurso. Como ya hemos configurado la interfaz enviamos el mensaje final del \textit{handshaking} (ver tabla~\ref{tab:endHandshakingNotCWSNMessage}) con las instrucciones que hemos visto ya.

\paragraph{Nodo coordinador} Este tipo de nodo se comporta como maestro en la comunicación \bt{}, no necesita aceptar conexiones, pero si disparar éstas. Para ello, recogemos de la base de datos los nodos inactivos y para cada uno de ellos lanzamos una conexión gracias al método connect() que se ejecuta en su propia hebra para asegurarnos que no se ejecuta en la hebra de la interfaz de usuario, en este caso no hace falta ya que la estamos llamando desde el segundo plano, pero como veremos este método se llama también directamente desde la UI-thread. Este método coge como parámetros la dirección \ac{MAC} con la cual queremos establecer una conexión y el número de intentos que vamos a intentar establecer esta conexión (a parte de otras constantes como el \ac{UIID}), como en \bt{} es fácil que falle el establecimiento intentamos minimizar este riesgo reintentando la conexión. En el momento que conseguimos establecer la conexión, liberamos esta hebra que se volverá a crear con el siguiente intento de conexión a otro nodo y manejamos la conexión con una nueva hebra del tipo \textit{connectedThread}, al final tendremos tantas hebras como nodos activos en la red. La forma en la que sabemos cuando podemos pasar al siguiente nodo radica en 2 flags que son modificadas gracias al sistema de estados: setState(), que tienen los controladores. En esencia, cuando disparamos una conexión y ésta falla propagamos un estado de conexión fallida al servicio que aumentara el flag de conexiones fallidas (\textit{numFailConnection}), si la conexión se produce con éxito se propaga análogamente un estado de nuevo nodo en la red y modificaremos el flag de nuevo dispositivo (\textit{flagNewDevice}) saliendo de la espera en la que nos encontramos, por establecimiento de la conexión o por llegar al máximo de intentos.

 Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje del \textit{handshaking} con el formato visto en la tabla~\ref{tab:endHandshakingNotCWSNMessage}
}
%------

Como en la configuración del controlador de \wifi{} empezamos liberando cada uno de los recursos no necesarios en este momento. Encendemos la interfaz \bt{} si no estuviese ya encendida, mediante una petición al sistema \android{} y esperamos a que finalice. A continuación, procedemos a configurar las hebras del controlador según el tipo de nodo:

\paragraph{Nodo normal} Por motivos de implementación este tipo de nodo se comporta como esclavo en la comunicación \bt{} por lo que necesita aceptar conexiones, como sólo esperamos un maestro cuando se consigue una conexión liberamos este recurso de aceptación de conexiones. Como ya hemos configurado la interfaz enviamos el tercer mensaje de la negociación (ver tabla~\ref{tab:endHandshakingNotCWSNMessage}) con las instrucciones que hemos visto ya.

\paragraph{Nodo coordinador} Por motivos de implementacion este tipo de nodo se debe comportar como maestro en la comunicación \bt{}, no necesita aceptar conexiones, pero sí disparar éstas. Para ello obtenemos del \var{Repositorio} los nodos inactivos y para cada uno de ellos lanzamos una conexión. El proceso de conexión necesita conocer la dirección \ac{MAC} con la cual queremos establecer una conexión y el número de intentos que vamos a intentar para establecer la conexión (a parte de otras constantes como el \ac{UIID}).\\ 
Como en \bt{} es fácil que falle el establecimiento, intentamos minimizar este riesgo mediante el reintento de la conexión. En el momento que conseguimos establecer el canal de comnunicación trasladamos este canal al manejador de conexiones del controlador que tendrá tantos canales como nodos haya en la red. Estos canales son cifrados y fiables por diseño de \android{}. Cada vez que se consigue o se falla en el establecimiento del canal, el controlador comunica al servicio esta información que es utilizada para saber cuando hemos de establecer el canal de comunicación con el siguente nodo.

Una vez hemos acabado con la lista de nodos inactivos habremos terminado de configurar la interfaz y procederemos al envío del último mensaje de la negociación.


%------------------------------
\subsection{Registro de un nodo en la red}
\label{subsec:enterInNetwork}

Según la interfaz en la que nos encontremos se alterna el papel de quién es el que da el primer paso. Así en \bt{} el nodo normal espera una conexión entrante y en \wifi{} es el coordinador quién espera un paquete \ac{UDP} enviado desde un nodo normal.
\subsubsection{Wi-Fi}
%\begin{codeInvolved}
%\begin{files}
%\textbf{WifiController}: SendHelloPacket (AsyncTask), UDPlistener (Thread), stopSendingHelloPacket(), setState()\\
%\textbf{Service}: mHandlerWf, sendInfoNewNodeOnNetwork()\\
%\textbf{Database}: eventNewDeviceIPCoordinator(), newDeviceEventNormal(), modifyNode()
%\end{files}
%\end{codeInvolved}
%%diseño+implementación
\comp{D+I:
Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otro proceso que comienza a enviar paquetes cada 800 milisegundos hasta llegar a un máximo de 20. La razón de enviar una ráfaga de paquetes radica en que al ser trafico broadcast/multicast los puntos de acceso pueden menospreciarlo (incluso bloquearlo) y el mismo dispositivo \android{} puede que no esté escuchando siempre en este tipo de direcciones. De hecho cuando se apaga la pantalla, el driver de \wifi{} se reconfigura automáticamente para dejar de escuchar a la dirección de broadcast, por ello una ráfaga de 20 paquetes espaciados en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta el proceso de registro terminará enviando hacia el servicio el estado {\small (EVENT\_HELLO\_NOT\_REACHED)} que será interpretado por éste informando a todas las aplicaciones registradas del fallo del proceso indicando que no ha sido posible establecer una \ac{CWSN} {\small (EVENT\_INTERFACE\_CANNOT\_CONNECT)}.\\
}
%------

Tras la configuración de la interfaz por parte de un nodo normal, éste inicia otro proceso por el que comienza a enviar una ráfaga de paquetes espaciados en el tiempo. La razón radica en que el tráfico \textit{broadcast/multicast} puede ser menospreciado tanto por los puntos de acceso \wifi{} que pueden bloquearlo, como por el mismo dispositivo \android{} puede que no esté escuchando siempre en este tipo de direcciones. De hecho cuando se apaga la pantalla, el driver de \wifi{} se reconfigura automáticamente para dejar de escuchar a la dirección de difusión. 

En vista de ello una ráfaga espaciada en el tiempo aumenta las posibilidades de recepción e interpretación de estos paquetes por parte del coordinador. Este tipo de paquetes lo denominamos \textit{``HelloPacket''}, su estructura puede verse en la tabla~\ref{tab:hellopacket} en el siguiente capítulo. Si al finalizar el envío de la ráfaga no consiguiésemos ninguna respuesta, el proceso de registro terminará enviando hacia el servicio el estado \Scst{EVENT\allowbreak\_HELLO\allowbreak\_NOT\allowbreak\_REACHED} que será interpretado por éste informando a todas las aplicaciones registradas del fallo del proceso indicando que no ha sido posible establecer una \ac{CWSN}. En este caso, el evento facilitado a las aplicaciones se transforma en \Scst{EVENT\allowbreak\_INTERFACE\allowbreak\_CANNOT\allowbreak\_CONNECT} que concentra el mismo tipo de evento en distintos controladores, uniformando la respuesta.
\comp{esto a implementación:\\
\protobufTableInit{Estructura mensaje registro en la red \wifi{}}
  \item[\fbox{\colorbox{green}{Tipo de paquete}}]\hfill\\[3pt] Valor ``HELLO'' del enumerado ``packetType''
	%\\\rule{2cm}{0.4pt}
	\item[\fbox{Hello packet}]\hfill\\[3pt] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo de paquete''
	%\\\noindent\rule{\textwidth}{0.4pt}
	\begin{description}
		\item[\fbox{Nombre del nodo en la red}]\hfill\\[3pt] Una \String{}  con el nombre del nodo en la red
		\item[\fbox{Papel del nodo}]\hfill\\[3pt] Una \String{} cuyo valor \bsq{p} es interpretado como primario y \bsq{s} como secundario (\bsq{u} para valor desconido)
		\item[\fbox{Tipo de nodo}]\hfill\\[3pt] Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\textcolor{notImplemented}{\bsq{t} coordinador temporal en \bt{} [sin implementar]}, \bsq{u} para valor desconocido)
		\item[\fcolorbox{blue}{red}{Dirección MAC}]\hfill\\[3pt] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca
	\end{description}
\protobufTableEnd{Campos del paquete ``HelloPacket''}{helloPacket}
}

Si por el contrario uno de los paquetes llega a destino y es manejado por el coordinador, se procerá a la interpretación del contenido dentro del mismo controlador. Esta ruptura del modelo de capas tiene como objetivo evitar propagar información al servicio de paquetes que no encajen con la estructura y campos requeridos. El controlador entiende cómo manejar estos paquetes pero no el resto. Si capturamos un \textit{``HelloPacket''} generaremos un evento hacia el servicio indicando que hay un nuevo nodo en la red \Scst{EVENT\_ENTERED\_IN\_NETWORK} con la información leída del paquete. 

\figura{Vectorial/design/entradaRed-wf-coord}{width=.7\textwidth}{fig:entradaRed-wf-coord}{Flujograma de los procesos desencadenados en el coordinador al introducir un nodo en \wifi{}}

Este evento llega al \var{Gestor de interfaces} (mas concretamente al \textit{handler} de \wifi{}), donde
lo primero que hacemos es ver si el nodo ya está registrado en la red
(este paso es necesario ya que tenemos varios envíos del mismo paquete
por parte del mismo nodo). Si ya está registrado ignoramos durante una guarda de
tiempo este evento, pues es una copia de otro anterior. La motivación de esta guarda recae en que en \wifi{} no se
detecta inmediatamente que un nodo se ha caído de la red. Sólo nos
podemos dar cuenta cuando intentamos enviarle algo y obtenemos un
error. Puede darse la situación de que un nodo se registre, se caiga e
intente registrarse de nuevo. Si en este lapsus nadie ha intentado
ponerse en contacto con él, el resto de nodos seguirán creyendo que el
nodo está en la red. Si ignorasemos este evento permanentemente, el nodo que está intentado cerrar su registro en la red no tiene manera de saber que en realidad a ojos de los demás nodos él ya está registrado en la red, creyendo que su \textit{``HelloPacket''} no ha llegado a destino resultando una situación de falso fallo. Si no estaba activo en la red, lo marcamos como activo (insertándolo, si no estuviese ya, en el \var{Repositorio} con la información facilitada por el controlador) y ponemos en marcha la guarda.
Acto seguido el coordinador informará a éste nodo del resto de nodos que ya hay en la red y al resto de nodos de la red se les informará del nuevo nodo. Por su parte el coordinador informará a las aplicaciones registradas que ha habido un nuevo nuevo nodo en la red y facilitará la lista de nodos.

La información de señalización que se envía y que representa %\footnote{Notar que el campo ``Dirección IP'' puede no ser informado por no estar disponible en ese momento o ser inecesario} 
al nodo la podemos ver en la tabla~\ref{itm:infoNode}, esta información está encapsulada en un mensaje de señalización junto con otra información relevante al evento.

\comp{esto a implementación:\\
\protobufTableInit{Estructura mensaje representación de un Nodo (serialización)}
	\item[Nombre del nodo en la red] Una \String{}  con el nombre del nodo en la red.
	\item[Papel del nodo] Una \String{} cuyo valor \bsq{p} es interpretado como usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconocido).
	\item[Tipo de nodo] Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador  (\textcolor{notImplemented}{\bsq{t} coordinador temporal en Bluetooth [sin implementar]}, \bsq{u} para valor desconocido).
	\item[Dirección MAC] Un \String{} cuyo valor es la dirección MAC en \bt{} del nodo, clave que identifica al nodo de manera unívoca.	
	\item[Dirección IP] Una \String{} cuyo valor representa la dirección IP (formato IP4) del nodo.
	\item[Dirección MAC del coordinador] Una \String{} que contiene la dirección MAC de \bt{} del coordinador del nodo que estamos enviando la información.
\protobufTableEnd{Representación de un nodo necesaria para recrear el mapa de red, contenido del mensaje de señalización}{infoNode}
}

Mientras el nodo normal está recibiendo esta información, el controlador correspondiente le habrá informado a través del \var{Gestor de Estados} de la situación de recibir datos. Este evento le sirve al módulo cognitivo para saber que ha sido registrado en la red. Con lo que él mismo genera un evento de entrada en la red \Scst{EVENT\_ENTERED\_IN\_NETWORK} que sirve para homogeneizar el flujo y que sea idéntico al de \bt{}. Además este evento sirve para parar el envío de \textit{``HelloPacket''}. 

Al terminar de recibir el mensaje de señalización antes de procesarlo tendremos que comprobrar que el nodo coordinador está incluido ya en el \var{Repositorio}. La razón es que necesitamos conocer el identificador del nodo para poder recrear el mapa de red, por lo que si el coordinador no estaba ya incluido, incluimos al menos su dirección \ac{MAC} que se obtiene haciendo un procesamiento mínimo del mensaje, así logramos obtener el identificador el nodo. A medida que vamos procesando el mensaje más profundamente, vamos sustituyendo los valores antiguos del \var{Repositorio} (y de relleno si el nodo coordinador no estaba incluido) por los nuevos valores extraídos del mensaje de señalización. En este momento el nodo normal informará a las aplicaciones de que ha entrado en la red gracias al mensaje visto en la figura~\ref{subsec:serviceInformation} con el evento \Scst{EVENT\_INTERFACE\_NEW\_NODE} (visto en la tabla~\ref{tab:events}) y anunciará la lista de nodos y quién es el coordinador. \comp{es oportuno decir que por motivos de eficiencia, solo hacemos una pasada por el mensaje} 

\subsubsection{Bluetooth}
%\begin{codeInvolved}
%\begin{files}
%\textbf{BluetoothController}: connected(), setState()\\
%\textbf{Service}: mHandlerBt, sendInfoNewNodeOnNetwork()\\
%\textbf{Database}: newDeviceEventNormal(), modifyNode(), updateInfoDeviceCoordinator()
%\end{files}
%\end{codeInvolved}

Como hemos explicado antes, es ahora el coordinador quien tiene que dar el primer paso. De hecho cuando se congifura la interfaz está incluida una ronda de conexión a los nodos inactivos. Al establecerse el canal de comunicaciones tanto el nodo coordinador como el nodo normal informan a sus respectivos servicios que se ha producido un evento de nodo nuevo \Scst{EVENT\_NEW\_DEVICE}.

\paragraph{Nodo normal} Al recibir el evento conexión al coordinador vemos si éste está en la base de datos. Si no lo estuviese, incluiríamos su dirección \ac{MAC} para obtener su identificador y pospondríamos el anuncio del nuevo nodo hacia las aplicaciones hasta que no obtengamos el mensaje de señalización dónde se nos informa de las características del resto de nodos en la red. Si por el contrario ya habíamos cooperado antes con este nodo, anunciaremos de inmediato hacia las aplicaciones el evento de conexión al nodo coordinador. Notar que los parámetros del nodo coordinador (nombre y papel) pueden ser valores que no se correspondan con la situación actual, no es una cosa que nos deba preocupar pues en primer lugar son parámetros cuyo cambio suele ser puntual y en segundo lugar será solventado momentos después al recibir la señalización con información sobre la población en la red.

\figura{Vectorial/design/entradaRed-bt-coord}{width=.6\textwidth}{fig:entradaRed-bt-coord}{Flujograma de los procesos desencadenados en el coordinador al introducir un nodo en \bt{}}

\paragraph{Nodo coordinador} El flujo (ilustrado en la figura~\ref{fig:entradaRed-bt-coord}) también comienza preguntándonos si habíamos cooperado ya con el nodo al que acabamos de conectarnos. Si no estuviese en la base de datos, le enviamos un mensaje de petición de información para que nos informe de su nombre y papel, ya que su dirección \ac{MAC} y su tipo (normal) lo sabemos porque o nos lo facilita el controlador o porque es deducible por el contexto. El nodo normal al recibir este mensaje envía sus datos, que el coordinador procesa como si fuese una actualización de parámetros en la red más, lo que conlleva modificar los datos del nodo que nos lo envía y la propagación de estos al resto de nodos. Además en este caso como el nodo no estaba en la red, se le envía información sobre la red cerrando el proceso de registro y se anuncia hacia las aplicaciones la entrada de un nuevo nodo. En la tabla~\ref{tab:serviceInformation} vemos la estructura de este mensaje.

%XXX-jblesa A quien te refieres con ``que nosotros procesamos'' en el parrafo anterior? XXX-cvilar nosotros es en este caso el coordinador.


%------------------------------
\subsection{Salida de un nodo de la red}
\label{subsec:salidaNodoRed}

\figura{Vectorial/design/salidaRed}{width=.6\textwidth}{fig:salidaRed}{Flujo salida red}

La dificultad en el proceso de salida de un nodo de la red viene marcada tanto por la interfaz como por el tipo de nodo que se trate. Es un proceso que tiene dos lados: por una parte la del nodo que se desregistra de la red y por otra la de los nodos que se quedan.\\
Un nodo se desregistra de la red cuando no quedan aplicaciones montadas sobre el servicio. Para que una aplicación se desregistre del servicio tiene que mandar una petición para dejar de estar atado pero que debe ser precedida por un mensaje del tipo \Scst{UNREGISTER\_CLIENT} (ver tabla~\ref{tab:unregisterClientMenssage}). Con el mensaje el servicio sabrá que tiene que borrar de su base de clientes a la aplicación y la petición liberará la conexión creada por \android{} entre ambos. 

%XXX-jblesa quita unbind y ponlo en español. XXX-cvillar done.

%El flujo que relaciona aplicación y servicio destruye a éste cuando todas las peticiones de \textit{bind} son correspondidas con sus \textit{unbind}. Parecido pasa con las peticiones de \textit{start} y \textit{stop} (en el caso general una única petición de \textit{stop()} destruye al servicio no importando cuantas peticiones de \textit{start()} haya habido). \android{} tiene este tándem para decidir si un servicio debe seguir vivo o no. Como las peticiones de \textit{start} son disparadas por el propio servicio para realizar de forma periódica su tarea cognitiva, ha sido necesario modificar el ciclo de vida para que cuando el servicio deje de tener aplicaciones sobre él, se destruya a si mismo y no automáticamente como normalmente ocurriría. 

Cuando se libera esta conxeión los pasos a seguir antes de destruir el módulo o servicio cognitivo es la preparación del \var{Repositorio} y otros módulos para que estén preparados para una nueva instancia del servicio. Estas acciones comprenden resetear las direcciones \ac{IP} y el identificador del coordinador para cada nodo, así como el marcaje de éstos como inactivos. Por último una indicación de que el servicio ha sido parado de forma volunaria para darnos cuenta de posibles cierres forzados, de tal forma que al instanciar de nuevo el servicio siempre tengamos una situación de partida inicial. 
Estas acciones no son ejecutadas si la salida es forzosa: debido a un error no manejado que provoca el cierre o debido a la falta de memoría que provoca que el gestor de \android{} cierre la aplicación. En este caso como no se ha puesto la marca de cierre voluntario del servicio, al arrancar el servicio de nuevo podemos realizar estas acciones al comienzo para desembocar en la misma situación inicial.\\

Entre las acciones a ejecutar por el nodo que sale de la red tenemos que dependiendo de la interfaz la forma de avisar al resto de nodos que se quedan varia:
\subsubsection{Wi-Fi}
%\begin{codeInvolved}
%\begin{files}
%\textbf{WifiController}: sendbyePacket(), sendbyePacketReliable(), SendByePacket (AsyncTask)\\
%\textbf{Service}: mHandlerWF, eventLostActionsNormal(), onDestroy(), onCreate()\\
%\textbf{Database}: lostNode()
%\end{files}
%\end{codeInvolved}

En esta interfaz tenemos una conexión intermitente, que se desplega y se retrae en los momentos en los que hay comunicación. En esta situación ante eventualidades no tenemos el mismo tiempo de reacción como lo podemos tener en \bt{}. En el caso de salida voluntaria necesitamos un mecanismo que informe que un nodo va a abandonar la red.

Este mecanismo consiste en el envío de un paquete llamado \textit{``ByePacket''} (ver detalle en figura~\ref{itm:byePacket}) que contiene la dirección \ac{MAC} del nodo que abandona la red. El envío de este paquete puede ser sobre \ac{TCP} o \ac{UDP}. En el caso de que el envío sea desde el nodo coordinador, sólo podremos mandarlo sobre \ac{TCP} ya que los nodos normales no escuchan sobre \ac{UDP} como hemos visto en la sección~\ref{subsec:configInterface} que explica la configuración de las distintas interfaces.\\
%%diseño+impletacion
\comp{D+I:
Este envío se realiza gracias a otra \textit{AsyncTask} que al finalizar libera los recursos del controlador cerrando la vida de la aplicación por completo.
%}
%%--

\protobufTableInit{Estructura mensaje desregistro en la red \wifi{}}
  \item[Tipo de paquete] Valor ``BYE'' del enumerado ``packetType''.
	\item[Bye packet] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo de paquete'':
	\begin{description}
		\item[Dirección MAC] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca.
	\end{description}
\protobufTableEnd{Campos del paquete ``ByePacket''}{byePacket}
}

Las acciones a ejecutar por los nodos que se quedan en la red son:

\figura{Vectorial/design/salidaRed-event}{width=.7\textwidth}{fig:salidaRed-event}{Flujo evento pérdida de nodo manejado disparado por evento del controlador desde los nodos que se quedan en la red}


\paragraph{Nodo normal} En \wifi{} tenemos dos formas de recibir el evento de pérdida de nodo:
\begin{itemize} 
	\item A través de un evento generado en el controlador tras la recepción de manera fiable del paquete \textit{``ByePacket''} por parte del coordinador. Procederemos a marcar a todos los nodos como inactivos y demás información volátil de la \ac{CWSN}. Por otra parte informamos a las aplicaciones registradas de la pérdida del nodo y de la salida de la red. 
\item Mediante un mensaje de señalización por parte del coordinador con la información de pérdida de un nodo. En este caso procedemos a marcar en exclusiva a este nodo como inactivo e informar a las aplicaciones registradas del nuevo mapa de red.
\end{itemize}

\figura{Vectorial/design/salidaRed-signaling}{width=.7\textwidth}{fig:salidaRed-signaling}{Flujo evento pérdida de nodo disparado por señalización manejado desde un nodo normal}

\paragraph{Nodo coordinador} Al recibir el paquete \textit{``ByePacket''} se generará el evento de pérdida de nodo que se entregará al servicio. Marcaremos este nodo como inactivo y veremos si aún quedan nodos en la red, si la respuesta es afirmativa enviaremos un mensaje de señalización (cuyo detalle se explica en la figura~\ref{itm:lostNode}) a cada nodo restante en la red informando de la pérdida, así ellos podrán recomponer el mapa de red e informar a sus aplicaciones, informamos también a nuestras aplicaciones registradas del evento y de la nueva lista de nodos. Si la respuesta es negativa, nos limitamos a informar a las aplicaciones registradas del evento de pérdida y del evento de salida de la red.


%XXX-jblesa. En todos los apartados cambiaria Normal y Coordinador por
%Nodo normal y Nodo coordinador. XXX-cvillar vale.

\subsubsection{Bluetooth}
%\begin{codeInvolved}
%\begin{files}
%\textbf{BluetoothController}: connectionLost(), setState()\\
%\textbf{Service}: mHandlerBt, eventLostActionsNormal(), onDestroy(), onCreate()\\
%\textbf{Database}: lostNode()
%\end{files}
%\end{codeInvolved}

En este caso tenemos una conexión abierta en todo momento, por lo que ante cualquier eventualidad nos daremos cuenta inmediatamente de que se ha perdido la conexión, lo que hace innecesario el mecanismo descrito en la sección anterior.
%%diseño+implementacion
\comp{D+I:
Tanto si se trata de una salida voluntaria como involuntaria, se
destruye tanto la aplicación como el servicio y se liberan todos los recursos. Al cerrarse el controlador de \bt{}, las hebras que haya abiertas desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de que el \textit{socket} usado en la comunicación ha sido cerrado, lo que supone que el controlador detecte el cierre de la conexión y lance el evento de pérdida de nodo.
}
%%---
Tanto si se trata de una salida voluntaria como involuntaria, se destruye tanto la aplicación como el servicio, se liberan todos los recursos. Al cerrarse el controlador de \bt{}, los canales de comunicación abiertos desaparecen lo que acarrea que el otro extremo de la comunicación se de cuenta de la desaparición de éste y se lance el evento de pérdida de nodo desde ambos extremos.\\

Las acciones a ejecutar por los nodos que se quedan en la red son:
\paragraph{Nodo normal} Al igual que en el caso anterior podemos percibir la pérdida de un nodo tanto por un evento del controlador como por señalización. 
El evento elevado hasta el
servicio por el controlador significa que hemos perdido conexión con
nuestro coordinador (que acaba de abandonar la red) y por tanto con
toda la red. Procedemos a marcar a todos los nodos como inactivos
borrando además todos los datos relativos a la \ac{CWSN} que acabamos
de abandonar. Informamos a las aplicaciones registradas que hemos
dejado de formar parte de ésta. Por otro lado, al recibir la
señalización que indica la pérdida de un nodo seguimos el flujo visto
en la figura~\ref{fig:salidaRed-signaling} que es gestiondo en el \var{Gestor de Interfaces}.

%XXX-jblesa. En el parrafo anterior dos veces por tanto seguidas. XXX-cvillar done.

\paragraph {Nodo coordinador} Si por el contrario somos un nodo coordinador, significa que hemos perdido la conexión con un nodo normal con el que teníamos comunicacion directa y debemos informar al resto de nodos de esta eventualidad enviando un mensaje de señalización con la dirección \ac{MAC} del nodo saliente para que ellos puedan rehacer el mapa de red. Marcamos también al nodo del que acabamos de perder la comunicación como inactivo e informamos a las aplicaciones registradas del evento y la nueva lista de nodos. Si todos los nodos de nuestra base de datos están marcados como inactivos, significa que acabamos de perder la comunicación con el último nodo y por tanto dejamos de estar en \ac{CWSN} situación que informamos a las aplicaciones registradas de manera análoga. 

%------------------------------
\subsection{Actualización de parámetros en la red}
\label{subsec:updateSettings}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service, spreadNodeChangeOnNetwork(), updateInformationToCoordinator()
%\end{files}
%\end{codeInvolved}


Los parámetros del servicio se pueden dividir en dos grupos: los propios del servicio y los de las aplicaciones. De estos últimos, uno de ellos es único y por tanto está compartido entre todas las aplicaciones registradas.
%(ver tabla~\ref{tab:serviceSettings}).

\begin{table}[h]
\begin{center}
	\begin{tabular}{r @{\hskip 1cm} p{7cm}}
	\multicolumn{2}{c}{Parámetros exclusivos servicio}\\ \hline
	\noalign{\vskip 0.17cm} 
	\textbf{Nombre del nodo} & Una \String{} que represente el nombre del nodo en la red.\\
	\textbf{Tipo de nodo} & Un \integer{} cuyo valor \bsq{0} se traduce por normal y cuyo valor \bsq{1} corresponde a coordinador.\\
	\textbf{Periodo tarea cognitiva} & Un \double{} que expresa el número de segundos que transcurren entre ejecuciones de la tarea cognitiva.\\
	\noalign{\vskip 0.2417cm} 
	\multicolumn{2}{c}{Parámetros aplicación}\\ \hline
	\noalign{\vskip 0.17cm} 
	\textbf{Papel del nodo} & Un \integer{} para representar el papel que juega el nodo en la red, \bsq{0}: usuario secundario mientras que el valor \bsq{1} representa al usuario primario.\\
	\textbf{Código de aplicación} & Una \String{} para discernir entre mensajes enviados por distinas aplicaciones.\\
	\end{tabular}
	\caption{Parámetros del servicio} \label{tab:serviceSettings}
\end{center}
\end{table}

Los primeros parámetros son ajustes del módulo cognitivo que traspasan a cualquier aplicación, sin embargo los segundos si son propios de cada aplicación: el primero expresa las necesidades de comunicación y el segundo nos sirve para filtrar mensajes en el servicio entregándo el contenido dirigido a cada aplicación en concreto. El parámetro ``papel del nodo'' en realidad es un parámetro compartido, es decir si varias aplicaciones están registradas en el servicio cada una habrá aportado un valor distinto. Como este valor es único, elegimos el que es más adecuado a las necesidades de comunicación de la aplicación más restrictiva. En otras palabras si una aplicación pide ser ``usuario primario'' y otra aplicación pide ser ``usuario secundario'' el valor del parámetro será ``usuario/nodo primario''.\\

La primera forma de actualizar los parámetros de aplicación es con el registro de la aplicación en el servicio (ver sección~\ref{subsec:serviceRegisterProcess}) o en cualquier momento enviando un mensaje desde la aplicación al servicio del tipo \Scst{REGISTER\_EXCHANGE} (visto en la tabla~\ref{tab:registerExchangeMessage}) que desembocará en una contestación con todos los parámetros del servicio.\\

Con respecto a los parámetros exclusivos del servicio la forma de actualizarlos está un poco escondida en la \ac{API}, ya que son ajustes propios del servicio, cuyo conocimiento no trasciende a la aplicación y por tanto sometidos a cambios poco frecuentes. Normalmente estos parámetros están guardados en el \var{Repositorio} y se recuperan al recibir un mensaje del tipo \Scst{REGISTER\_EXCHANGE}.
%Sin embargo, si en este mensaje viene informado el campo \textit{obj} con un valor booleano a \true{} entonces en vez de coger los parámetros de la base de datos, los extraemos del mensaje. El detalle del mensaje ya se definió en la tabla~\ref{tab:updateAllParamsMessage}.
Sin embargo, si este mensaje viene informado de una manera particular, podemos cambiar el flujo para que se produzca una actualización de estos parámetros. En la tabla~\ref{tab:updateAllParamsMessage} se describe el detalle de este mensaje.

La actualización de estos parámetros (tanto si sólo actualizamos los de aplicación o todos) viene condicionada a si estamos cooperando en una red o no. Si no estamos en ninguna red los valores pasados sobreescribiran los existentes. En cambio si estamos en una situación de red, los parámetros ``papel del nodo'' y ``periodo tarea cognitiva'' pueden no ser actualizados. Su actualización depende por tanto del valor actual, si el nuevo valor es más restrictivo se podrá actualizar. Es decir para el ``papel del nodo'' sólo actualizaremos si el cambio pedido es a ``nodo primario'' y para ``periodo tarea cognitiva'' sólo actualizaremos si el periodo requerido es más pequeño que el actual.  Con respecto al parámetro ``tipo de nodo'', una vez se está en una \ac{CWSN} no se permiten cambios ya que dejaríamos a la red sin coordinador o añadiriamos otro coordinador, situaciones que no son de interés. Lo anterior no aplica, salvo el cambio de tipo de nodo, en la situación en que sólo hay una aplicación registrada, situación en la que actualizaremos el resto de los parámetros al producirse ningún conflicto. \\

Con respecto a la actualización de estos parámetros al resto de nodos, una vez validados y actualizados según las reglas descritas, si son de interés general (``nombre del nodo'', ``papel del nodo'') son enviados al coordinador (ver detalle del mensaje en figura~\ref{itm:updateToCoordinator}) para que este los distribuya como una actualización más del mapa de red (estructura del mensaje de red detallada en figura~\ref{itm:updateParams}).

En \bt{} puede darse la situación de que si somos un nodo normal los demás nodos nos vean con parámetros antiguos. Esta sitaución se produce si hemos actualizado nuestros parámetros fuera de una \ac{CWSN} donde obviamente no han sido propagados a la red. Cuando el coordinador, que no tiene manera de saber que hemos modificado nuestros parámetros, nos incluye en la red, si nos conoce de veces anteriores no nos preguntará sobre ellos, si no que sacará una copia desactualizada de su \var{Repositorio} que distribuirá al resto. No obstante esta situación es muy poco frecuente, por lo que teniendo en mente la minimización del tamaño de mensajes y el número de éstos, se ha preferido no implementar mecanismos que hagan mantener actualizados en todo momento los parámetros del nodo (``nombre del nodo'', ``papel del nodo'' y ``tipo de nodo'' aunque este último es deducible por el contexto) en favor de una mayor eficiencia de red y menor consumo. Esta situación no ocurre en \wifi{} ya que la forma de registro en la red conlleva el envío de un paquete para registrarse en el que enviamos toda la información del nodo, por lo que sobre \wifi{} se puede actualizar en cualquier momento y sobre \bt{} sólo en momentos de cooperación en red. No obstante la situación de desactualización se soluciona cuando hay un cambio de contexto con interfaz destino \wifi{}.

%------------------------------
\subsection{Intercambio de mensajes}
La transmisión y recepción de datos se realizan a través del intercambio de mensajes definidos en la \ac{API}. Podemos destacar tres acciones: el envío, la recepción y una mezcla de ambos reservada sólo al coordinador que es el re-envío de mensajes.

\subsubsection{Recepción de mensajes}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service, mHandler<controlador>, incomingContentNormal(), incomingDataMessageToApp()\\
%\end{files}
%\end{codeInvolved}
%%diseño+implementación
\comp{D+I:
Empezamos explicando este proceso por ser el más fácil. Cuando la hebra del controlador (no importando cual) sale de su bloqueo al recibir datos, se genera el evento de recepción de datos que es manejado en el servicio. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona de nuevo al servicio los datos recibidos e información sobre el envío
%conjuntamente a información que dependiendo del controlador, incluirá {\small EXTRAS} distintos 
(ver tabla~\ref{tab:messageReadController}).
}
%%--
Empezamos explicando este proceso por ser el menos complejo y nos que nos ayuda a introducir algunas de las piezas que veremos en el proceso de envío. Al recibir datos se genera el evento \Scst{INTERFACE\_STATE\_RECEIVING} que es manejado en el \var{Gestor de Interfaces}, para que este informe a las aplicaciones. Cuando ha terminado de recibir todo el mensaje, el controlador proporciona de nuevo al servicio los datos recibidos e información sobre el envío
(ver tabla~\ref{tab:messageReadController}).

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{A implementación:\\
\messageTableInit{\controllerToServ}{2 =\\ \scriptsize{MESSAGE\_READ}}{Número de \textit{bytes} leídos}{\nc{}}{\textit{bytes} leídos de la red}{\nc{}}

\messageTableExtraControllerSpecified{\wifi{}}{device\_ip\_address}{Una \String{} con la direción IP del nodo que nos envía los datos}

\messageTableExtraControllerSpecified{\bt{}}{device\_name}{Una \String{} con el nombre proporcionado por los servicios de \bt{} de \android{} (no es relevante)}
\messageTableExtraAddrow{device\_address}{Una \String{} con la dirección MAC de \bt{} del nodo que nos envía los datos}

\messageTableEnd{Mensaje recibido por la red entregado por ambos controladores al servicio}{messageReadController}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Una vez tenemos los \textit{bytes} leídos en el servicio los procesamos. Este procesamiento puede ser tan simple como entregar el contenido del mensaje a la aplicación correspondiente o reenviar el mensaje al siguiente eslabón de la cadena (sección explicada en la página~\pageref{forwardProcess}). 

El tratamiento del mensaje depende del tipo de nodo sin embargo, la presentación del mensaje hacia la aplicación es común. 
%Si estamos en la lista de destinatarios, obtenemos el ``Código de aplicación'' (ver tabla~\ref{itm:dataMessage}) que nos permite recuperar el \textit{Messenger} de la aplicación. Así filtramos y entregamos a cada aplicación los mensajes que le interesan. También, gracias al campo ``Desde'' sabemos quién es el originador del mensaje. Una vez hemos recuperado la aplicación destinataria y el nodo que envío el mensaje, podemos trasladar esta información a la aplicación correspondiente (ver tabla~\ref{tab:incomingContent}).
La presentación consiste en entregar, si aplica, es decir si el nodo está en la lista de destinatarios, los datos recibidos e información sobre el origen a la aplicación correspondiente a través de mensajes de la \ac{API} (ver tabla~\ref{tab:incomingContent}).
%ayudándonos del campo ``Código de aplicación'' para discernir quién es la interesada y obtener quién es el originario del mensaje que vendrá escrito en el mensaje recibido (en la tabla~\ref{tab:incomingContent} vemos el detalle entregado a la aplicación).

\subsubsection{Envío de mensajes}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: m2service, builtDataMessage(), getNextNodes(), send(), mHandler<controlador>, outgoingContentProgress()\\
%\textbf{DataMessageQueue}: add(), hashMessage(), changeStatus(), remove()
%\end{files}
%\end{codeInvolved}

El proceso de envío de datos a través del servicio cognitivo comienza con un mensaje a través de la \ac{API} (ver estructura en la tabla~\ref{tab:outgoingContent}).

Una vez entregado el mensaje al servicio se empieza a
procesar. Asumimos que el mensaje que se quiere enviar es de un
contenido que se puede codificar como una \String{}. Por tanto, éste
es el tipo de dato que se espera en el campo \textit{obj} del mensaje
.%(\textit{payload}). 
Si no es así, el servicio devolverá un mensaje de error a la aplicación explicando que el contenido no puede manejarlo. En segundo lugar se comprueba que todos los valores de la lista son nodos de la red y están activos, también comprobamos que estamos en una \ac{CWSN}. Si no se superase alguna de estas otras validaciones se entregaría al igual que antes un mensaje de error a la aplicación con el código y descripción pertinentes abortándose el proceso en curso. Si no hay ningun problema, confeccionamos con el formato expresado en al tabla~\ref{itm:dataMessage} el mensaje que se va a enviar a la red.

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje datos}
  \item[Tipo] Valor ``DATA'' del enumerado ``MessageType''.
  \item[Desde] Una \String{} con la dirección MAC de \bt{} del nodo.
	\item[Lista destinatarios] Una lista de \String{} con la lista con las direcciones MAC de \bt{} de los nodos destinatarios.
	\item[Código de aplicación] Una \String{} con el código de aplicación para filtrar el mensaje en destino. 
	\item[Marca de tiempo] Un \textit{long} con la representación del momento en el cual la aplicación entregó el mensaje al servicio.
	\item[Mensaje de datos] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Payload] Una \String{} con el contenido del mensaje. 
	\end{description}
\protobufTableEnd{Campos del mensaje de datos}{dataMessage}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Una vez tenemos el mensaje lo guardamos en una cola, lo que nos ayuda a calcular el tiempo de llegada de los mensajes de datos por parte de las aplicaciones y es necesario para ofrecer a la aplicación una confirmación positiva o negativa sobre la entrega a los nodos destinararios para cada mensaje. Como esta confirmación puede no ser inmediata, necesitamos almacenar de alguna manera el mensaje para poder recuperarlo cuando nos llegue ésta. Para guardarlo y rescatarlo cuando llegue el momento nos ayudamos de una clave, un \textit{hash} calculado en base a la marca de tiempo, el contenido del mensaje y la dirección \ac{MAC} de \bt{} del nodo que envía el mensaje. 

El siguiente punto es ver si podemos enviar el mensaje por la red. Para ello debemos estar registrados en una \ac{CWSN} y no estar en una situación de cambio de contexto. Si se da esta situación marcamos el mensaje como ``pendiente de envío'' en la cola. Si podemos enviarlo lo marcamos como ``en envío'' y se procede al mismo. Para ello necesitamos saber quién o quienes son los siguientes nodos en la cadena de envío, información facilitada por el submódulo \var{Enrutamiento} del \var{Gestor de Interfaces}. Aunque gracias a que cada nodo tiene información sobre cómo alcanzar a otros nodos, nuestra red está centralizada en la figura del coordinador, por lo que la comunicación entre nodos no es posible siendo precisa una comunicación de saltos en los que el coordinador juega el papel central. Se sigue la recomendación vista en \ac{CB} (\cite{conbrok}) para incrementar de esta forma la eficiencia. No obstante hay casos en que esta comunicación de saltos viene forzada por la interfaz de comunicación en uso: estamos hablando de \bt{} cuya única tipología posible es la de estrella (esclavo/maestro). El encaminamiento por tanto depende del tipo de nodo: 

\paragraph{Nodo normal} El siguiente eslabón de la cadena siempre es nuestro nodo coordinador, tanto si el mensaje es dirigido a él, como si lo es a otros nodos. 

\paragraph{Nodo coordinador} El coordinador tiene comunicación directa con todos los nodos, en \wifi{} ocurre siempre y en \bt{} tenemos la restricción de hasta siete nodos, si no introducimos la figura del ``coordinador intermedio'', nodo que se comporta como concentrador de mensajes en su \textit{piconet} y que a su vez está en otra \textit{piconet} donde se encuentra el coordinador. En estos momentos como sólo hay un salto, tenemos contacto directo con cualquier nodo no importando la interfaz en la que nos encontremos. Por tanto los siguientes eslabones de la cadena de entrega son los mismos nodos que están en el campo ``Lista de Destinatarios'' del mensaje a enviar.\\

Una vez tenemos los datos codificados y a quién se lo vamos a enviar, procedemos al envío (en la siguente sección veremos que necesitamos un parámetro más pero que por el momento podemos obviar). Enviar es básicamente pasar como parámetros el mensaje al método \textit{write()} del controlador traduciendo los nodos a la dirección de comunicación de la interfaz, es decir si tenemos que enviar un mensaje a una serie de nodos de los cuales tenemos sus identificadores, tendremos que traducir estos identificadores a las direcciones \ac{IP} en el caso de \wifi{} o a las direcciones \ac{MAC} en \bt{}. Una vez que el mensaje ha sido escrito en la red por el controlador, este mismo informa al servicio a través de un mensaje del tipo \Scst{MESSAGE\_WRITE} con resultado del envío, enviándonos el propio mensaje de vuelta más una lista de las direcciones de comunicación a las cuales no ha podido entregar el mensaje (ver tabla~\ref{tab:messageWriteController}).\\

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\messageTableInit{\controllerToServ}{3 =\\ \scriptsize{MESSAGE\_WRITE}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{bytes} enviados a través de la red}{\nc{}}
\messageTableExtra{requester}{Una \String{} que representa el \textit{messenger} de la aplicación que origina el mensaje}
\messageTableExtraAddrow{addressNotDelivered}{Una lista de \String{} con las direcciones \ac{MAC} de \bt{} o direcciones IP de los nodos a los cuales el envío del mensaje ha resultado fallido, según el controlador que nos envíe el mensaje}
\messageTableEnd{Mensaje resultado envío de datos desde el controlador al servicio}{messageWriteController}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

%Dependiendo de quienes sean los destinatarios del mensaje, el mensaje habrá llegado a su destino (no hay saltos de por medio) y por tanto no necesitamos más confirmación de entrega que la que ya nos da \ac{TCP} de por si. Si no tuviesesemos contacto directo con los nodos a los que queremos enviar el mensaje necesitamos esperar a que nos confirmen el resultado de la entrega de éste.

Dependiendo de quienes sean los destinatarios del mensaje su entrega comprenderá uno o más saltos. Si sólo tenemos un salto, es decir, ambos nodos pueden establecer un canal de comunicación directo, no necesitamos un mensaje extra de confirmación de llegada pues el protocolo \ac{TCP} nos cerciora de la entraga. Si por contra la entrega del mensaje pasa por varios nodos antes de llegar al destino final es necesario un mensaje de confirmación que recorra el camino contrario para informar al nodo que envió el mensaje del éxito o fallo del proceso de entrega:

%XXX-jblesa. Este parrafo anterior no tiene sentido. Escribelo otra vez. XXX-cvillar mejor?

\paragraph{No es necesario recibir mensaje ACK} En este primer caso, al ser una entrega directa, si somos un nodo normal el mensaje tiene como único destinatario nuestro coordinador. Si somos un nodo coordinador el mensaje ha sido entregado en mano a todos los nodos. Como ya se ha terminado el flujo de envío del mensaje, procedemos a borrarlo de nuestra cola de mensajes gracias al \textit{hash} y a entregar un mensaje a la aplicación con información sobre la entrega (ver tabla~\ref{tab:outgoingContentResultApp}).

\paragraph{Es necesario mensaje ACK} En el segundo caso, el mensaje envíado requiere de un salto en la red, requiere de un re-envío. La casuística de cómo se producen este tipo de mensajes será explicada en la siguiente sección, en ésta nos limitamos a ver el proceso de recepción del \ac{ACK} vista desde un nodo normal. En este caso al recibir por parte del controlador el mensaje (ver tabla~\ref{tab:messageWriteController}) procedemos a su marcaje en la cola como ``pendiente de ack'' quedando a la espera de recibir la confirmación del envío del siguiente salto. En la tabla~\ref{itm:ackMessage} podemos ver el formato del mensaje de señalización utilizado para la confirmación del envío.

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:
\protobufTableInit{Estructura mensaje ACK}
  \item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``ACK'' del enumerado ``AskType''.
		\item[Mensaje de ACK] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':
			\begin{description}
				\item[Hash] Un \textit{long} con el identificador único de mensaje.
				\item[Número mensajes escritos OK] Un \integer{} con el número de mensajes que han sido correctamente entregados.
				\item[Lista de direcciones MAC NOK] Una lista de \String{} con las direcciones MAC de \bt{} de los nodos a los cuales no se ha podido entregar el mensaje.
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje ACK}{ackMessage}
}
%%%%%%%%%%%%%%%%%%%%%%%%_ 
Al recibir ésta procedemos a borrar de la cola el mensaje de datos utilizando el \textit{hash} leído de la señalización y a comunicar a la aplicación el resultado del proceso de envío. (El detalle puede verse en la tabla~\ref{tab:outgoingContentResultApp})

\umlsdInitTitle{Envío desde nodo A, a los nodos B y C}
	\newinst{a}{nodo A} \newthread[black!30]{nc}{nodo Coordinador} \newinst[1]{b}{nodo B} \newinst{c}{nodo C}
	\begin{call}{a}{Envío datos}{nc}{} \end{call}
	\prelevel\callSelf{a}{Marcar mensaje en la cola como \bsq{pendiente de ACK}}
	\begin{messcall}{nc}{Re-envío datos A}{b} \end{messcall}
		\prelevel\prelevel\callSelf{b}{Entrega datos a la app} \postlevel
	\begin{messcall}{nc}{Re-envío datos A}{c} \end{messcall}
		\prelevel\prelevel\callSelf{c}{Entrega datos a la app}
	%\mess{nc}{ACK}{a}
	%\begin{messcall}{nc}{\shortstack {ACK\\ \texttt{(Entrega datos enviados} \\ \texttt{y estadísticas a la app)}}}{a} \end{messcall}
	\begin{messcall}{nc}{ACK}{a} \end{messcall}
	%\callSelf{a}{borrado mensaje de la cola}
	\node[align=right,text width=5cm] at (0.9,-7.6){\texttt{Entrega datos enviados, borrado del mensaje en la cola y envío de estadísticas a la app}};
\umlsdEnd{Ejemplo envío con necesidad de ACK}{sendNeededACK}
 
%\newpage
\subsubsection{Re-envío de mensajes}
%XXX-jblesa quita forward y ponlo en español XXX-cvillar ok.
\label{forwardProcess}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: mHandler<controlador>, incomingContentCoordinator(), outgoingContentProgressCoordinator()\\
%\end{files}
%\end{codeInvolved}

Este proceso es una mezcla de una recepción y un envío de mensajes,
reservada al papel de coordinador. Este proceso comienza con la
recepción (en el nodo coordinador) de un mensaje originario en un nodo
normal cuya lista de nodos destinatarios atañe a más nodos de los dos
implicados en esta comunicación. En esta lista puede estar o no
incluido el coordinador. Si está incluido como paso inicial
presentaremos el mensaje a la aplicación como hemos descrito en la
recepción de mensajes. Acto seguido procederemos al re-envío de
éste. Para ello, como vimos en la sección anterior, tenemos que
conocer:
\begin{enumerate}
\item Lista de destinatarios: cuáles son los siguientes nodos a los que enviar el mensaje
(prestando especial atención a que si es un mensaje dirigido a todos,
no volver a enviarlo al nodo originario de la comunicación).
\item El mensaje a enviar: el que hemos recibido, sin modificaciones.
\item Un parámetro que antes obviamos que sirve para identificar que se trata de un re-envío.
\end{enumerate}

%XXX-jblesa La ultima frase no se entiende... ``el mensaje...'' XXX-cvillar, con la lista queda mejor?

Esta elusión tiene como motivación haber facilitado la lectura de secciones anteriores al no añadir otra pieza más al rompecabezas. Nuestro flujo de trabajo necesita transmitir a través de todas las capas (servicio, controlador y capas inferiores, si intervienen) qué aplicación es la originaria del mensaje para poder ofrecerle una respuesta cada vez que envie datos a través del servicio. En el caso de un re-envío, el mensaje se recibe por la red por tanto no hay aplicación originaria de este mensaje en el nodo. No se puede utilizar el ``Código de aplicación'' grabado en el mensaje de datos, entre otras razones porque desembocaríamos en una situación en la que, después de re-enviar el mensaje, se entregaría a la aplicación que tuviese el mismo valor del ``Código de aplicación'' que el leído en el mensaje una confirmación a un mensaje de la que no es originaria. 

El parámetro por tanto es una simple \String{} que representa, o al \textit{Messenger} de la aplicación, para poder ponerse en contacto con ella o si ésta no existe una \String{} especial que marque la situación de re-envío.
De esta manera uniformamos el valor de este campo al tratarse en ambos casos de \Strings{} e indirectamente evitamos serializar un objeto complejo como es el \textit{Messenger} de \android{} o ubicarlo en un sitio que no está pensado para él: al intervenir en este proceso varias capas de la arquitectura si hubicasemos el objeto en el campo (\textit{msg.replyTo}) se usaría con otro propósito al pensado por la plataforma \android{}, lo que hace poco claro el código.\\

Es necesario transmitir este parámetro a través de todo el flujo de envío ya que son procesos que pueden no resolverse en la misma petición, además son sin memoria y pueden ser disparados por distintas aplicaciones en cualquier momento donde además el preservamiento del orden entre distintos procesos de envío no está garantizado.

%Las \Strings{} especiales que representan la situación de re-envío y que son claves para que el flujo del proceso actúe en consecuencia son: \textit{``forward-me''} y \textit{``forward-not-me''} para referirse tanto a la situación en la que el coordinador forma parte de la lista del mensaje que se re-envía, como a cuando no.

Al igual que en un envío normal, almacenamos el mensaje en la cola y lo enviamos. Al recibir por parte del controlador el mensaje descrito en la tabla~\ref{tab:messageWriteController} en vez de trasladar el mensaje a la aplicación (dado que no existe) como se hace en el envío, es aquí dónde el flujo se da cuenta que es un re-envío y puede confeccionar el mensaje de confirmación (ver tabla~\ref{itm:ackMessage}) que enviaremos al nodo originario del mensaje de datos.


%------------------------------
\subsection{Sensado del entorno compartido y política cognitiva}
\label{subsec:senseAndPolicy}
Los parámetros del entorno que son de nuestro interés son el  \ac{RSSI} (intensidad de señal) de la red \wifi{} a la cual estamos conectados y la tasa de envío de mensajes de datos. El sensado del entorno se realiza en varios puntos de la arquitectura: \var{Sensado} y \var{Gestor del Sensor}. Esta información se comparte mediante señalización (ver tabla~\ref{itm:scanMessage}) con el coordinador de forma periódica. Éste al recibirla dependiendo de la prioridad con la que venga marcada se limita a guardarla en su módulo \var{Repositorio} o a hacer un análisis rápido de la situación que desemboque en la toma de ciertas decisiones.
%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje SCAN}
  \protobufItem{Tipo}{Valor ``RESPONSE'' del enumerado ``MessageType''.}
  \protobufItem{Mensaje de respuesta}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':}
	\begin{description}
		\protobufItem{What}{Valor ``SCAN'' del enumerado ``AskType''.}
		\protobufItem{Mensaje de SCAN}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':}
			\begin{description}
				\protobufItem{Prioridad}{Un enumerado (Priority) con la urgencia del sensado, toma dos valores {\small Priority.TASK} para sensados normales y {\small Priority.URGENT} para marcar que la información del entorno es sensible.}  
				\protobufItem{RSSI}{Un \integer{} con el nivel de señal de la red \wifi{} a la que estamos conectados (-9999 si no estamos en ninguna).}
				\protobufItem{Intervalo promedio envío de mensajes}{Un \double{} con el resultado promedio móvil del intervalo medido en segundos entre la llegada de mensajes de datos por parte de las aplicaciones.}
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SCAN}{scanMessage}
}
%%%%%%%%%%%%%%%%%%%%%%%%_
\subsubsection{Parámetro del entorno: RSSI}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: normalCognitiveTask(), mWifiAdapter.getConnectionInfo()\\
%\end{files}
%\end{codeInvolved}

Para medir la intensidad de señal podemos utilizar de manera activa la \ac{API} de \android{} obteniendo el valor de la potencia de señal medida en dBm. También de una manera indirecta, aprovechamos los mensajes que lanza el sistema \android{} con información acerca de este parámetro. El registro se efectúa cuando se inicializa el servicio y nos desregistramos (para no dejar fugas de memoria al no liberar su reserva) al finalizar el servicio. Así las diferentes políticas cognitivas tienen disponible este parámetro a lo largo de toda la vida del servicio.\\
 
%XXX-jblesa Quita memory leaks XXX-cvillar vale.

En nuestra arquitectura utilizamos estos dos puntos de medida para este parámetro, el primero está localizado en la tarea cognitiva del \var{Optimizador} que guarda en el \var{Repositorio} el dato para usos futuros. El otro punto reside en las notificaciones, éstas nos ayudan a actuar con el menor tiempo de respuesta, ya que si detectamos una situación que entrañe riesgo podemos compartir esta información sin esperar a la tarea cognitiva donde realizamos entre otras cosas el sensado del entorno. Al recibir esta información urgente el coordinador vuelve a evaluar estos datos para evitar cambios de contexto disparados por umbrales que no concuerden entre los dos nodos. 

\subsubsection{Parámetro del entorno: Intervalo promedio envío de mensajes}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: normalCognitiveTask()\\
%\textbf{DataMessageQueue}: getAvgArrivalRateUpdateTillNow()
%\end{files}
%\end{codeInvolved}

En este caso la medición se va confeccionado cada vez que una aplicación entrega un mensaje de datos al servicio para su envío. Al añadirlo a la cola registramos el tiempo que ha pasado desde la última vez, si tenemos suficientes registros olvidamos el último antes de añadir este nuevo. Esto nos permite realizar promedios móviles que se centren en una situación cercana al momento actual para extraer información reciente y no condicionada excesivamente por eventos pasados.\\

En el módulo \var{Optimizador} calculamos de manera periódica la media de estos valores. Se da la situación de que el promedio sólo cambia al incluir nuevos mensajes en la cola, desembocando en que si no se producen nuevas inclusiones se obtiene el mismo valor del intervalo de envío de mensajes en ejecuciones consecutivas de la tarea cognitiva, desvirtuando este valor. Necesitamos algún mecanismo que sin desfigurar los datos, refleje esta situación de no envío y por tanto evidenciar un aumento del promedio.

Para ello en el momento de la transmisión de los parámetros del entorno al coordinador, obtenemos el promedio de las muestras tomadas y lo recalculamos teniendo en cuenta el tiempo actual. Este cómputo no afecta al promedio de las muestras tomadas pues no se incluye como si fuera una muestra más, evitando desfigurar resultados posteriores.

\subsubsection{Política cognitiva}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: mayTakeAdvantageOfBT() mayTakeAdvantageOfWiFi(), sendTroublingRssi(), coordinatorCognitiveTask()
%\end{files}
%\end{codeInvolved}
La política cognitiva implementada es competencia del nodo coordinador. Esta política tiene en cuenta tanto los parámetros propios del nodo coordinador como el sensado del entorno propocionado por los demás nodos. El análisis de los datos de sensado recae fundamentalmente en el nodo coordinador. Sin embargo para evitar situaciones de pérdida de nodos, el nodo normal avisa de forma activa si su \ac{RSSI} decae por debajo de un umbral.

La política actúa unicamente sobre el cambio de interfaz, que obedece a estos motivos:
\begin{description}
	\item[De Wi-Fi a Bluetooth] Por pérdida de la señal.
	\item[De Bluetooth a Wi-Fi] Por el aumento de la tasa de envío de mensajes de datos en la red.
\end{description}

%------------------------------
\subsection{Cambios de contexto}
Con la información recogida del entorno tanto por el mismo nodo como por sus compañeros podemos tomar decisiones sobre la estabilidad de la red y conforme a experiencias pasadas colocar a ésta en el lugar que mejor se adapte. Necesitamos una serie de protocolos que mantengan la integridad de la red y marquen los pasos a seguir cuando hay un cambio de interfaz.

\subsubsection{Cambio de contexto con interfaz destino WiFi}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfWiFi(), contextChangeToWiFi(), SetupWifiInterface (asyncTask), mHandlerWF, scheduleTaskWifi(), sendEndSwitchMessage(), endContextualChange()
%\end{files}
%\end{codeInvolved}

\umlsdInit
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B}
	\callSelf{nc}{Configurar \wifi{} y obtener ip}
	
	\mess{nc}{Switch: ip, ssid}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{\shortstack{Configurar \wifi{}\\y apagar interfaz origen}}	

	\mess{b}{\bsq{HelloPacket}}{nc}	
	\mess{nc}{ACK \bsq{HelloPacket}}{b}
	\prelevel\callSelf{b}{Parar envío \bsq{HelloPacket}}\prelevel	
	\mess{a}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{a}
	\prelevel\callSelf{a}{Parar envío \bsq{HelloPacket}}\prelevel
	\postlevel
	\callSelf{nc}{Apagar interfaz origen}
	\prelevel\mess{nc}{End Switch}{a}	
	\mess{nc}{End Switch}{b}
\umlsdEnd{Ejemplo cambio de contexto hacia \wifi{}}{switchToWifi}

Cuando el coordinador ejecuta su tarea cognitiva va rescatando del \var{Repositorio} para cada nodo los últimos escaneos de éste obteniendo un promedio y una tendencia de los datos de sensado. Evalúa estos datos y decide si es necesario un cambio de interfaz. En caso positivo, obtenemos una lista de los nodos activos en la red, los marcamos como inactivos e informamos a las aplicaciones sobre el nuevo evento (\Scst{EVENT\_INTERFACE\_SWITCH\_TO\_WIFI}, tabla~\ref{tab:events}) y configuramos la interfaz de \wifi{}. Para ello utilizamos el mismo prodecimiento usado en~\ref{subsec:configInterface} con unos pasos extras: una vez nos hemos conectado a la red enviamos un mensaje de señalización (a través de la interfaz actual, aún \wifi{} no es efectiva) a la lista de nodos que sacamos informandoles del cambio y de la información necesaria para llevarla a cabo (ver tabla~\ref{itm:switchToWifi}).
%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje SWITCH hacia \wifi{}}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la direción MAC de \bt{} del nodo.
  \item[Mensaje de señalizacion]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``SWITCH'' del enumerado ``SignalType''.
		\item[Mensaje de SWITCH] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Interfaz destino] Valor ``TO\_WIFI'' del enumerado ``ToInterface''.  
				\item[SSID] Una \String{} con el nombre de la red \wifi{} a la que se va a realizar el cambio.
				\item[BSSID] Una \String{} con la dirección MAC del punto de acceso para evitar cualquier equívoco.
				\item[Dirección IP coordinador] Una \String{} con la dirección IP del nodo.
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SWITCH hacia \wifi{}}{switchToWifi}
}
%%%%%%%%%%%%%%%%%%%%%%%%_ 
Al terminar de configurar la interfaz (siendo ésta ya efectiva),
dejamos programado un \textit{timeout} que dispare el fin de cambio
contextual para evitar bloqueos porque algún nodo no responda. A partir de
ahora esperamos a que los nodos normales configuren su interfaz de
\wifi{} (antes apagarán su interfaz en curso, en este caso \bt{}) y
vayan entrando en la nueva red tal y como se contó en las
secciones~\ref{subsec:configInterface} y~\ref{subsec:enterInNetwork} de los procesos de red. 

%XXX-jblesa aqui has hecho referencia a la seccion enterInNetworks que
%es futura. XXX-cvillar no, es anterior.

El coordinador al recibir los \textit{``HelloPacket''} en vez de
seguir el flujo normal que consiste informar a todos los nodos de la
nueva entrada y al nuevo nodo informarle sobre el mapa de red, se
limita a enviarle un mensaje de confirmación indicándole que se ha recibido el paquete para que éste pare su envío. Así evitamos enviar muchos mensajes de señalización de una situación que es probable que cambie. Estos paquetes están enviados directamente a la \ac{IP} del coordinador (recogida del mensaje de señalización de cambio) para que haya más posibilidades de recepción. 

Si por algún casual el nodo normal terminase su ráfaga y no obtuviese respuesta el mismo entendería que el proceso de cambio de contexto ha acabado de manera insatisfactoria. En la tabla~\ref{itm:okSwitch} podemos ver detalle de este mensaje de confirmación de entrada en la red en situación de cambio de contexto.\\

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje confirmación cambio de contexto}   
	\item[Tipo] Valor ``RESPONSE'' del enumerado ``MessageType''.
  \item[Mensaje de respuesta]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[What] Valor ``SWITCH'' del enumerado ``AskType''.
	\end{description}
\protobufTableEnd{Campos del mensaje de confirmación entrada (\wifi{}) / interfaz lista (\bt{})}{okSwitch}
}
%%%%%%%%%%%%%%%%%%%%%%%%_
Si antes de que salte el \textit{timeout} programado, hemos recibido todos los \textit{``HelloPacket''} de todos los nodos que estaban formando la red, procedemos a finalizar el cambio de contexto. Si no, esperamos a que finalice el \textit{timeout}, situación en la que habremos perdido algún nodo. Tras este evento el nodo reacciona según sea su tipo:

\paragraph{Nodo coordinador} Al dispararse el final del cambio de contexto, apagamos la interfaz \bt{} y liberamos todos los recursos. Hemos mantenido la interfaz arriba hasta el último momento para no perder mensajes de datos si algún nodo actúa de manera incorrecta y envía estos mensajes en pleno cambio de conexto. Acto seguido se envía el mapa de red por medio de señalización a todos los nodos que formen ahora la red (idealmente todos los que la formaban antes del cambio), en la tabla~\ref{itm:endSwitch} se detalla el formato de este mensaje independiente de la interfaz de comunicación.

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje fin cambio de contexto}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la direción MAC de \bt{} del nodo (coordinador).
  \item[Mensaje de señalizacion]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``TOPOLOGY'' del enumerado ``SignalType''.
		\item[Mensaje de mapa de red] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Cambio] Valor ``ALL\_END\_SWITCH'' del enumerado ``TopologyChange''.  			
					\begin{description}
						\item[Representación de un nodo] Mensaje con los cambios que sirven para representar a nodo (ver tabla~\ref{itm:infoNode}). Tendremos tantas representaciones como nodos haya en la red.
					\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje finalización cambio de contexto}{endSwitch}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Notar que este mensaje es diferente para cada nodo ya que incluye la lista de nodos. Ésta se entrega de manera personalizada, incluyendo el resto de nodos sin contar a él mismo. Los últimos pasos para finalizar el cambio de contexto es intentar enviar los mensajes encolados (los mensajes que hayan entregado las aplicaciones mientras que el proceso de cambio de contexto esté vigente) y publicar hacia las aplicaciones registradas en el servicio el evento del fin de cambio de contexto que incluye la nueva interfaz, el estado de ésta y la lista de nodos que forman la red en este momento. Así como el vaciado de la cola de mensajes pendientes de envío.

\paragraph{Nodo normal} Al recibir el mensaje de señalización de cambio de contexto, procedemos a cancelar (de nuevo) el envío de \textit{``HelloPacket''} por si no hubiesemos recibido el mensaje visto en la tabla~\ref{itm:okSwitch}, informar a las aplicaciones el evento de fin de cambio de contexto con el nuevo mapa de red leído del mensaje de señalización y proceder al envío de los mensajes encolados mientras haya durado este proceso.

\umlsdInitTitle[!h]{Cambio de contexto, situación problemática}
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B} \newinst[1]{c}{nodo C}
	\callSelf{nc}{Configurar \wifi{} y obtener ip}
	
	\mess{nc}{}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\mess{nc}{Switch: ip, ssid}{c}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{}
	\prelevel\prelevel\callSelf{c}{\shortstack{Configurar \wifi{}\\y apagar\\interfaz origen}}
	
	\messFail{a}{\bsq{HelloPacket}}{nc}
	\messFail{c}{\bsq{HelloPacket}}{nc}	
	\messFail{a}{\bsq{HelloPacket}}{nc}
	
	\mess{b}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{b}
	\prelevel\callSelf{b}{Parar envío \bsq{HelloPacket}}\prelevel
	
	\mess{a}{\bsq{HelloPacket}}{nc}
	\mess{nc}{ACK \bsq{HelloPacket}}{a}
	\prelevel\callSelf{a}{Parar envío \bsq{HelloPacket}}\prelevel

	\postlevel\postlevel

	\draw[thick,->] (0.9,-8) -- (1.4,-8) node[anchor=south east] {\small\shortstack{\textit{Timeout}\\expirado\\en Coor-\\dinador}};
	\callSelf{nc}{Apagar interfaz origen}
	\prelevel\mess{nc}{End Switch}{a}
	\messFail{c}{\bsq{HelloPacket}}{nc}	
	\mess{nc}{End Switch}{b}
		
	\callSelf{c}{\small\shortstack{\textit{Timeout} expirado en\\ C: No hay respuesta\\a \bsq{HelloPacket}: no\\ en CWSN}}		
	\node[fill=blue!30, align=right] at (6,-11.7) {\small\shortstack{Situación normal de red\\ población: A, B y Coordinador}};
	%\node [draw, rotate=90] at(0,-3) (first) {Timeout};
	%\node at(-0.5,-3) (second) {a};
	%\draw[->,gray,rounded corners] (second) edge (first);
	
	%\draw[thick,->] (0.5,-4) -- (1,-4) node[anchor=south east] {Timeout expired};
\umlsdEnd{Ejemplo cambio de contexto hacia \wifi{} con pérdida de nodos}{switchToWifiFail}
~\\%ajustar espacios y que caiga por debajo de la imagen
\subsubsection{Cambio de contexto con interfaz destino Bluetooth}
%\begin{codeInvolved}
%\begin{files}
%\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfBT(), contextChangeToBT(), SetupBTinterface (asyncTask), mHandlerBt,  tellBTisUP(), scheduleEndSwitchBTRunnable (future) scheduleSetupBTRunnable (future) , sendEndSwitchMessage(), endContextualChange()
%\end{files}
%\end{codeInvolved}

\umlsdInit
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B}
	\mess{nc}{Switch}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{Configurar \bt{}}	

	\mess{a}{OK Switch}{nc}
	\mess{b}{OK Swtich}{nc}
	
	\callSelf{nc}{Configurar \bt{} y apagar interfaz origen}
	\begin{call}{nc}{connect()}{a}{conexión aceptada} \end{call}
	\begin{call}{nc}{connect()}{b}{conexión aceptada} \end{call}	
	\mess{nc}{End Switch}{a}
	\prelevel\callSelf{a}{Desconectar interfaz origen}
	\mess{nc}{End Switch}{b}
	\prelevel\callSelf{b}{Desconectar interfaz origen}
\umlsdEnd{Ejemplo cambio de contexto hacia \bt{}}{switchToBT}

Cuando se produce un cambio de interfaz a \bt{} el coordinador al igual que en el otro cambio de contexto obtiene una lista de quién está en la red y se marcan como inactivos. Comunicamos hacia las aplicaciones el nuevo estado de la red y procedemos a enviar un mensaje de señalización que marque a los demás nodos el evento de cambio de contexto hacia \bt{}
%Este mensaje tiene la disposición mostrada en la tabla~\ref{itm:switchToBT}\\
(ver tabla~\ref{itm:switchToBT}).

%%%%%%%%%%%%%%%%%%%%%%%%_
\comp{a implementación:\\
\protobufTableInit{Estructura mensaje SWITCH hacia \bt{}}   
	\item[Tipo] Valor ``SIGNALING'' del enumerado ``MessageType''.
	\item[Desde] Una \String{} con la direción MAC de \bt{} del nodo.
  \item[Mensaje de señalizacion]  Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Tipo'':
	\begin{description}
		\item[Señal] Valor ``SWITCH'' del enumerado ``SignalType''.
		\item[Mensaje de SWITCH] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``Señal'':
			\begin{description}
				\item[Interfaz destino] Valor ``TO\_BT'' del enumerado ``ToInterface''.   
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje SWITCH hacia \bt{}}{switchToBT}
}
%%%%%%%%%%%%%%%%%%%%%%%%_

Una vez enviado, programamos la tarea de configurar la interfaz de
\bt{} en el coordinador con un margen de tiempo suficiente para
obtener las respuestas de los nodos normales, que al recibir la
señalización configuran su interfaz \bt{} e informan a sus
aplicaciones del nuevo estado. Una vez levantada, comunican al
coordinador, a través de la interfaz en curso (\bt{} aún no es efectiva para envíar mensajes, ya que entre otras cosas no hemos establecido ninguna conexión con el coordinador) que la interfaz destino está lista para aceptar conexiones. Para ello utilizamos el mensaje ya visto en la tabla~\ref{itm:okSwitch}, reutilizamos este mensaje de confirmación que no lleva ninguna información especial y que por el contexto le damos el significado de estar preparado (en la otra ocasión el contexto le daba el significado de confirmación de entrada en la red).\\

Este mensaje le sirve al coordinador para saber que el nodo ya está listo y cuando recibe todas las confirmaciones (o salta el timeout programado anteriormente) procede a configurar su interfaz de \bt{} pasándole la lista de nodos que obtuvimos. La configuración de la interfaz incluye una ronda de conexiones a los nodos que formaban la red antes del cambio, que es pasada como parámetro. Una vez terminado ejecuta los mismos pasos descritos en la sección anterior para terminar el cambio de contexto. Salvo que en el mensaje de señalización de fin de cambio de contexto (ver tabla~\ref{itm:endSwitch}) la representación de cada nodo no incluye el campo ``Dirección IP''.\\
%%diseño+implementacion
\comp{I+D:
Por su parte, el nodo normal, al configurar su interfaz \bt{} y después de enviar la confirmación al coordinador de que está listo, programa una tarea (implementada gracias al esquema de programación basado en \textit{Runnables} alojados en la interfaz \textit{Future} y ejecutados en hebras gestionadas por el objeto \textit{Executor}) para salir de la situación de cambio de contexto por si no recibe ninguna conexión entrante o por si no recibe el mensaje de señalización de fin de cambio de contexto. Así se garantiza que ningún nodo se quede en \textit{deadlock} y el flujo siempre se ejecuta de principio a fin.
}
%%----

Por su parte el nodo normal al configurar su interfaz \bt{} y después de enviar la confirmación al coordinador de que está listo, programa una tarea para salir de la situación de cambio de contexto por si no recibe ninguna conexión entrante o por si no recibe el mensaje de señalización de fin de cambio de contexto. Así se garantiza que ningún nodo se quede en \textit{deadlock} y el flujo siempre se ejecuta de principio a fin.

\umlsdInitTitle[!h]{Cambio de contexto, situación problemática}
	\newthread{nc}{nodo Coordinador} \newinst[2]{a}{nodo A} \newinst[1]{b}{nodo B} \newinst[1]{c}{nodo C}
	\mess{nc}{Switch}{a} 
	\prelevel\mess{nc}{}{b}
	\prelevel\mess{nc}{}{c}
	\prelevel\callSelf{a}{}%\shortstack{Configurar\\ \wifi{}}}
	\prelevel\prelevel\callSelf{b}{Configurar \bt{}}
	\callSelf{c}{\shortstack{Configurar \\\bt{}: NOK}}

	\mess{a}{OK Switch}{nc}
	\mess{b}{OK Swtich}{nc}
	\postlevel\postlevel\postlevel
	\draw[thick,->] (0.9,-6) -- (1.4,-6) node[anchor=south east] {\small\shortstack{\textit{Timeout}\\expirado\\en Coor-\\dinador}};
	\callSelf{nc}{Configurar \bt{} y apagar interfaz origen}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{a}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{b}{} \end{messcall}
	\begin{call}{nc}{connect()}{b}{conexión aceptada} \end{call}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}
	\begin{messcall}{nc}{connect()}{c}{} \end{messcall}	
	\mess{nc}{End Switch}{b}
	\prelevel\callSelf{b}{Desconectar interfaz origen}
	\postlevel\callSelf{a}{\textit{Timeout} expirado en A y C: no en CWSN}
	\prelevel\prelevel\callSelf{c}{}
	\node[fill=blue!30, align=right] at (6,-18.3) {\small\shortstack{Situación normal de red\\ población: B y Coordinador}};
\umlsdEnd{Ejemplo cambio de contexto hacia \bt{} con pérdida de nodos}{switchToBTFail}

%-------------------------------------------------------------------
\clearpage
\section{Aplicación utilitaria servicio cognitivo}
\label{sec:app}
%-------------------------------------------------------------------
Para hacer uso y probar las características cognitivas de nuestra arquitectura se ha diseñado una aplicación que se monta sobre el módulo o servicio cognitivo. La aplicación desarrollada además de cumplir la \ac{API} en su totalidad (incluida la denominada parte oculta) permite acceder a los parámetros de la politica cognitiva y los timeouts utilizados en los procesos de red.\\

La aplicación simula el comportamiento de un sensor cuyo valor lo introduce el usuario y monitoriza el estado del servicio gracias a los mensajes de información que se envían desde el propio servicio o módulo cognitivo. Se estrutura en tres secciones: la principal que da cabida al objetivo de la aplicación y permite en caso de \bt{} la conexión manual al nodo. En una segunda sección se muestra (si el usuario lo requiere desde la configuración) unas funciones de \textit{test} entre las que podemos enumerar:
\begin{description} 
	\item[Petición, respuesta] Permite, dependiendo del tipo de nodo, guardar una respuesta en el caso de nodos normales o pedir esta información para los nodos coordinadores. Con esta función se habilita un mecanismo de petición de información muy útil para la arquitectura cognitiva para la compartición de datos de sensado.
	\item[Encolamiento de mensajes] Debido a que la aplicación actualiza de forma instantánea la lista de nodos al recibir un evento de cambio de contexto, se inabilita la elaboración de mensajes de datos que entregar al servicio debido a que no es posible construir una lista de destinatarios válida puesto que el único valor seleccionable por el usuario es \bsq{0} cuyo significado es la ausencia de nodos. Al intentar entregar un mensaje de datos al servicio con este valor, la validación que existe en la aplicación impide finalmente su entrega.\\
Por este motivo no es posible generar un mensaje válido que se entrege
al servicio en el momento que produzca su encolamiento, por lo que la
aplicación usuaria permite simular el encolamiento. Al pulsar el
botón diseñado a tal efecto, se nos pregunta a través de una cadena de
diálogos el mensaje a encolar y a que destinatarios debe dirigirse. El servicio recoge esta información por medio de una solución alternativa.

%XXX-jblesa workaround y shortcut en español XXX-cvillar, cambiaré workaround por solución alternativa.

	\item[Vaciado de la cola de mensajes] El vaciado de la cola de mensajes pendientes de envío se produce al efectuarse un cambio de contexto, una vez las funciones de red están nuevamente activas, si se quiere forzar el vaciado de esta cola por motivos de \textit{test} se ha habilitado un botón junto al de la función anterior a tal efecto.
	\item[Envío periódico datos sensor] Una característica muy presente en redes de sensores es la que los sensores suelen enviar datos de forma periódica. Simulamos esta característica en la aplicación tras selecionar el periodo, los datos enviados consiste en una \String{} más un número que incrementamos en cada envio. 
\end{description}
Por último, en una tercera sección que alberga la configuración. En ella podemos elegir:
\begin{description}
	\item[Ajustes del servicio] Tipo y nombre del nodo, periodo tarea cognitiva y valores de la política que regula los cambios de contexto (ver~\ref{subsubsec:policyImpl}).
	\item[Ajustes de la aplicación] Código de aplicación, papel del nodo y si el texto que se usa como valor del sensor debe borrarse después de su envío al servicio.
 \item[Ajustes de test] Toda la configuración de la segunda sección como: si ha de visualizarse en la pantalla principal, con qué interfaz debe arrancar el servicio si la sección de \textit{test} está activada y los \textit{timeouts} utilizados para los cambios de contexto.
\end{description}

La aplicación proporciona validaciones adicionales para evitar el incumplimiento de la \ac{API} o la interacción con el servicio si no es necesaria. No se permite:
\begin{itemize}
	\item El envío de mensajes de datos si no está establecida una \ac{CWSN}.
	\item El envío de mensajes no dirigidos a un nodo válido (tanto si es inactivo pues no se permite su selección al no estar presente entre los \textit{items} que se presentan al usuario, como si el único valor que se presenta es la ausencia de nodos).
	\item La actualización vacía de la configuración. Es decir si no hay un cambio en la configuración no se traspasan las modificaciones necesarias al servicio para su actualización.
\end{itemize} 

\begin{figure}
\begin{center}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/settings}%
		\caption{settings1}%
%XXX-jblesa En español los captions

	\end{minipage}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/settings2}%
		\caption{settings2}%
	\end{minipage}%
	%\caption{settings}%
\end{center}
\end{figure}


\begin{figure}
\begin{center}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/listnodes}%
		\caption{main ui}%
	\end{minipage}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=.6\linewidth]{Imagenes/Bitmap/design/menu}%
		\caption{menu}%
	\end{minipage}%
	%\caption{settings}%
\end{center}
\end{figure}

\begin{figure}
\begin{center}%
		\includegraphics[width=.3\linewidth]{Imagenes/Bitmap/design/uitest}%
		\caption{testing ui}%
\end{center}
\end{figure}

%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
