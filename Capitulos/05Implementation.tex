%---------------------------------------------------------------------
%
%                          Capítulo 5
%
%---------------------------------------------------------------------
\chapter{Implementación}
\label{chap:implementation}
\begin{FraseCelebre}
	\begin{Frase}
	Cuando cortejas a una bella muchacha, una hora parece un segundo. Pero si te sientas sobre el carbón al rojo vivo, un segundo parecerá una hora. Eso es relatividad.
	\end{Frase}
	\begin{Fuente} Albert Einstein \end{Fuente}
\end{FraseCelebre}
\begin{resumen}
Este capítulo es complementario al de diseño. Existe una delgada línea entre diseño e implementación que es muy fácil traspasar, quizás debido a que según cómo se mire la implementación puede interpretarse como el diseño de la siguiente capa a lo largo de éstas según bajamos hacia el \textit{hardware}. En este capítulo se intenta explicar el cómo se ha hecho, es decir, qué componentes \textit{software} se han utilizado para tal propósito.
\end{resumen}

%-------------------------------------------------------------------
\section{Detalles de implementación de la arquitectura cognitiva}
%-------------------------------------------------------------------
\label{sec:detallesImplementacion}

Para la implementación de los distintos bloques de la arquitectura se han elegido los mecanismos que mayor grado de independencia obtienen y que ayudan a estructurar los procesos en capas y tener puntos de intercomunicación entre éstos fuertemente marcados. La programación basada en objetos y el paso de mensajes entre distintas entidades ayudan a resolver las directrices de modularidad marcadas en diseño.

\subsection{Interfaz Aplicación - Módulo cognitivo}
Como se vio en análisis~\ref{sec:android}, de entre las formas de recrear la interfaz cliente-servidor necesaria para la confección de un servicio con ataduras, escogemos aquella que se realiza a través de un objeto \textit{Messenger}. De esta forma la interfaz no declara métodos para su llamada desde el cliente, si no que la interacción con el \var{Módulo cognitivo}, en adelante servicio, se basa en el intercambio de mensajes que son recogidos en su método \textit{handleMessage()} declarado en su \textit{Handler}. Por consiguiente tenemos una interfaz mucho más flexible y actualizable a cambio de estar abierta a errores: mensajes intercambiados sin fijarse a las reglas de la \ac{API} del servicio. Además se garantiza un entorno multihebra seguro que encola las solicitudes de los diferentes clientes al ser entregadas al servicio en orden una vez que se ha atendido a la petición anterior. Esta tarea la realiza la hebra que maneja el \textit{Handler}.  
La interfaz o el objeto \textit{IBinder} se construye gracias al
método \textit{getBinder()} del objeto \textit{Messenger} creado
gracias al \textit{Handler} implementado en el servicio.

%XXX-jblesa La referencia sec:android no funciona. Quita bound service
%y ponlo en español. Quita thread-safe y ponlo en español XXX-cvillar ok

A su vez las aplicaciones deben declarar su propio \textit{Handler} para poder recibir mensajes desde el servicio, para ello se deberá informar al servicio cuál es el objeto \textit{Messenger} de la aplicación, así habilitamos también en sentido contrario la comunicación capacitando al servicio que nos comunique datos en cualquier instante de tiempo. Al tratarse de la misma implementación, los envíos desde el servicio serán encolados en el \textit{Handler} de la aplicación, que no debe prever mecanismos multihebra para atender a éstos.\\

%XXX-jblesa Quita multi-thread y ponlo en español XXX-cvillar ok.

\subsection{Módulo o Servicio cognitivo}
El servicio se constituye en dos clases con una relación de heredamiento (entre ambas). La clase padre \class{CognitiveLayer\allowbreak\_common\allowbreak\_Service} extiende de la clase servicio de \android{} (ver sección~\ref{subsec:service}). Su función es la de encapsular las partes que todo servicio cognitivo tendría que satisfacer:
\begin{itemize}
	\item Métodos de inicialización de los componentes necesarios no específicos y su destrucción, (\textit{onCreate(), onDestroy()}).
	\item Inicialización del \textit{Handler} para la comunicación con las aplicaciones y manejo de mensajes de registro y no reconocidos (\var{Gestor del Sensor}).
	\item Obtención de la referencia e inicialización del \var{Repositorio}.
	\item Programación de la tarea periódica (forma parte del módulo \var{Optimizador}) y la obtención de recursos para evitar que \android{} duerma al proceso en el trascurso desde la recepción de la alarma en un \textit{BroadcastReceiver} hasta la llamada a \textit{onStartCommand()} y la ejecución de éste por completo.
\end{itemize} 

Dejando las acciones específicas y propias de cada \ac{CWSN} para la clase hija \class{CognitiveLayer\allowbreak\_specific\allowbreak\_Service}, entre las que destacamos:
\begin{itemize}
	\item Implementación de la mayor parte de la \ac{API} del servicio.
	\item Implementación de los diferentes \textit{Handler} usados en la comunicación con las interfaces (\var{Gestor de Interfaces})
	\item Implementación del resto de la arquitectura cognitiva: \var{Optimizador}, \var{Ejecutor}, \var{Políticas}, \var{Acceso} y parte del módulo \var{Sensado}.
	\item Implementación de procesos de red que usan los distintos módulos de la arquitectura: cambios de contexto, confeccionador e interpretador de mensajes de red, encaminamiento\ldots
\end{itemize}

Realmente no hay una relación de padre-hijo, si no más bien de
complementación. Las competencias entre ambas tampoco están muy bien
delimitadas, pero sí es cierto que se consigue
cierta encapsulación y nos ayuda a centrarnos exclusivamente en la
programación del proceso cognitivo más que en los detalles necesarios
para proveer del entorno necesario para llevar a cabo esa tarea. 

%XXX-jblesa en espñaol parent-son, peer-to-peer. XXX-cvillar ok.

\comp{diseño? analisis?:
El apellido cognitivo supone una abstracción del modelo de comunicaciones. La aplicación que use de este modelo sólo tiene que entender del dato que quiere enviar o recibir y del destinatario de ese mensaje. En \android{} las aplicaciones son procesos que interactúan con el usuario, están formadas por varios componentes. Entre los distintos que nos provee \android{} el más adecuado para montar nuestra arquitectura es el servicio. Permitiéndonos estructurar nuestro modelo de capas ubicando en este componente todo lo que tenga que ver con el establecimiento, control, transmisión y recepción de señalización y datos.
}

\paragraph{Optimizador, programación tarea} Se basa en el sistema de alarmas de \android{} \cite{alarms}, este sistema es útil para realizar periódicamente operaciones sin tener en cuenta el ciclo de vida de la aplicación (en este caso el servicio cognitivo). Una alarma puede ser usada para lanzar un servicio en conjunción con un \textit{BroadcastReceiver}. Al dispararse la alarma gracias a la clase \class[android.app]{AlarmManager} y efectuarse el \textit{PendingIntent} descrito en ella, se ejecuta el método \textit{onReceive()} del \textit{BroadcastReceiver} (puesto en el \textit{Intent}). Este método lanza la iniciación del servicio cognitivo (ver~\ref{subsec:broadcastReceiver}). Entre que se termina de ejecutar el método y empieza a ejecutarse el servicio, ocurre un espacio de tiempo \cite[p.~328-342]{busyCoder} en el que nuestro dispositivo puede dormirse. Por lo tanto debemos adquirir en el método \textit{onReceive()} un \textit{Wakelock} que impida que el dispositivo pueda dormirse en este espacio de tiempo y liberarlo una vez se ha terminado de ejecutar las operaciones deseadas en el servicio.\\
Para realizar esto, llamamos a un método (que debe ser estático para
poder llamarlo sin tener referencia al objeto) de nuestro servicio (alojado en
la clase ``padre'') que adquiere este cerrojo e inicia el servicio, es decir ejecuta el método \textit{onStartCommand()}.\\

%Cuando un servicio es iniciado (se crea si no estuviese iniciado o
%vinculado previamente) se ejecuta el método \textit{onStartCommand()} una vez terminada su ejecución, no se produce a la destrucción hasta que se pare el servicio. 
Nuestro servicio permite ser vinculado para interactuar con las aplicaciones y permite ser iniciado para realizar operaciones de forma periódica, esta  iniciación la realiza el mismo servicio gracias a la sucesión de alarmas que se programan al crearse el servicio (método \textit{onCreate()}). Al tener un cambio en el ciclo de vida del servicio, la extinción de éste tiene que ser llevada a cabo por él mismo cuando detecte que no hay aplicaciones sobre él a las que dar soporte. La consecuencia de haber una inicialización es que la falta de vinculación no detendrá al servicio, siendo preciso la llamada al método \textit{stopSelf()} cuando sea oportuno (ver sección~\ref{subsec:salidaRedImpl}).
%-------------------
\subsection{Repositorio}
Utilizamos la tecnología de base de datos de \texttt{Sqlite3} para implementar nuestro repositorio. La principal razón radica en que se trata de una base de datos integrada en \android{} lista para usarse que consume pocos recursos y se adapta bastante bien a casi todas las necesidades que pueda tener una aplicación móvil.\\ 

\figura{Vectorial/implementation/repository}{width=.76\textwidth}{fig:repositorio}{Repositorio, estructura interna}

El modelo de capa de datos se basa en la propia base de datos \class[android.database.sqlite]{SQLiteDatabase} y una clase auxiliar para la creación, actualización, apertura y liberación de ésta: \texttt{MySQLiteHelper}. Éstas son englobadas en otra clase que abstrae aún más al servicio de la tecnología usada y de su tratamiento, ya que ofrece la funcionalidad de introducir o hacer consultas sobre datos a través de métodos como si se tratase de un objeto corriente más, se trata de la clase \class[util]{CognitiveDataSource}. \android{} suministra una \ac{API} para la realización de \textit{insert, update, remove} o \textit{query} a través de métodos que toman como parámetros los distintos datos de una sentencia o nos permite lanzar en crudo la misma sentencia de base de datos. Esto último tiene como riesgo que si la sintaxis cambia en el lenguaje \ac{SQL} nuestra sentencia puede verse afectada, sin embargo si se realiza de la primera forma, somos inmunes a los cambios en el lenguaje debido a que la sentencia se construye en tiempo de ejecución en base a la tecnología que se posea en ese momento.
La manera de facilitar datos a estos métodos es a través de \textit{arrays} de \String{s} en el caso de consultas y eliminaciones o utilizando el objeto \texttt{ContentValues} para nuevas inserciones o actualizaciones. El resultado lo obtenemos en un objeto \texttt{Cursor}. Para ayudar a encapsular tanto la entrada como la salida en la capa de datos, nos ayudamos de las siguientes clases que traducen el objeto \texttt{Cursor} a objetos de clase:
\begin{itemize}
	\item \class[util]{Node}
	\item \class[util]{Scan}
	\item \class[util]{StatusInformation}
\end{itemize}

\subsubsection{Esquema base de datos}

Vimos en la sección \ref{subsec:repository} la información que necesitamos guardar, ésta la estructuramos en tres tablas formado el siguiente esquema de base de datos:

\ddbbTableInit{Me}
\ddbbTableRow{PK}{\_id}{Un \integer{} auto incrementado}
\ddbbTableRow{}{currentInterface}{Una \String{}}
\ddbbTableRow{}{state}{Una \String{} no nula}
\ddbbTableRow{}{stopped}{Un \textit{boolean} no nulo}
\ddbbTableRow{}{periodTask}{Un \integer{} no nulo}
\ddbbTableEnd{Estructura tabla \texttt{Me}}{tableMe}
 
La tabla \var{Me} (tabla~\ref{tab:tableMe}) contiene información acerca del estado del servicio, tiene un registro único que vamos actualizando conforme cambie la situación. El campo \var{currentInterface} contiene los valores \bsq{\textit{bt}} o \bsq{\textit{wifi}} y \var{state}: \bsq{\textit{down}}, \bsq{\textit{listen}}, \bsq{\textit{connected}}. El campo \var{stopped} nos indica que el servicio ha finalizado voluntariamente si tiene el valor \true{} en el momento de inicializar el servicio. La precisión del campo \var{periodTask} es de milisegundos.

\ddbbTableInit{Nodes}
\ddbbTableRow{PK}{id\_node}{Un \integer{} auto incrementado}
\ddbbTableRow{}{name}{Una \String{} no nula}
\ddbbTableRow{}{role}{Una \String{} no nula}
\ddbbTableRow{}{type}{Una \String{} no nula, defecto: \bsq{n}}
\ddbbTableRow{}{macBT}{Una \String{} no nula, única}
\ddbbTableRow{}{ipAddress}{Una \String{}}
\ddbbTableRow{}{id\_coordinator}{Un \integer{}}
\ddbbTableRow{}{active}{Un \textit{boolean} no nulo, defecto: \bsq{0} {\small se interpreta como \false{}}}
\ddbbTableEnd{Estructura tabla \texttt{Nodes}}{tableNodes}

La tabla \var{Nodes} (tabla~\ref{tab:tableNodes}) alberga la representación de todos los nodos conocidos. Con el campo \var{active} discernimos si forman parte de la actual \ac{CWSN}. Esta tabla nos permite crear el mapa de red y construir las diferentes rutas para el encaminamiento de paquetes gracias al campo \var{id\_coordinator}. Notar que se necesita que el campo \var{macBT} sea único, pero no se declara como clave primaria de la tabla puesto que es mejor tener un índice dedicado a ello: \var{id\_node}. Al crear esta tabla rellenamos el primer registro con los valores del propio nodo, así por diseño, el identificador \bsq{1} hace referencia siempre a sí mismo.

Entre los distintos campos hay varios con codificación fija:
\begin{itemize}
	\item El campo \var{role} utiliza el símbolo \bsq{p} para representar a un usuario primario y el carácter \bsq{s} para denominar a un usuario secundario, (\bsq{u} para valor desconocido).
	\item El campo \var{type}: \bsq{n} se utiliza para denominar a un nodo normal, mientras que \bsq{c} se usa para nodos coordinadores, (\bsq{u} para valor desconocido). 
\end{itemize}

\ddbbTableInit{Scans}
\ddbbTableRow{PK, FK(PK Nodes)}{id\_node}{Un \integer{} no nulo}
\ddbbTableRow{PK}{id\_scan}{Un \integer{} no nulo}
\ddbbTableRow{}{rssi}{Un \integer{}}
\ddbbTableRow{}{throughput}{Un \double{}}
\ddbbTableRow{}{timestamp}{Un \textit{datetime}, defecto \var{CURRENT\_TIMESTAMP}}
\ddbbTableEnd{Estructura tabla \texttt{Scans}}{tableScans}

La tabla \var{Scans} (tabla~\ref{tab:tableScans}) hace referencia a los datos de sensado del entorno. La clave primaria está formada por el par (\var{id\_node}, \var{id\_scan}). Vinculamos esta tabla con la tabla \var{Nodes} gracias a la clave foránea: \var{id\_node}, que hace referencia al campo \var{id\_node} de \var{Nodes} de tal forma que no se permite introducir datos de sensado de nodos que no existan, así como borrar nodos en la tabla \var{Nodes} si existen datos en la tabla \var{Scans} para no dejar huérfano el dato. La manera de introducir nuevos valores implica una consulta previa para averiguar cuál es el número de \var{id\_scan} que corresponde al nodo al que queremos vincular el dato. Este proceso está encapsulado en el método que se publica en la capa de datos siendo éste transparente al servicio.

La precisión del intervalo guardado en el campo \var{throughput} es un número real expresado en segundos y el campo \var{rssi} expresa el valor en dBm en un número entero. 
%----------------------


\subsection{Mensajes enviados por la red}
\label{subsec:networkMessages}
Estos mensajes son el resultado en última instancia del submódulo
\var{Gestor de Inter\-faces} que es el punto de salida del servicio cognitivo
hacia los \texttt{Controladores} de interfaz para su envío por el
canal de datos o por el canal \var{VCC} que es controlado por el submódulo \var{Acceso}.

%XXX-jblesa. No has hablado del VCC hasta ahora. Supongo que lo haras
%cuando escribas las primeras secciones. XXX-cvillar, por este comentario imagino que debo matizarlo mejor en diseño. 

La implementación está basada en \textit{Protocol-Buffers} de Google \cite{protocolBuffers}. Los mensajes son construidos utilizando \ac{IDL}: un archivo donde definimos la estructura de estos mensajes. \textit{Protocol-Buffers} utiliza un entero que identifica cada campo para evitar codificar el nombre de éste y así serializar estructuras de datos de manera más eficaz. La manera de codificar este entero varia por la misma razón: desde el 1-15 se codifica con un \textit{byte}, del 16-2047 con dos y así en adelante. \textit{Protocol-Buffers} define una entidad llamada \bsq{\textit{Message}} que puede albergar campos de distintos tipos: int32, bool, bytes\ldots, tipos más complejos como enumerados u otros mensajes anidados.

Con esta \ac{IDL} definida en la clase \class[util]{Message} con extensión \texttt{.proto}, \textit{Protocol-Buffers} nos genera (gracias al compilador \texttt{protoc}) un intérprete del árbol de derivación creado para traducir los mensajes y todos los métodos necesarios para construir y serializar las estructuras de datos. Usamos la sentencia \Scst{option optimize\_for = LITE\_RUNTIME;} en nuestro archivo \ac{IDL} para indicar que nuestra máquina es limitada y así usar los menos recursos posibles a cambio de perder otras características como la rapidez.\\

Para facilitar la traducción de los diferentes mensajes, se ha definido dos grandes mensajes para evitar anidar mensajes que no comparten significado, lo que haría poco claro el modelo. El primer mensaje engloba todos los mensajes intercambiados en la \ac{CWSN}: \var{NodeMessage}. El segundo engloba a los paquetes que se envían sobre \wifi{} para el registro y desregistro en la red: \var{WifiPacket}. Empezamos a interpretar un mensaje asumiendo (por probabilidad) que es del tipo \var{NodeMessage} si obtenemos un error del tipo \Scst{InvalidProtocolBufferException} significa que el mensaje recibido es del otro tipo. Para saber qué tipo de mensaje está contenido evaluamos los campos \var{type} y \var{packetType} respectivamente. Estos campos guía, uno para cada mensaje, no deben ser codificados con el mismo número, ya que de ser así, el proceso de traducción puede confundir ambos tipos de mensaje.\\
%El punto de entrada en el proceso de \textit{parsing} para cada mensaje es la evaluación de \var{type} y \var{packetType} respectivamente, para evitar fallos en la interpretación y confundir ambos mensajes estos campos no pueden ser codificados con el mismo número.

%XXX-jblesa parsing en español. XXX-cvillar parsing = traducción?

En la figura~\ref{fig:messageProto} se plasma un mapa completo de la estructura de anidación de los diferentes mensajes que utilizan los procesos de red (sección~\ref{sec:procesosRed} del capítulo de diseño). En color {\bf\color[RGB]{0,128,128}turquesa} se pinta el nombre de los campos que son opcionales y en {\bf negro} aquellos que son obligatorios. Los denominados con el prefijo \textit{list} en el tipo aceptan más de un valor, convirtiéndose en una lista del tipo denominado. Aunque se nos permite anidar más de un tipo de mensaje, la manera de interpretarlo está conducida por los campos guía donde se especifica qué tipo de mensaje contenemos. Por ello cada mensaje anidado está marcado como opcional pero para evitar errores en el momento de interpretación, debemos asegurar que está presente el mismo tipo de mensaje que el especificado en el campo guía.

\figura{Vectorial/implementation/message2}{width=.9\textwidth}{fig:messageProto}{Estructura anidada de mensajes de red sobre \textit{Protocol-Buffers}}

%\figura{Vectorial/implementation/message2}{width=.976\textwidth}{fig:messageProto}{Estructura anidada de mensajes de red sobre \textit{Protocol-Buffers}}
%\clearpage

%--------------------------

\subsection{Interfaz Módulo cognitivo - Controlador}
Esta comunicación, al igual que la interfaz Aplicación - Módulo cognitivo, está fuertemente marcada y se basa también en el paso de mensajes. Esto nos ayuda a colocar la funcionalidad en cada parcela e intercambiar exclusivamente y de forma estandarizada la información necesaria para llevar a cabo un proceso.\\

En el \var{Gestor de Interfaces} implementamos tantos \textit{Handler} como \texttt{Controladores} de interfaz tengamos, pasándole éstos como referencia. El controlador por tanto tiene una forma de remitir información de manera estandarizada sin conocer más datos del servicio, el cual sí puede lanzar los procesos (llamar a métodos del controlador) al usar la referencia suministrada gracias a la programación basada en objetos. El servicio recoge los diferentes mensajes enviados por el controlador que son entregados en orden una vez se ha atendido a la petición anterior. Este sistema, recordemos, es el mismo que el implementado en la interfaz entre las aplicaciones y el servicio. Los mensajes aglutinan tanto el evento que se produzca en la red como el estado de la interfaz e incluyen diferentes campos \textit{extra} según sea ésta: en las tablas~\ref{tab:stateManagerWifiMessage} y~\ref{tab:stateManagerBtMessage} podemos ver ejemplos de la diferente información y su estructuración.

\comp{Diseño:
y los homogeneiza su respuesta entre los distintos controladores para que las distintas comunicaciones que tenga que hacer a las aplicaciones sean uniformes y transparentes a la interfaz de comunicación usada en ese momento. 

Estos mensajes pueden ser respuesta al lanzamiento de un proceso por parte del servicio o directamente bajo iniciativa del propio controlador al cambiar de estado por eventos de red. Se crea así un gestor de estados entre controlador y servicio 
}
%-----------------------

\subsection{Controlador interfaz Wi-Fi}
Está formado por:
\begin{itemize}
	\item La clase \class{WifiController} maneja las conexiones entrantes sobre \ac{IP} y centraliza todas las funciones de la interfaz para enviar y recibir datos, así como el descubrimiento y salida de la red: submódulo \var{Registrador en la Red}.\\
Contiene dos hebras encargadas de alojar los \textit{sockets} utilizados en la comunicación y un \var{Gestor de estados} que va recabando y enviando la información al servicio sobre el estado de la interfaz. Necesitamos alojar esto en una hebra independiente pues son llamadas bloqueantes no acotadas en el tiempo y cuyo tiempo de ejecución no está delimitado, es decir, una vez salgamos del bloqueo vamos a querer bloquearnos otra vez para no perder ninguna conexión. El submódulo \var{Registrador en la red} consiste en un par de \textit{AsyncTask} encargadas de enviar en segundo plano tanto los paquetes de registro en la red: \textit{``HelloPacket''} (ver secciones~\ref{subsec:enterInNetwork} y~\ref{subsec:enterInNetworkimpl}) como los de desregistro en la red: \textit{``ByePacket''} (secciones~\ref{subsec:salidaNodoRed} y~\ref{subsec:salidaRedImpl}).

	\item El \textit{ServiceIntent} \class[util]{SendoIP} administra las conexiones salientes sobre \ac{IP}. En este caso la implementación se basa sobre un servicio en vez de una hebra propiamente dicha. Aprovechando que los servicios están pensados para realizar una tarea preestablecida desde el comienzo, sin que el componente que lo inicializó influya en su ciclo de vida y al revés, el envío de datos por la red es un ejemplo al ser un trabajo acotado en el tiempo, no sabemos cuanto va a tardar, pero tiene delimitado un final. Implementamos esta tarea como un \textit{serviceIntent} (ver sección~\ref{subsubsec:serviceIntent}). Esto nos permite asegurar que sólo tenemos un \textit{socket} abierto para el envío de datos y que no hay condiciones de carrera en el envío de distintos datos a distintos participantes.
 
	\item La \textit{AsyncTask} encargada de inicializar el \texttt{WifiController} 
y del manejo de la \ac{API} \wifi{} de \android{}. La tarea:
\class{CognitiveLayer\allowbreak\_specific\allowbreak\_Service\allowbreak.SetupWifiInterface}
está ubicada dentro del servicio aunque no se aprovecha del
ámbito en el que está, ya que no accede de manera directa a variables locales del servicio. 
De esta manera puede declararse independientemente en su archivo y funcionar 
de la misma manera. En la configuración de la interfaz como proceso de red 
explicaremos los motivos del por qué usar una \textit{AsyncTask}.

%XXX-jblesa Pon scope en español XXX-cvillar ok.

	\item Un \textit{BroadcastReceiver} \class{StatusReceiver\allowbreak\_wifi} encargado de recoger los eventos de conexión o cambios para sincronizar procesos en el controlador.
\end{itemize}

\figura{Vectorial/implementation/wificontroller}{width=.76\textwidth}{fig:wifiController}{Controlador Wi-Fi, estructura interna}

El servicio inicializa el controlador de la siguiente manera:
\begin{enumerate}
	\item Inicializar el \textit{BroadcastReceiver} y añadir los
filtros pertinentes para registrarse a los eventos (mensajes de difusión) deseados.
Lo realizamos en el método \textit{onCreate()} y limpiamos estos registros
en el \textit{onDestroy()} para evitar fugas de memoria.

%XXX-jblesa Pon memory-leaks en español XXX-cvillar ok.
  
	\item Crear el objeto \texttt{WifiContoller} pasándole la referencia del \textit{Handler} para poder enviarle mensajes. Este objeto necesita ser configurado con la llamada al método \textit{start()}.
	\item Lanzar la \textit{AsyncTask} asociada a la configuración de la interfaz, como veremos este proceso es costoso por lo que se tiene que ejecutar fuera de la hebra principal (encargada de recoger la interacción del usuario) evitando la pérdida de rendimiento y errores tipo \ac{ANR}. A su vez esta tarea termina de configurar el \texttt{WifiController} en la modalidad deseada.  
\end{enumerate}

El \var{Gestor de Estados} gracias a la referencia que tiene del \textit{Handler} del \var{Gestor de Interfaces} puede enviar mensajes al servicio sobre eventos y estado de la interfaz (ver tabla~\ref{tab:wifiStateManager}) esta información se codifica en los campos \argOne{} y \argTwo{} como números \integer{s} en el siguiente mensaje:

\messageTableInit{\wifiToServ}{1 =\\ \scriptsize{MESSAGE\_STATE\_\\AND\_EVENT\_CHANGE}}{Estado de la interfaz}{Evento}{\nc{}}{\nc{}}
\messageTableExtraArbitraryText{Si el evento no es \Scst{EVENT\_NO\_DEVICES\_CHANGES} se incluyen estos campos \textit{extra}:}{device\_ip\_address}{Una \String{} con la dirección IP del nodo que ha producido el evento}
\messageTableEnd{Mensaje perteneciente a la interfaz Módulo cognitivo - Controlador, gestor de estados en \wifi{}}{stateManagerWifiMessage}


\subsection{Controlador interfaz Bluetooth}
\label{subsec:btControllerImpl}
\figura{Vectorial/implementation/btcontroller}{width=.76\textwidth}{fig:btController}{Controlador Bluetooth, estructura interna}

Como se ve ambos \var{Controladores} tienen una arquitectura similar. El de \bt{} está formado por:

\begin{itemize}
	\item La clase \class{BluetoothController} maneja el establecimiento y mantenimiento de las conexiones sobre un canal \ac{RFCOMM}.
Al igual que su homóloga y por las mismas razones se implementa sobre hebras que gobiernan los detalles de la comunicación. En concreto se usan tres tipos de hebras como veremos en la configuración de la interfaz: dos de ellas para conseguir el \textit{socket} sobre el que enviar y recibir datos y otra para alojarlo y controlarlo.
	\item La \textit{AsyncTask} encargada de la configuración de la interfaz y del objeto  \texttt{{\small BluetoothController}}: \class{CognitiveLayer\allowbreak\_specific\allowbreak\_Service\allowbreak.SetupBTinterface}, imitando las mismas líneas marcadas en el controlador de \wifi{}.
	\item Un \textit{BroadcastReceiver} \class{StatusReceiver\allowbreak\_bluetooth} encargado de recoger los eventos de encendido o apagado, útiles para sincronizar procesos.
\end{itemize}  

De igual similitud el servicio sigue los mismos pasos para configurar este controlador. Su módulo \var{Gestor de Estados} funciona de manera similar al de \wifi{}, con la peculiaridad de que los eventos y estados son diferentes tal y como podemos ver en la tabla~\ref{tab:btStateManager}. En la tabla~\ref{tab:stateManagerBtMessage} aparece la estructura del mensaje enviado al servicio.

\messageTableInit{\btToServ}{1 =\\ \scriptsize{MESSAGE\_STATE\_\\AND\_EVENT\_CHANGE}}{Estado de la interfaz}{Evento}{Un \textit{array} con las direcciones MAC de los nodos que forman la red}{\nc{}}
\messageTableExtraArbitraryText{Si el evento no es \Scst{EVENT\_NO\_DEVICES\_CHANGES} se incluyen estos campos \textit{extra}:}{device\_name}{Una \String{} con el nombre proporcionado por los servicios de Bluetooth de \android{} del nodo que ha producido el evento (no usado)}
\messageTableExtraAddrow{device\_address}{Una \String{} con la dirección MAC de Bluetooth del nodo que nos envía los datos}
\messageTableEnd{Mensaje perteneciente a la interfaz Módulo cognitivo - Controlador, gestor de estados en \bt{}}{stateManagerBtMessage}
Al igual que los campos \textit{extra}, el campo \textit{obj} no viene informado si se trata del evento \Scst{EVENT\_NO\_DEVICES\_CHANGES}. De todas formas la información que proporciona este campo no es usada por el servicio debido a que la misma información y más completa se encuentra en el \var{Repositorio}. Lo mismo ocurre con el campo \textit{extra} ``device\_name''. El controlador suministra toda la información que posee que será atendida o no en el servicio cognitivo.
 
 \paragraph{Fallo conocido} En algunos dispositivos y versiones (principalmente inferiores a \android{} 2.3), el \textit{HashMap} utilizado para mantener un registro de las hebras del tipo \var{ConnectedThread} pierde su contenido momentos después de añadir un valor. Esta situación solamente ocurre cuando partimos de una situación sin datos de usuario previos, bien porque se trata de la primera vez que inicializamos la aplicación o bien porque hemos borrado de manera manual estos datos. El comportamiento observado se resume en que el nodo no puede responder porque pierde la referencia y según la situación o no puede entrar a formar parte de la red o queda aislado dentro de ella. Esta anomalía encontrada en este componente, desaparece en las subsiguientes inicializaciones de la aplicación, sin importar si en esta primera vez hemos intentado formar parte de una \ac{CWSN}.\\

Por norma general a cualquier interfaz, los \textit{BroadcastReceiver} tienen que ser inicializados por el servicio para tener comunicación directa con éste para conocer los eventos ocurridos en el sistema. Así se evita introducir una capa intermedia al referenciarlos directamente desde el servicio, lo que nos permite su observación a lo largo de toda su vida. Si ligásemos la vida del \textit{BroadcastReceiver} a la del controlador, los eventos de una interfaz sólo serían observables cuando ésta esté en uso. 

El resto del controlador, menos los componentes del módulo \var{Sensado}, se libera al no ser utilizado por motivos de eficiencia y minimización de recursos.

\comp{Analisis:
en este caso la aplicación como sólo desea enviar un dato a través de la red cognitiva, si por ejemplo nuestra arquitectura cognitiva estuviese montada sobre una \textit{Activity} (un componente con interfaz gráfica que liga su ciclo de vida a su tiempo en pantalla) en primer lugar la aplicación dejaría de estar en pantalla, con lo cual corre el riesgo de ser destruida y 

Dejamos la activity para:
las \textit{activities} ligan su ciclo de vida a la interacción en la pantalla, son componentes con interfaz gráfica. Una vez el usuario quita el foco de la aplicación la \textit{activity} es candidata o se produce a su destrucción.
}

\section{API del servicio: interfaz Aplicación - Módulo cognitivo}
%-------------------------------------------------------------------
\label{sec:apiImpl} %% API DEL SERVICIO %%
%-------------------------------------------------------------------

A continuación vemos cómo se ha decidido estructurar la información y mediante qué entidades construimos cada una de las funciones de la interfaz vistas en diseño. Allí comentamos que cada mensaje va clasificado con una etiqueta, se trata del campo \textit{what} del mensaje que se codifica como un número \integer{}. En cada mensaje veremos qué número le corresponde.

\subsection{Conectarse al módulo cognitivo}
\label{subsec:apiStartImpl}
Para poder entregar y recibir mensajes necesitamos una referencia al \textit{Messenger} del servicio. Esta referencia la obtenemos tras hacer una petición de unión o atadura llamando al método \textit{bindService()} con un \textit{Intent} explícito con destino: \class{CognitiveLayer\_specific\_Service.class}
%es.upm.die.lsi.pfc.CWSNoA.CognitiveLayer_specific_Service.class
%\end{verbatim}

En esta petición, también se pasa como parámetro un objeto de la clase \textit{ServiceConnection} que el sistema \android{} llama cuando ha establecido la conexión. \android{} arrancará el servicio si éste no lo estaba ya y nos devolverá como objeto \textit{IBinder} una instancia del \textit{Messenger} del servicio. 
Por motivos de seguridad la aplicación que realice la petición de atadura requiere declarar en su archivo manifiesto la aceptación del permiso:
\begin{verbatim}
 - es.upm.die.lsi.pfc.CWSNoA.permission.COGNITIVE_SERVICE
\end{verbatim}
Este permiso informa al usuario final que usa la aplicación sobre las intervenciones en las interfaces de comunicación sin la intervención de éste.\\

El primer mensaje usado en la negociación tiene la siguiente estructura, no contiene ninguna información adicional más que el \textit{Messenger} de la aplicación para que el \var{Gestor del Aplicaciones} pueda registrarla de forma correcta. Esta información la ubicamos en el campo del mensaje \replyTo{}:

\messageTableInit{\appToServ}{1 =\\ \footnotesize{REGISTER\_CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \msgAPIcaption{} registro cliente}{registerClientMessage}

El segundo mensaje utilizado en la negociación aporta información (ver tabla~\ref{tab:infoHandshaking}) sobre la aplicación. Ésta se codifica de la siguiente manera:
\messageTableInit{\appToServ}{3 = \scriptsize{REGISTER\_\\DATA\_EXCHANGE}}{Papel del nodo}{\nc}{\textit{null}}{\messApp{}}
\messageTableExtra{appCode}{Una \String{} con el ``código de aplicación''}
\messageTableEnd{Mensaje \msgAPIcaption{} entrega parámetros de aplicación}{registerExchangeMessage}
\begin{itemize}
	\item \textbf{Papel del nodo}, como un número \integer{}. El valor \bsq{0} indica que la aplicación usuaria es un usuario secundario y el valor \bsq{1} para indicar que se trata de un usuario primario. Este campo lo incluimos en el campo \argOne{} del mensaje.
	\item \textbf{Código de la aplicación}, como una \String{}. Lo adjuntamos al mensaje como un campo \textit{extra} con la clave ``\texttt{appCode}''.
\end{itemize}
El campo \textit{obj} lo dejamos vacío o lo informamos como \textit{null}, en la secciones~\ref{subsubsec:darkApiUpdateParams} y~\ref{subsubsec:darkApiUpdateParamsImpl} veremos el porqué de este campo.\\

Respecto al tercer mensaje que cierra la negociación, la forma de identificar la situación previa del servicio reside en el valor del campo \textit{obj} recibido, así:

\paragraph{En situación red no existente} Si el campo \textit{obj} es \false{} significa que no estábamos cooperando en una \ac{CWSN}, el formato recibido en el mensaje se estructura en la siguiente tabla: %~\ref{tab:endHandshakingNotCWSNMessage} se refleja esta situación.

\messageTableInit{\servToApps}{3 = \scriptsize{REGISTER\_\\DATA\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{False}}{\nc{}}
\messageTableExtra{nodeRole}{Un \integer{} que codifica el papel del nodo}
\messageTableExtraAddrow{nodeType}{Un \integer{} con el tipo de nodo}
\messageTableExtraAddrow{periodTask}{Un \double{} que representa el periodo tarea cognitiva en segundos}
\messageTableExtraAddrow{nodeName}{Una \String{} con el nombre del nodo en la red}
\messageTableExtraAddrow{errorSetupInterface}{Un valor booleano con el resultado de la configuración de la interfaz}
\messageTableEnd{Mensaje \msgAPIcaption{} finalización de la negociación: CWSN no establecida}{endHandshakingNotCWSNMessage}
La forma de codificar los campos que aparecen en este mensaje es:
\begin{itemize}
	\item \textbf{Estado de la interfaz}, los siguientes estados se codifican como números \integer{s}:
		\begin{enumerate}
			\setcounter{enumi}{-1}
			\item \Scst{INTERFACE\_STATE\_DOWN}, la interfaz de comunicación no está configurada.
			\item \Scst{INTERFACE\_STATE\_IDLE}, la interfaz está configurada pero no estamos cooperando en red.
			\item \Scst{INTERFACE\_STATE\_IDLE\_CONNECTED}, situación de reposo cooperando en \ac{CWSN}.
			\item \Scst{INTERFACE\_STATE\_CONNECTING}, nos estamos conectando a otro nodo (sólo en \bt{}).
			\item \Scst{INTERFACE\_STATE\_SENDING}, estamos enviado datos a través de la interfaz.
			\item \Scst{INTERFACE\_STATE\_RECEIVING}, estamos recibiendo datos.
		\end{enumerate}
	\item \textbf{Interfaz} en el campo \argTwo{} del mensaje viene en forma de \integer{} la interfaz de comunicaciones usada. Usamos el enumerado \var{Interfaces} ubicado en la clase \class{CognitiveLayer\_common\_Service} para codificar como:
	\begin{itemize}
		\item \bsq{0} la interfaz \bt{}.
		\item \bsq{1} la interfaz \wifi{}.
		\item \textcolor{notImplemented}{\bsq{2} la interfaz \textit{Mobile}, no implementado.}
		\item \bsq{-1} desconocido, valor devuelto en el transcurso de cambio de contexto.
	\end{itemize}
	\item \textbf{Papel de nodo}, misma codificación que la del segundo mensaje. Se utiliza un tipo enumerado para esta función denominado \var{Role} ubicado en la clase \class[util]{Node}, esta representación es interna al servicio, el cual codifica este valor en el número \integer{} que corresponda cuando esta información sale de su ámbito. 
	\item \textbf{Tipo de nodo}, utiliza el enumerado \var{Type} en la misma clase. Sus valores codificados son:
		\begin{itemize}
			\item \bsq{0} para nodo normal.
			\item \bsq{1} representa al nodo coordinador.
			\item \textcolor{notImplemented}{\bsq{2} para la figura del subcoordinador temporal en \bt{}, finalmente no implementada} 
			\item \bsq{-1} para un valor desconocido en caso de error.
		\end{itemize}
\end{itemize}

\paragraph{En situación de red previa} En cambio si el valor recibido es \true{} significa que el servicio ya estaba colaborando en una \ac{CWSN} por lo que no es necesario realizar ninguna configuración obteniendo una respuesta en exclusiva y casi inmediata a la aplicación que inició la negociación. El formato del mensaje recibido es:

\messageTableInit{\servToApp}{3 = \scriptsize{REGISTER\_\\DATA\_EXCHANGE}}{Estado de la interfaz}{Interfaz}{\textbf{True}}{\nc{}}
\messageTableExtra{nodeRole}{Un \integer{} que codifica el papel del nodo}
\messageTableExtraAddrow{nodeType}{Un \integer{} con el tipo de nodo}
\messageTableExtraAddrow{periodTask}{Un \double{} que representa el periodo tarea cognitiva en segundos}
\messageTableExtraAddrow{nodeName}{Una \String{} con el nombre del nodo en la red}
\messageTableExtraAddrow{appCode}{Una \String{} que identifica al código de la aplicación}
\messageTableExtraAddrow{nodeIdList}{\textit{Array} de \integer{s} con los identificadores de los nodos}
\messageTableExtraAddrow{nodeNameList}{\textit{Array} de \String{s} con los nombres de los nodos}
\messageTableEnd{Mensaje \msgAPIcaption{} finalización de la negociación: CWSN establecida}{endHandshakingInCWSNMessage}
La codificación empleada en los campos que difieren en este mensaje es:
\begin{itemize}
	\item \textbf{Código de aplicación}, aunque está explicado en la tabla~\ref{tab:endHandshakingInCWSNMessage}, este campo no aparecía en el mensaje anterior. Este campo codificado como una \String{}, lo recuperamos con la clave ``\texttt{appCode}''.
	\item \textbf{Lista de nodos}, \ListaNodosDescription{}
\end{itemize}

%----------
\subsection{Incluir nodos a la red en Bluetooth}
\label{subsec:connectViaBTimpl}
La información sobre el nodo al que queremos conectarnos la incluimos en el campo \obj{} del mensaje (ver tabla~\ref{tab:connectToBT}). Este campo acepta dos tipos de codificación:

\begin{itemize}
 \item Una \String{} con la dirección MAC de \bt{} del nodo.
 \item Un \integer{} con el identificador del nodo. Este identificador nos lo facilita el servicio por ejemplo en sus mensajes de información (ver secciones~\ref{subsec:serviceInfo} y~\ref{subsec:serviceInfoImpl}).
\end{itemize}

\messageTableInit{\appToServ}{12 =\\\footnotesize{CONNECT\_VIA\_BT}}{\nc{}}{\nc{}}{nodo al que conectarse}{\nc{}}
\messageTableEnd{Mensaje \msgAPIcaption{} conexión manual a un nodo en \bt{}}{connectToBT}

%----------
\subsection{Recibir datos de otros nodos}
El contenido del mensaje se encuentra en el campo \obj{} del mensaje recibido. Por otra parte, el identificador del nodo que nos ha enviado el mensaje, se encuentra en un campo \textit{extra} que recuperamos con la clave ``\texttt{device\_id}'':

\messageTableInit{\servToApp}{8 =\\ \scriptsize{INCOMING\_CONTENT}}{\nc{}}{\nc{}}{\textit{payload}}{\nc{}}
\messageTableExtra{device\_id}{Un \integer{} que identifica al nodo que ha enviado el mensaje}
\messageTableEnd{Mensaje \msgAPIcaption{} datos recibidos}{incomingContent}

%----------
\subsection{Enviar mensajes de datos a otros nodos}
La \String{} que queremos enviar la alojamos en el campo \obj{} del mensaje. La lista de nodos destinatarios la codificamos como una instancia del objeto \textit{ArrayList<Integer>} que adjuntamos como un campo \textit{extra} del mensaje con la clave ``\texttt{addressedNodes}''. También debemos incluir el objeto \textit{Messenger} de la aplicación en el campo \replyTo{}. %Esta información es incluida en el mensaje cuyo formato se visualiza en la tabla~\ref{tab:outgoingContent}.% Con esta información podemos formar el siguiente mensaje:
En la tabla~\ref{tab:outgoingContent} se formatea la información que se incluye en este mensaje.

\messageTableInit{\appToServ}{4 =\\ \scriptsize{OUTGOING\_CONTENT}}{\nc{}}{\nc{}}{\textit{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{}s con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje \msgAPIcaption{} envío de datos}{outgoingContent}

%----------
\subsection{Confirmación entrega de datos a otros nodos}
En el mensaje de confirmación alojamos en el campo \argOne{} el número de mensajes que se han escrito de forma correcta, en el \argTwo{} el número de ellos que han fallado en la entrega y en el \obj{} el contenido que fue enviado. Si el campo \argTwo{} tiene un valor mayor que cero, entonces adjuntamos la lista de nodos a los que la entrega ha fallado. Como hemos visto, esta lista es una pareja de dos \textit{arrays} ligados que nos devuelve el identificador y el nombre del nodo. % En la tabla~\ref{tab:outgoingContentResultApp} se describe la codificación de este mensaje.
La codificación de este mensaje es la que sigue:
\messageTableInit{\servToApp}{6 =\\ \scriptsize{OUTGOING\_CONTENT \_RESULT}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{payload}}{\nc{}}
\messageTableExtra{IdsNotDelivered}{Un \textit{array} de \integer{s} con los identificadores de los nodos a los cuales no les ha llegado el mensaje}
\messageTableExtraAddrow{NamesNotDelivered}{Un \textit{array} de \String{s} con los nombres de los nodos a los cuales no les ha llegado el mensaje}
\messageTableEnd{Mensaje \msgAPIcaption{} resultado de envío de datos presentado a la aplicación}{outgoingContentResultApp}

%----------
\subsection{Informe previo a la entrega de datos encolados}
Además de los subconjuntos de la lista de nodos que se adjuntan como campos \textit{extra} del mensaje, en los campos \argOne{} y \argTwo{} adjuntamos el cardinal de estas listas. En el campo \obj{} adjuntamos el contenido del mensaje de datos. %Formateamos esta información que representa el informe previo al envío del mensaje de datos como se aprecia en la siguiente tabla: 
En la tabla~\ref{tab:queuedMessage} se representa el formato de este informe.

\messageTableInit{\servToApp}{11= \scriptsize{QUEUED\_MESSAGE}}{número enviados}{número no enviados}{\textit{payload}}{\nc{}}
\messageTableExtra{IdsTriedToSend}{Un \textit{array} de \integer{s} con los identificadores de los nodos los cuales siguen en red}
\messageTableExtraAddrow{NamesTriedToSend}{Un \textit{array} de \String{s} con los nombres de los nodos que siguen en red}
\messageTableExtraAddrow{IdsNotDelivered}{Un \textit{array} de \integer{s} con los identificadores de los nodos que no hemos enviado el mensaje por no encontrarse en la red}
\messageTableExtraAddrow{NamesNotDelivered}{Un \textit{array} de \String{s} con los nombres de los nodos que no hemos enviado el mensaje por no encontrarse en la red}
\messageTableEnd{Mensaje \msgAPIcaption{} informe previo a la salida de un mensaje encolado}{queuedMessage}

%----------
\subsection{Información sobre el servicio cognitivo}
\label{subsec:serviceInfoImpl}

El mensaje de información que envía el servicio a las aplicaciones estructura la información de la siguiente manera.

El campo \obj{} alberga un valor booleano, si tiene el valor \true{} significa que esta información implica un cambio en la lista de nodos. En este caso incluimos los dos \textit{arrays} que representan la lista de nodos formada por el par (identificador, nombre). La codificación de los campos \argOne{} y el recuperado con la clave ``\texttt{state}'' es la ya vista en otros mensajes. La codificación que queda por explicar es la del campo cuya clave es ``\texttt{event}'', su semántica ya la vimos en la tabla~\ref{tab:infoGatheredFromService}, a ésta le asignamos los siguientes números \integer{s}:
\begin{enumerate}
	\setcounter{enumi}{-1}
	\item\Scst{EVENT\_INTERFACE\_NO\_CHANGES}, este evento es la ausencia de evento. Hay cambios en el estado de la interfaz que no son provocados por un evento, para estas casuísticas el evento que le asignamos es el de \bsq{no cambio}.	
	\item\Scst{EVENT\_INTERFACE\_NODE\_JOINED}, este evento surge cuando el coordinador nos conecta a la red. Se genera en ambos extremos (en el coordinador y el nodo normal que empieza a formar parte de la red).
	\item\Scst{EVENT\_INTERFACE\_NODE\_EXITED}, se genera al perder la comunicación con un nodo (entre coordinador y normal, aparece este evento al igual que el anterior en ambos extremos).
	\item\Scst{EVENT\_INTERFACE\_CANNOT\_CONNECT}, surge en el nodo que ha intentado conectarse a otro y no ha podido.
	\item\Scst{EVENT\_INTERFACE\_ALREADY\_CONNECTED}, surge cuando el coordinador intenta conectarse a un nodo al cual ya está conectado (sólo en \bt{}). 
	\item\Scst{EVENT\_INTERFACE\_SWITCHING\_TO\_BT}, evento que surge cuando recibimos o disparamos (coordinador) el cambio de contexto hacia \bt{}.
	\item\Scst{EVENT\_INTERFACE\_SWITCHING\_TO\_WIFI}, evento que surge cuando recibimos o disparamos (coordinador) el cambio de contexto hacia \wifi{}.
	\item\textcolor{notImplemented}{\Scst{EVENT\_INTERFACE\_SWITCHING\_TO\_MOBILE}, no implementado, de manera análoga cuando la interfaz de destino es datos móviles.}
	\item\Scst{EVENT\_INTERFACE\_SWITCHING\_ENDED}, se genera al terminar el cambio de contexto.
	\item\Scst{EVENT\_LIST\_NODES\_UPDATED}, cuando es necesaria una actualización de la lista de nodos que no haya sido provocada por algún evento anterior.
\end{enumerate}

La estructura de la tabla~\ref{tab:serviceInformation} aglutina toda la información este mensaje.

\messageTableInit[!h]{\servToApps}{9 = \scriptsize{SERVICE\\\_INFORMATION}}{interfaz}{\nc{}}{modificación lista nodos}{\nc{}}
\messageTableExtra{coordinator}{Una \String{} con el nombre del nodo coordinador. Si somos el nodo coordinador este campo viene informado a \textit{null}}
\messageTableExtraAddrow{triggerNodeName}{Una \String{} con el nombre del nodo que ha disparado el evento. Si no existe tal nodo no se incluye este campo en el mensaje}
\messageTableExtraAddrow{state}{Un \integer{} con el estado de la interfaz}
\messageTableExtraAddrow{event}{Un \integer{} con el evento producido en la red}
\messageTableExtraAddrow{nodeIdList}{Un \textit{array} de \integer{s} con los identificadores de los nodos que forman la red en estos momentos}
\messageTableExtraAddrow{nodeNameList}{Un \textit{array} de \String{} con los nombres de los nodos que forman la población actual}
\messageTableEnd{Mensaje \msgAPIcaption{} información evento/estado por parte del servicio}{serviceInformation}


%----------
\subsection{Mensajes de error: Incumplimiento de la API del servicio}
Los diferentes códigos de error tienen la siguiente codificación en números \integer{s}, estos códigos se formatean en el campo \argOne{} del mensaje (ver tabla~\ref{tab:errorMessage}) que se envía a las aplicaciones:
\begin{enumerate}
	\item\Scst{ERROR\_CODE\_ILLEGAL\_ARGUMENT}
	\item\Scst{ERROR\_CODE\_NODE\_NOT\_EXISTING}
	\item\Scst{ERROR\_CODE\_INTERNAL}
	\item\Scst{ERROR\_CODE\_NOT\_IN\_NETWORK}
	\item\Scst{ERROR\_CODE\_MESSAGE\_NOT\_RECOGNIZED}
	\item\Scst{ERROR\_CODE\_ILLEGAL\_PAYLOAD}
\end{enumerate}
\messageTableInit{\servToApp}{10 =\\ \scriptsize{ERROR\_MESSAGE}}{código de error}{\nc{}}{Descripción del error}{\nc{}}
\messageTableEnd{Mensaje \msgAPIcaption{} comunicación de error en el servicio}{errorMessage}

%----------
\subsection{Actualización de parámetros de aplicación}
\label{susubbsec:apiUpdateParamsImpl}
Al ser éste un subproceso sacado de la negociación desde el punto de vista de la implementación sólo comentar los códigos usados en la interfaz \var{Aplicación - Módulo cognitivo} para el campo ``tipo de nodo'' el valor \bsq{0} representa al nodo normal y el valor \bsq{1} al nodo coordinador.

%----------
\subsection{Desconectarse del servicio cognitivo}
El mensaje que permite al \var{Gestor de Aplicaciones} borrarnos de su base de clientes es el que sigue:

\messageTableInit{\appToServ}{2 =\footnotesize{UNREGISTER\_\\CLIENT}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \msgAPIcaption{} desregistro cliente}{unregisterClientMenssage}

Para liberar en totalidad la atadura al servicio, se debe realizar la llamada al método \textit{unbindService()}, pasándole como parámetro el objeto de conexión \textit{ServiceConnection}. Una vez liberada, \android{} nos avisa en la instancia del objeto usado en la conexión.

\subsection{API \bsq{oculta}~del servicio}
Los mensajes que permiten lanzar procesos de forma manual, siguen la misma estructura ya vista en los mensajes anteriores.

%----------
\subsubsection{Actualización de parámetros del servicio cognitivo}
\label{subsubsec:darkApiUpdateParamsImpl}
La estructura de mensaje que permite la actualización en bloque tanto de los parámetros de aplicación como los del servicio tiene la peculiaridad en su campo \obj{}:
\messageTableInit{\appToServ}{3 = \scriptsize{REGISTER\_\\DATA\_EXCHANGE}}{papel del nodo}{tipo de nodo}{\textbf{True}}{\messApp{}}
\messageTableExtra{appCode}{Una \String{} con el ``código de aplicación''}
\messageTableExtraAddrow{nodeName}{Una \String{} con el nuevo nombre del nodo en la red}
\messageTableExtraAddrow{periodTask}{Un \double{} con el nuevo periodo medido en segundos de la tarea cognitiva a ejecutar}
\messageTableEnd{Actualización de todos los parámetros del servicio}{updateAllParamsMessage}

Como vemos este campo viene informado con un valor booleano a \true{}. Esta es la clave que permite al servicio reconocer y efectuar un flujo distinto que actualice en su \var{Repositorio} estos valores. La codificación de los distintos campos se aprecia en la tabla~\ref{tab:updateAllParamsMessage} u obedece a las mismas reglas vistas en otros mensajes.
%----------
\subsubsection{Forzar cambio de contexto}
El mensaje %(ver tabla~\ref{tab:wa_switch})
que permite forzar un cambio de contexto es el que sigue, no necesita ninguna información adicional porque se deduce del contexto: 
\messageTableInit{\appToServ}{22=\footnotesize{WORKAROUND\_\\ SWITCH\_INTERFACE}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \workaround{} \msgAPIcaption{} cambio de interfaz de comunicación}{wa_switch}

%----------
\subsubsection{Almacenar y liberar datos encolados}
El mensaje que permite encolar un mensaje de datos directamente saltándonos el flujo normal se formatea igual que un mensaje de datos (ver tabla~\ref{tab:outgoingContent}) salvo por la etiqueta: campo \textit{what}. %En la tabla~\ref{tab:wa_queue} se ilustra este mensaje.
Por tanto el formato de éste es el que sigue:

\messageTableInit{\appToServ}{23=\scriptsize{WORKAROUND\_ PENDINGMESSAGE \_PUT}}{\nc{}}{\nc{}}{\textit{payload}}{\messApp{}}
\messageTableExtra{addressedNodes}{Una lista de \integer{s} con los identificadores de los nodos destinatarios del mensaje}
\messageTableEnd{Mensaje \workaround{} \msgAPIcaption{} encolamiento de mensaje de datos}{wa_queue}

%Para expresar el deseo de vaciar la cola de mensajes enviamos al servicio el mensaje formateado en la tabla~\ref{tab:wa_disposalqueue} que no necesita de ninguna información adicional para disparar el proceso.

Para expresar el deseo de vaciar la cola de mensajes enviamos al servicio el mensaje formateado en la siguiente tabla que no precisa de ninguna información adicional para disparar el proceso:


\messageTableInit{\appToServ}{24=\scriptsize{WORKAROUND\_ PENDINGMESSAGE \_SEND}}{\nc{}}{\nc{}}{\nc{}}{\messApp{}}
\messageTableEnd{Mensaje \workaround{} \msgAPIcaption{} vaciado cola de mensajes}{wa_disposalqueue}

%----------
\subsubsection{Mensaje de petición y respuesta}
En la tabla~\ref{tab:wa_reply} vemos la estructura del mensaje que permite a un nodo normal guardar la respuesta que suministrará en caso de ser requerida.

\messageTableInit[!h]{\appToServ}{20 = \footnotesize{WORKAROUND\\ \_WHAT\_TO\_REPLY}}{\nc{}}{\nc{}}{\textit{reply}}{\messApp{}}
\messageTableEnd{Mensaje \workaround{} \msgAPIcaption{} modificación de respuesta a enviar}{wa_reply}

En su campo \obj{} codificamos la respuesta como una \String{}.\\

%Sin embargo la aplicación que esté registrada sobre un nodo coordinador, siguiendo la estructura plasmada en la tabla~\ref{tab:wa_ask} puede requerir esta información a un nodo normal.
Por otra parte el mensaje que necesita enviar una aplicación en un nodo coordinador para solicitar información de \textit{test} de un nodo normal se codifica de esta manera:

\messageTableInit{\appToServ}{21 = \footnotesize{WORKAROUND\\ \_ASK\_RESPONSE}}{\nc{}}{\nc{}}{Identificador nodo}{\messApp{}}
\messageTableEnd{Mensaje \workaround{} \msgAPIcaption{} petición de respuesta}{wa_ask}

Cuando el servicio ha conseguido la respuesta envía a todas las aplicaciones pues no tiene forma de deducir por el contexto quién disparó el proceso. Aunque aquí lo vemos como un proceso lineal, no hay ninguna correlación entre ellos. La respuesta viene codificada en el campo \obj{} del %mensaje~\ref{tab:wa_ask_response}.
siguiente mensaje:

\messageTableInit[!h]{\servToApps}{21 = \footnotesize{WORKAROUND\\ \_ASK\_RESPONSE}}{\nc{}}{\nc{}}{Respuesta del nodo preguntado}{\messApp{}}
\messageTableEnd{Mensaje \workaround{} \msgAPIcaption{} respuesta obtenida}{wa_ask_response}


%-------------------
% FIN API
%-------------------
%\clearpage
%-------------------------------------------------------------------
\section{Implementación de procesos de red}
%-------------------------------------------------------------------
\label{sec:procesosRed-impl}
%En esta sección relataremos los detalles de implementación de ciertas
%partes de la arquitectura cuya explicación viene más a colación de la
%mano del proceso que en la su bloque.
En esta sección relataremos los detalles de implementación de los procesos
de red que como sabemos implican a más de un bloque de la arquitectura. Al dotar de un contexto
de proceso más que de bloque, se logra entender los pequeños componentes
que son usados por uno o más procesos.%\newpage%\\[30pt]
%XXX-jblesa Esta seccion no se entiende XXX-cvillar mejor?

%------------------------------
\subsection{Registro de una aplicación en el servicio cognitivo}
\label{subsec:serviceRegisterProcessImpl}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service (manejador de mensajes entre servicio y aplicaciones)
\end{files}
\end{codeInvolved}
%XXX-cvillar el primer mensaje será explicado en la api en implementación, vincularlo desde ahi.
Una vez recibido el primer mensaje (ver tabla~\ref{tab:registerClientMessage}), el \var{Gestor de Aplicaciones} procede a registrar la aplicación. Para ello guardamos el \textit{Messenger} de la aplicación (que viene informado en el campo \replyTo{} de este mensaje que inicia la pequeña negociación) en una matriz asociativa llamada \var{mClients} cuya clave es la representación en forma de \String{} de este objeto \textit{Messenger} que queremos almacenar. Ésta se obtiene a través del método \textit{toString()}. También registramos su ``código de aplicación'', informado en el segundo mensaje de la negociación, en otros dos \textit{HashMap}:
\begin{itemize} 
\item \var{mOut\_app}: nos relaciona la clave de \var{mClients} con el ``código de aplicación''. Al enviarnos la aplicación una petición de envío (en la que va incluida su \textit{Messenger}) recuperamos su código (gracias al \textit{Messenger}) para poder marcar el mensaje de datos saliente sin necesidad de que la aplicación nos informe en cada petición de su código. 
\item \var{mIn\_app}: relaciona el ``código de aplicación'' con la clave \var{mClients}. Al recibir un mensaje de red leemos el ``código de aplicación'' que viene marcado. Gracias a este \textit{HashMap} obtenemos la referencia a \var{mClients} dónde obtenemos el \textit{Messenger} para poder entregar el mensaje de datos entrante a la aplicación correspondiente.
\end{itemize}

%-------------------------------
\subsection{Configuración de la interfaz de comunicación}
\label{subsec:configInterface-impl}
La configuración de cada interfaz de comunicación se realiza en una \textit{AsyncTask}: clase diseñada por el sistema \android{} (ver sección~\ref{subsubsec:asyncTask}). La razón de esta elección en detrimento de un \textit{ServiceIntent}, reside en los mecanismos de compartición de información entre ambas hebras lo que hace una transición más fluida. En el caso de un \textit{ServiceIntent} necesitamos serializar toda la información que vayamos a utilizar y codificar explícitamente una forma de devolver la información de cómo ha transcurrido el proceso.

\subsubsection{Wi-Fi: servicio y controlador}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: SetupWifiInterface (AsyncTask)\\
\textbf{WifiController}: stop(), start() / StatusReceiver\_wifi (BroadcastReceiver)
\end{files}
\end{codeInvolved}

\comp{El controlador \wifi{} dependiendo del tipo de nodo en el que esté alojado, tendremos una o dos hebras escuchando para tráfico \ac{TCP} y \ac{UDP}. Al configurar la interfaz, liberamos estas hebras, para ello llamamos al método \textit{stop()} del controlador quien llamará a los métodos \textit{cancel()} de cada una de las hebras que cerraran los \textit{sockets} utilizados para la escucha y anulará la suscripción de anuncios del sistema del estado de la conexión entre otros. Una vez liberado todo, las volvemos (hebras y suscripción) a inicializar según proceda, gracias al método \textit{start()}. Esto nos sirve para partir de una situación deseable sin \textit{memory leaks}. //esto yo creo que tb va fuera.}
%--
La esperas señaladas en \ref{subsec:configInterface} consistentes en levantar la interfaz \wifi{} o conectarse a una red \wifi{} se realizan mediante esperas de consulta activa cuya variable de control es manejada en el \textit{BroadcastReceiver} de esta interfaz: \class{StatusReceiver\_wifi}. 

En el primer caso el anuncio que esperamos tiene la acción \Scst{WIFI\allowbreak\_STATE\allowbreak\_CHANGED\allowbreak\_ACTION} 
%\cst{WIFI\_STATE\_CHANGED\_ACTION}
con valor a \true{} en la variable
\Scst{WIFI\allowbreak\_STATE\allowbreak\_ENABLED}. Al recibir este anuncio modificamos la variable \Scst{wifiON}, que actúa como control para salir de la primera espera.

Para la segunda espera el anuncio que aguardamos es del tipo
\Scst{NETWORK\allowbreak\_STATE\allowbreak\_CHANGED\allowbreak\_ACTION}
con el valor \Scst{CONNECTED} en el campo \Scst{EXTRA\_NETWORK\_INFO}. La variable de control usada es
\Scst{waitUntilWifiGetConnected} que permite la salida de esta segunda espera al recibir este anuncio
por parte del sistema.\\

%XXX-jblesa pon callback en español. Has escrito ``espera
%esperamos''.  Cambia de palabra. XXX-cvillar reestructurado.

Para encender la interfaz \wifi{} procedemos a invocar el método \textit{setWifiEnabled(true)} de la clase \class[android.net.wifi]{WifiManager}. Es una llamada asíncrona que desencadena los procesos para encender el \textit{driver} de \wifi{} y su anuncio al resto del sistema mediante mensajes de difusión.

\paragraph{Nodo normal} Necesita configurar un \textit{ServerSocket} para
permitir conexiones entrantes para recibir tráfico del
coordinador. Para ello creamos el \textit{socket} de la clase
\class[java.net]{ServerSocket} e intentamos vincularlo a un puerto con
\textit{bind()} pasándole como parámetro el puerto donde escuchar. Si
este puerto está siendo utilizado para otros propósitos nos devuelve
un error del tipo \texttt{IOException}. El valor de este puerto es una
constante escrita en el propio código cuyo valor es \bsq{7617},
al ser un conocimiento compartido a priori, evitamos tener que
transmitir este valor por la \ac{CWSN}.

%XXX-jblesa pon hard-coding en español. XXX-cvillar ok.

\paragraph{Nodo coordinador} También necesitamos escuchar tráfico proveniente de los nodos normales, por lo que desplegamos un \textit{socket} \ac{TCP} al igual que el nodo normal. Además para poder registrar nodos en la red, donde éstos no conocen a priori ni la configuración ni el esquema, necesitamos escuchar en direcciones: \textit{multicast} y/o \textit{broadcast}.

Para ello necesitamos de un \textit{MulticastSocket} para ampliar el rango de escucha más allá de nuestra propia dirección \ac{IP} en la red. Registramos el \textit{socket} en un grupo \textit{multicast} a través de la llamada al método \textit{joinGroup()} de la clase \class[java.net]{MulticastSocket} (clase heredada de {\small\texttt{DatagramSocket}}) pasando como parámetro la dirección \textit{multicast} deseada. En este caso hemos elegido \bsq{224.2.76.24} que también está escrita directamente en el código. Necesitamos adquirir un cerrojo para que este tipo de mensajes no sean descartados de la cola de \wifi{} y sean entregados en el \textit{socket}. Esta es la razón de llamar a \textit{createMulticastLock()} de la clase \class[android.net.wifi]{WifiManager}. Para escuchar en la dirección de difusión, llamamos al método \textit{setBroadcast(true)} de la misma clase. El puerto de escucha de este \textit{socket} \ac{UDP} es el número siguiente a donde escuchamos en \ac{TCP}.
   
También necesitamos adquirir otro cerrojo para prevenir que el \textit{driver} de \wifi{} deje de escuchar en ciertas situaciones. El cerrojo encargado se invoca con \textit{createWifiLock()} pasándole como parámetro la constante \Scst{WifiManager.WIFI\allowbreak\_MODE\allowbreak\_FULL\allowbreak\_HIGH\allowbreak\_PERF} para indicar que se debe mantener la interfaz despierta, es decir, que se sigan capturando paquetes y se mantenga una latencia baja en la respuesta cuando la pantalla esté apagada.\\

Una vez terminada la configuración de la interfaz, colocamos el envío del último mensaje de la negociación (el que indica la finalización de ésta) en el método \textit{onPostExecute()} de la \textit{AsyncTask} que recordemos que vuelve a ejecutarse sobre la hebra principal.

\subsubsection{Bluetooth: servicio y controlador}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: SetupBTinterface (AsyncTask)\\
\textbf{BluetoothController}: stop(), start(), connect(), setState() / StatusReceiver\_bt (BroadcastReceiver)
\end{files}
\end{codeInvolved}

\comp{Para liberar los recursos, al igual que en el controlador de \wifi{}, llamamos al método \textit{stop()} y restaurando la situación inicial con el método \textit{start()}. //esto podría ser diseño yo creo que va fuera.}
%--
El controlador maneja tres tipos de hebras: la que acepta conexiones (\var{AcceptThread}), la que lanza la conexión (\var{ConnectThread}) y la que mantiene la conexión entre esclavo y maestro (\var{ConnectedThread}), de este último tipo podemos tener más de una. 

Un nodo normal necesita mantener una hebra del tipo \var{AcceptThread} en todo momento que no esté conectado a un nodo coordinador y que la interfaz en curso sea \bt{}. Cuando está conectado al coordinador mantiene una instancia de \var{ConnectedThread}. 

El nodo coordinador necesita mantener tantas instancias de la hebra \var{Connected\-Thread} como esclavos tenga conectados. Estas hebras se guardan en una matriz asociativa cuya clave es la dirección \ac{MAC} de \bt{} del dispositivo con el cual se establece la comunicación. Estas hebras se crean cuando la hebra \var{ConnectThread} consigue establecer la conexión. La clave nos permite acceder al método \textit{write()} de la hebra correspondiente cuando el servicio nos envía datos para entregarlos al destino oportuno.\\

%XXX-jblesa quita Hasmap y ponlo en español XXX-cvillar hashmap = matriz asociativa... por ejemplo.

La espera para levantar la interfaz \bt{} también se realiza mediante consulta activa, cuya variable de control se maneja en el \textit{BroadcastReceiver}: \class{StatusReceiver\_bluetooth}. La variable cambia cuando llegan anuncios del tipo \Scst{ACTION\allowbreak\_STATE\allowbreak\_CHANGED} con el parámetro \Scst{STATE\_ON}.

Para levantar la interfaz \bt{} obviamos la recomendación de \android{} que incita a preguntar al usuario a través de un diálogo para la activación del \bt{}. Un requisito de la \ac{CR} es ser transparente al usuario, por ello utilizamos la llamada asíncrona del método \textit{enable()} de la clase \class[android.bluetooth]{BluetoothAdapter}. Esto desencadena su encendido y anuncios posteriores del sistema, que capturamos también con el \textit{BroadcastReceiver}, informando que ya está levantada la interfaz \bt{}.\\

El método \textit{connect()} arranca una hebra independiente para evitar que su procesamiento bloquee al resto del programa. La razón de asegurar una ejecución en segundo plano reside en que este método es llamado en dos puntos de la arquitectura: al configurar la interfaz y al recibir una petición desde la aplicación para conectarse de manera manual a un nodo (ver sección~\ref{subsec:connectViaBT}). En el primer caso este proceso ya está en segundo plano, pero en el segundo si no se ejecutase en su propia hebra, se retrasaría el procesamiento de los mensajes encolados en el \textit{Handler} del servicio con las aplicaciones sin necesidad, ya que no hay que devolver ni utilizar el resultado en el proceso.

La llamada a este método comienza con la interrupción de la hebra tipo \textit{ConnectThread} (la que lanza la conexión) si estuviese ejecutándose por una llamada previa inacabada. Tras esto lanzamos una nueva instancia de esta hebra y esperamos a que termine con la instrucción de Java \textit{join()}. Por el mecanismo interno de estados del controlador si la conexión se ha producido con éxito se habrá modificado un \textit{flag} que nos permite terminar la ejecución del método, si no, reintentamos hasta que alcancemos el máximo de intentos (pasado como parámetro).

Mientras tanto la \textit{AsyncTask} donde está alojado el proceso nos habrá esperado mediante espera activa, cuya salida está garantizada por los \textit{flags}: \var{flagNewDevice} y \var{numFailConnection}, accesibles a través de los métodos \textit{getFlagNewDevice()} y \textit{getNumFailedConnection()} del servicio.\\

Una vez hemos terminado de lanzar las conexiones a los nodos indicados finalizamos la tarea en segundo plano, dejando la ejecución del envío del mensaje que finaliza la negociación en la hebra de usuario o principal.

%------------------------------
\subsection{Registro de un nodo en la red}
\label{subsec:enterInNetworkimpl}

Un nodo se puede representar en una estructura de datos como la expresada en la tabla~\ref{itm:infoNode}\footnote{Notar que el campo ``Dirección IP'' puede no ser informado por no estar disponible en ese momento o ser innecesario}:\\


\protobufTableInit{Estructura mensaje representación de un Nodo (serialización)}
	\protobufItem{\texttt{name}}{Una \String{}  con el nombre del nodo en la red.}
	\protobufItem{\texttt{role}}{Una \String{} cuyo valor \bsq{p} es interpretado como usuario primario y \bsq{s} como secundario (\bsq{u} para valor desconocido).}
	\protobufItem{\texttt{type}}{Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador  (\textcolor{notImplemented}{\bsq{t} coordinador temporal en \bt{} [sin implementar]}, \bsq{u} para valor desconocido).}
	\protobufItem{\texttt{macBT}}{Un \String{} cuyo valor es la dirección MAC en \bt{} del nodo, clave que identifica al nodo de manera unívoca}.	
	\protobufItem{\texttt{ipAddress}}{Una \String{} cuyo valor representa la dirección IP (formato IP4) del nodo.}
	\protobufItem{\texttt{coorMacBT}}{Una \String{} que contiene la dirección MAC de \bt{} del coordinador del nodo que estamos enviando la información.}
\protobufTableEnd{Representación de un nodo necesaria para recrear el mapa de red, contenido del mensaje de señalización}{infoNode}

Este mensaje no se presenta nunca sólo, si no que está encapsulado en un mensaje de señalización (ver en la figura~\ref{fig:messageProto}) junto con otra información relevante para identificar el tipo de evento. Como hemos visto en diseño, el nodo coordinador manda dos tipos de mensaje: uno informado al nuevo nodo del resto de nodos en la red (cuya estructura la podemos ver en la tabla~\ref{itm:populationToNewNode}) y otro tipo correspondiente a la información que recibe el resto de nodos acerca del nuevo dispositivo. Tenemos que enviar tantas copias de este mensaje como nodos había en la red antes de la nueva inclusión sin contar al nodo coordinador (ver detalle en la tabla~\ref{itm:newNode}). 

\protobufTableInit{Estructura mensaje población de red}
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo (coordinador).}
	\protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{TOPOLOGY} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{Topology}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{change}}{Valor \bsq{ALL} del enumerado ``TopologyChange''.}  			
					%\begin{description}
						\protobufItem{Mensaje: \texttt{Node}}{Mensaje que representa al nodo (ver tabla~\ref{itm:infoNode}). Hay tantos mensajes internos de este tipo como dispositivos hay en la red.}
					%\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} informando del resto de dispositivos al nuevo nodo}{populationToNewNode}


\protobufTableInit{Estructura mensaje nuevo nodo en la red}
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo (coordinador).}
	\protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{TOPOLOGY} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{Topology}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{change}}{Valor \bsq{NEW} del enumerado ``TopologyChange''.}  			
					%\begin{description}
						\protobufItem{Mensaje: \texttt{Node}}{Mensaje que representa al nuevo nodo en la red (ver tabla~\ref{itm:infoNode}).}
					%\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} informando del nuevo nodo al resto de dispositivos}{newNode}

\clearpage
Como vimos en diseño, la interfaz condiciona quien debe dar el primer paso, esto se debe a restricciones en el diseño de las diferentes interfaces de comunicación. 

\subsubsection{Registro sobre Wi-Fi}
\begin{codeInvolved}
\begin{files}
\textbf{WifiController}: SendHelloPacket (AsyncTask), UDPlistener (Thread), stopSendingHelloPacket(), setState()\\
\textbf{Service}: mHandlerWf, sendInfoNewNodeOnNetwork()\\
\textbf{Database}: eventNewDeviceIPCoordinator(), newDeviceEventNormal(), modifyNode()
\end{files}
\end{codeInvolved}

Una red \wifi{} tiene más flexibilidad para recrear la tipología de red que se requiera. En el caso que sea del tipo infraestructura, es decir existe uno o varios puntos de acceso, la tipología que subyace es estrella. Al contrario que la implementación de \bt{}, en \wifi{} esto alcanza a los dos primeros niveles del modelo de la pila de protocolos de comunicación, por lo que la tipología a efectos del programador de aplicaciones está enmascarada. Así podemos tener desde conexiones \ac{PPP} hasta \textit{multicast} o \textit{broadcast}. La fiabilidad de este tipo de conexiones viene determinada por la elección del protocolo de transporte, ya que algunos tipos de conexiones no son compatibles con todos los niveles de fiabilidad.\\

En la tabla~\ref{itm:helloPacket} vemos la estructura de los paquetes \textit{``HelloPacket''} usados para registrarse en la red, este registro de los nodos normales se monta sobre el envío de paquetes \ac{UDP} con la ayuda del objeto \textit{DatagramSocket}. La dirección a la que van dirigidos estos paquetes se alterna entre la dirección de difusión de la red a la que estemos conectados y una dirección de \textit{multicast}: \bsq{224.2.76.24}. El motivo es intentar incrementar el éxito de llegada e interpretación de estos paquetes. Pueden presentarse fallos en este proceso por el establecimiento de la ruta, por la corrupción de los datos del paquete, porque el \ac{AP} menosprecie este tráfico o incluso por el propio sistema \android{} que no permite que el \textit{driver} de \wifi{} este siempre escuchando en la dirección de difusión y cuya notificación no llega al \textit{socket}.

Para ello enviamos una ráfaga de 20 paquetes espaciados 800 milisegundos, estos valores garantizan una buena acogida del nodo en la nueva red sin extender demasiado la latencia del proceso en caso de fallo. Uno de cada cinco van dirigidos a la dirección de \textit{multicast}, el resto a la de difusión. El envío de estos paquetes se realiza, al ser un proceso largo, en segundo plano implementado como una \textit{AsyncTask} en el submódulo \var{Registrador en la Red}.\\

%XXX-jblesa Este parrafo es ilegible. Pon muchos mas puntos. XXX-cvillar ok reestructurado.

%Los paquetes enviados en ráfagas que son útiles para el registro en la red siguen la estructura que dicta la figura~\ref{itm:helloPacket}, son los denominados \textit{``HelloPacket''}.
%La estructura de los paquetes \textit{``HelloPacket''} puede verse en la figura~\ref{itm:helloPacket}, estos paquetes enviados en ráfagas sirven para registrarse en la red. 
\protobufTableInit{Estructura mensaje registro en la red \wifi{}}
  %\item[\fbox{\colorbox{green}{Tipo de paquete}}]\hfill\\[3pt] Valor ``HELLO'' del enumerado ``packetType''
	\protobufItem{\texttt{packetType}}{Valor \bsq{HELLO} del enumerado ``PacketType''.}
	%\\\rule{2cm}{0.4pt}
	\protobufItem{Mensaje: \texttt{Hello}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{packetType}'':}
	%\\\noindent\rule{\textwidth}{0.4pt}
	\begin{description}
		\protobufItem{\texttt{name}}{Una \String{}  con el nombre del nodo en la red.}
		\protobufItem{\texttt{role}}{Una \String{} cuyo valor \bsq{p} es interpretado como primario y \bsq{s} como secundario (\bsq{u} para valor desconocido).}
		\protobufItem{\texttt{type}}{Una \String{} cuyos valores pueden ser: \bsq{n} normal, \bsq{c} coordinador (\textcolor{notImplemented}{\bsq{t} coordinador temporal en \bt{} [sin implementar]}, \bsq{u} para valor desconocido).}
		%\item[\fcolorbox{blue}{red}{Dirección MAC}]\hfill\\[3pt] Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca
		\protobufItem{\texttt{macBT}}{Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca.}
	\end{description}
\protobufTableEnd{Campos del paquete \msgNETcaption{} ``HelloPacket''}{helloPacket}

\subsubsection{Registro bajo Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{BluetoothController}: connected(), setState()\\
\textbf{Service}: mHandlerBt, sendInfoNewNodeOnNetwork()\\
\textbf{Database}: newDeviceEventNormal(), modifyNode(), updateInfoDeviceCoordinator()
\end{files}
\end{codeInvolved}

La única topología de red permitida en una red \bt{} como vimos en
\ref{sec:bt-analysis}, es la de estrella formada por un maestro y
varios esclavos (las puntas de la estrella). Siguiendo este modelo podemos crear \textit{piconets} \cite{piconet}, éstas se identifican por un \ac{UUID} que se hace necesario para, entre otras cosas, registrar los \textit{sockets} que van montados sobre un canal \ac{RFCOMM} \cite{rfcomm}. Por ello el nodo coordinador (el maestro) es quien lanza las conexiones, para ello no necesitamos ningún mecanismo de registro por parte de los nodos normales tal y como ocurre en \wifi{}.

%XXX-jblesa. No funciona la ref bt-analisis XXX-cvillar ya funcionará cuando se añada el análisis

%------------------------------
\subsection{Salida de un nodo de la red}
\label{subsec:salidaRedImpl}

Tras recibir el mensaje de desregistro (ver tabla~\ref{tab:unregisterClientMenssage}) procedemos a borrar la aplicación del mapa \var{mClients} y con él también las referencias cruzadas en los mapas \var{mOut\_app} y \var{mIn\_app}. Estos procesos se encapsulan en el método \textit{removeClientknownMessengerReply()} que necesita de la representación del objeto \textit{Messenger} en forma de \String{} y \textit{removeClientKnownAppCode()} que requiere del ``código de aplicación'' para efectuar el borrado.\\

Una vez no haya aplicaciones sobre el servicio procedemos a la destrucción del mismo tal y como vimos en diseño en la sección~\ref{subsec:salidaNodoRed}. Las acciones (tanto aviso al resto de nodos como restauración de la situación inicial) a realizar las incluimos en el método \textit{onDestroy()}: un método que llama \android{} automáticamente, en este caso, cuando no hay referencias al servicio, es decir todas las peticiones de \textit{bind()} han sido correspondidas con sus \textit{unbind()} y cuando hemos llamado manualmente al método \textit{stopSelf()} desde el mismo servicio cuando \var{mClients} deja de contener aplicaciones.\\

El envío del paquete \textit{``ByePacket''} en el caso de \wifi{} se realiza bajo una \textit{AsyncTask} que finaliza con la destrucción del propio controlador. Se establece una ronda de conexiones \ac{TCP} a todos los nodos normales que haya en la red en caso de que el nodo coordinador abandone la red, o bajo \ac{UDP} (aunque están implementadas ambas formas) en caso de que un nodo normal abandone la red. %En la figura~\ref{itm:byePacket} se refleja
La estructura de este paquete es:

\protobufTableInit{Estructura mensaje desregistro en la red \wifi{}}
  \protobufItem{\texttt{packetType}}{Valor \bsq{BYE} del enumerado ``PacketType''.}
	\protobufItem{Mensaje: \texttt{Bye}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{packetType}'':}
	\begin{description}
		\protobufItem{\texttt{macBT}}{Una \String{} cuyo valor es la dirección MAC de \bt{}, clave que identifica al nodo de manera unívoca.}
	\end{description}
\protobufTableEnd{Campos del paquete \msgNETcaption{} ``ByePacket''}{byePacket}

Respecto al mensaje de señalización que envía el nodo coordinador al resto de nodos cuando un dispositivo sale de la red, 
%en la figura~\ref{itm:lostNode} 
podemos ver el detalle de los campos incluidos en la siguiente tabla:

\protobufTableInit[!h]{Estructura mensaje pérdida nodo en la red}
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo (coordinador).}
	\protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{TOPOLOGY} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{Topology}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{change}}{Valor \bsq{LOST} del enumerado ``TopologyChange''.}  			
					%\begin{description}
						\protobufItem{Mensaje: \texttt{Node}}{Mensaje que representa al nodo que acaba de salir de la red (ver tabla~\ref{itm:infoNode}).}
					%\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} pérdida de un nodo}{lostNode}

\newpage%ajustar titulo para la nueva página
%------------------------------
\subsection{Actualización de parámetros en la red}
\label{subsec:updateSettingsImpl}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, spreadNodeChangeOnNetwork(), updateInformationToCoordinator()
\end{files}
\end{codeInvolved}
\comp{Yo creo que esto es diseño y ni lo pondría\\
Como vimos en diseño tenemos un conflicto en la separación de capas. Existe la necesidad de poder modificar todos los parámetros del nodo cognitivo para su adecuación y colaboración en cualquier \ac{CWSN}. Tenemos dos opciones:
\begin{itemize}
	\item No permitir actualizar estos parámetros si no es con la aplicación desarrollada alojada en el mismo ámbito que el servicio cognitivo. Con lo cual, el servicio accedería a estos valores del archivo de preferencias (usando el objeto \textit{Preference} \cite{preferences}) ubicado en el mismo paquete que la aplicación. Esto implica que cada vez que se requiera un cambio en el nombre, periodo de la tarea cognitiva o tipo de nodo, tener que abrir la aplicación y cambiar éstos desde el menú de configuración habilitado a tal efecto.
	\item La otra opción pasa por permitir que cualquier aplicación pueda cambiar estos valores, garantizando que estas actualizaciones no penalicen a otras aplicaciones que ya estén en ese momento en ejecución.
\end{itemize}

Nos hemos decantado por la segunda opción, por ello en diseño vimos que hay una manera especial de actualizar estos parámetros y un mecanismo para garantizar que no haya conflictos. Ello exige comunicar todos los parámetros del servicio a las aplicaciones cuando estas se registran y el almacenaje de estos parámetros en base de datos para independizar el archivo de preferencias que compete exclusivamente a la aplicación desarrollada a la vez que el servicio, pero que éste no debería tener acceso a él.\\
}
%--
Se necesitan dos tipos de mensajes de red para implementar una actualización de parámetros. Primero el nodo normal ha de informar al coordinador del cambio de parámetros (ver tabla~\ref{itm:updateToCoordinator}). Seguidamente el coordinador actualizará al resto de nodos estos nuevos parámetros, para ello distribuye el mensaje cuyo detalle se ve en la tabla~\ref{itm:updateParams}, a cada uno de los nodos de la red.

\protobufTableInit{Estructura mensaje envío de parámetros al coordinador}
  \protobufItem{\texttt{type}}{Valor \bsq{RESPONSE} del enumerado ``MessageType''.}
	\protobufItem{Mensaje: \texttt{Response}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{what}}{Valor \bsq{INFO} del enumerado ``AskType''.}
		%\protobufItem{Mensaje de información / Mensaje \var{INFO} \Scst{INFO}}]\hfill\\[3pt] Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``What'':}
		\protobufItem{Mensaje: \texttt{Info}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{what}'':}
		\begin{description}		
			\protobufItem{\texttt{name}}{Una \String{} con la representación del nombre del nodo.}
			\protobufItem{\texttt{role}}{Una \String{} cuyo valor \bsq{p} representa el papel de usuario primario y \bsq{s} identifica al usuario secundario.}
			\protobufItem{\texttt{type}}{Una \String{} cuyos valores pueden ser: \bsq{n} normal o \bsq{c} coordinador.}			
		\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} información de parámetros al coordinador}{updateToCoordinator}

\protobufTableInitLong{Estructura mensaje informe de la actualización de parámetros de un nodo}
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo (coordinador).}
	\protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{TOPOLOGY} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{Topology}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{change}}{Valor \bsq{UPDATE} del enumerado ``TopologyChange''.}  			
					%\begin{description}
						%\protobufItem{Representación de un nodo / Mensaje Node}{Mensaje que representa al nodo que ha actualizado sus parámetros (ver tabla~\ref{itm:infoNode}).}
				\protobufItem{Mensaje: \texttt{Node}}{Mensaje que representa al nodo que ha actualizado sus parámetros (ver tabla~\ref{itm:infoNode}).}
					%\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} informe de actualización de parámetros de un nodo enviado por el coordinador hacia el resto, estructura siguiendo la figura~\ref{fig:messageProto}}{updateParams}


%------------------------------
\subsection{Intercambio de mensajes}
La transmisión y recepción de datos se realizan a través del intercambio de mensajes definidos en la \ac{API}. Podemos destacar tres acciones: el envío, la recepción y una mezcla de ambos reservada sólo al coordinador: el reenvío de mensajes.

\subsubsection{Recepción de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, mHandler<controlador>, incomingContentNormal(), incomingDataMessageToApp()
\end{files}
\end{codeInvolved}
Este proceso empieza cuando la hebra del controlador de la interfaz de comunicación en curso sale del bloqueo y envía el evento \Scst{INTERFACE\_STATE\_RECEIVING}:
\paragraph{Wi-Fi} En este caso salimos del bloqueo que nos produce la instrucción \textit{accept()} al aceptar una conexión del cliente para que nos envíe datos. En este caso empezamos a leer datos hasta que no queden datos disponibles: bien con la sentencia \bsq{\textit{available()} == 0} (del \textit{stream} de entrada obtenido del \textit{socket} con la instrucción \textit{getInputStream()}) o bien que el \textit{byte} leído sea \bsq{-1}. En ese momento cerramos la conexión y quedamos bloqueados a la espera de una nueva.

\paragraph{Bluetooth} Como la conexión ya está establecida, la
instrucción que nos bloquea es precisamente la de leer. Al igual
cuando terminamos de leer (no hay más datos disponibles o hemos leído
\bsq{-1}) nos bloqueamos de nuevo con la misma instrucción. No
podemos cerrar la conexión pues es necesaria para intercambiar la
información de salto de frecuencia que utiliza \bt{}.\\

Ambos \texttt{Controladores} entregan los datos leídos al servicio (ver tabla~\ref{tab:messageReadController}) para que los interprete y actúe presentando y/o reenviándolos. Para ello el \var{Gestor de interfaces} se ayuda del campo ``\texttt{id\_app}'' o ``código de aplicación'' para discernir qué aplicación está interesada en los datos recibidos y del campo ``\texttt{from}'' para averiguar el origen del mensaje, ambos campos están en los \textit{bytes} leídos de la red.

\messageTableInit{\controllerToServ}{2 =\\ \scriptsize{MESSAGE\_READ}}{Número de \textit{bytes} leídos}{\nc{}}{\textit{bytes} leídos de la red}{\nc{}}
\messageTableExtraControllerSpecified{\wifi{}}{device\_ip\_address}{Una \String{} con la dirección IP del nodo que nos envía los datos}
\messageTableExtraControllerSpecified{\bt{}}{device\_name}{Una \String{} con el nombre proporcionado por los servicios de \bt{} de \android{} (no es relevante)}
\messageTableExtraAddrow{device\_address}{Una \String{} con la dirección MAC de \bt{} del nodo que nos envía los datos}
\messageTableEnd{Mensaje perteneciente a la interfaz Módulo cognitivo - Controlador en sentido ascendente tras  recibir un mensaje de red}{messageReadController}

\newpage%para ajustar el título a una nueva página.
\subsubsection{Envío de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: m2service, builtDataMessage(), getNextNodes(), send(), mHandler<controlador>, outgoingContentProgress()\\
\textbf{DataMessageQueue}: add(), hashMessage(), changeStatus(), remove()
\end{files}
\end{codeInvolved}

El envío comienza encolando el mensaje si éste ha pasado los mecanismos de validación, entonces el mensaje se codifica según la estructura descrita en la tabla~\ref{itm:dataMessage} tal y como comentamos ya en diseño.

\protobufTableInit{Estructura mensaje datos}  
  \protobufItem{\texttt{type}}{Valor \bsq{DATA} del enumerado ``MessageType''.}
  \protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo.}
	\protobufItem{\texttt{to}}{Una lista de \String{} con la lista con las direcciones MAC de \bt{} de los nodos destinatarios.}
	\protobufItem{\texttt{id\_app}}{Una \String{} con el ``código de aplicación'' para filtrar el mensaje en destino.} 
	\protobufItem{\texttt{timestamp}}{Un \textit{long} con la representación del momento de tiempo en el cual la aplicación entregó el mensaje al servicio.}
	\protobufItem{Mensaje: \texttt{Data}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{payload}}{Una \String{} con el contenido del mensaje.} 
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} datos}{dataMessage}

El modelo de cola utilizada es \ac{FIFO}. Se implementa con un \textit{LinkedHashMap} en la clase \class[util]{DataMessageQueue}. La razón de no usar un objeto \textit{Queue} puro es la necesidad de acceder a cualquier elemento en todo momento debido a la heterogeneidad de estados en que pueden encontrarse éstos.

El \textit{LinkedHashMap} tiene como clave un tipo \textit{long} que representa el \textit{hash} o resumen del mensaje. Para calcular este resumen no podemos usar la función \textit{hashcode()} de un \byteArray{} puesto que obtenemos valores distintos en cada invocación \cite{hashIssue}, por ello necesitamos realizar una función personalizada sencilla pues no prevemos grandes volúmenes en esta cola por lo que la colisión es un riesgo bajo. Este \textit{hash} lo calculamos de esta forma\footnote{Posteriormente se ha descubierto que la función \textit{deepHashCode()} tiene en cuenta los problemas citados y los resuelve. (ver \url{http://stackoverflow.com/questions/4671858/deephashcode-with-byte-array})}:
\begin{lstlisting}
	long hash = 17;
	hash = hash * timestamp;
	hash = hash + 3 * from.hashCode() >> 1;
	long tmp =  hash & from.hashCode();
	hash = (hash ^ tmp);
	hash = hash + 24 * payload.hashCode();
	return hash;
\end{lstlisting}

La clave de la matriz asociativa donde se guarda el mensaje encolado es un objeto la clase \texttt{MessageInQueue} (clase anidada en \texttt{DataMessageQueue}), cuyas variables de clase son: 
\begin{itemize}
	\item Un enumerado del tipo \var{MessageState} cuyos valores pueden ser:
	\begin{itemize}
		\item \Scst{PENDING\_SEND}, se asigna este estado a los mensajes encolados que no pueden ser enviados en el momento de su recepción.
		\item \Scst{SENDING}, estado asignado a los mensajes que permanecen en la cola mientras se está procediendo a su envío (salida del nodo).
		\item \Scst{PENDING\_ACK}, estado que indica que el mensaje ha sido entregado en el siguiente salto en la red pero falta confirmación de entrega en destino o destinos finales.
		\item \textcolor{notImplemented}{\Scst{OK} | Actualmente los mensajes que se han entregado correctamente se borran de la cola por lo que no se usa.} 
		\item \textcolor{notImplemented}{\Scst{NOK} | no usado. Útil por si queremos retransmitir el mensaje que falló en su entrega.}
	\end{itemize}
	\item Un \byteArray{} que contiene el mensaje ya codificado listo para su envío.

%XXX-jblesa. Quita byte array y ponlo en español. XXX-cvillar array de bytes, vale?
\end{itemize}

Utilizando el \textit{hash} del mensaje podemos recuperarlo para cambiar su estado o enviarlo a la aplicación tras producirse la confirmación de envío (ver tabla~\ref{tab:outgoingContentResultApp}).\\

El envío de datos a la red se realiza en los \textit{Controladores} a
través del método \textit{write()}, estos métodos recogen, un
\byteArray{} con el mensaje a enviar ya codificado , una lista
de \String{} con las direcciones adecuadas a la interfaz que se trate y una
\String{} en representación al origen del mensaje. La adaptación de
los argumentos se realiza con la ayuda de dos métodos del \var{Gestor de Interfaces}:

%XXX-jblesa. Adaptacion con tilde. No se porque no me deja poner tildes. XXX-cvillar gracias.
\begin{itemize}
	\item \textit{getNextNodes()}: este método nos sirve para funciones de encaminamiento. Pasada una lista de identificadores de los nodos o una lista de direcciones \ac{MAC} de \bt{} como parámetro, nos devuelve según la interfaz en curso y el tipo de nodo, una lista de \String{s} con las direcciones válidas de comunicación. Es decir una lista de direcciones IP o una lista de direcciones MAC de \bt{} de los siguientes nodos en la cadena de envío.
	\item \textit{send()}: recoge todos los parámetros y llama al método \textit{write()} del controlador oportuno.  
\end{itemize}
%~\\

%Finalmente el mensaje que sale a red lleva la codificación que se aprecia en la tabla~\ref{itm:dataMessage},
Una vez este mensaje ha sido escrito con la ayuda del método \textit{send()} del servicio y en segunda instancia con el método \textit{write()} del controlador correspondiente, el \var{Gestor de Interfaces} espera recibir una confirmación de escritura. Esta información la podemos ver en la siguiente tabla:%~\ref{tab:messageWriteController} vemos el formato de este tipo de mensaje.\\

\messageTableInit{\controllerToServ}{3 =\\ \scriptsize{MESSAGE\_WRITE}}{número mensajes escritos OK}{número mensajes escritos NOK}{\textit{bytes} enviados a través de la red}{\nc{}}
\messageTableExtra{requester}{Una \String{} que representa el objeto \textit{Messenger} de la aplicación que origina el mensaje}
\messageTableExtraAddrow{addressNotDelivered}{Una lista de \String{} con las direcciones \ac{MAC} de \bt{} o direcciones IP, según sea el controlador que envíe este dato, de los nodos a los cuales no se ha podido entregar el mensaje correctamente}
\messageTableEnd{Mensaje perteneciente a la interfaz Módulo cognitivo - Controlador en sentido ascendente, resultado de envío de datos}{messageWriteController}

%~\\
Los métodos \textit{write()} de ambos \texttt{Controladores} vistos bajo el modelo de caja negra son idénticos salvo la lista de direcciones que toman como parámetro, Para uniformar y que de acara al servicio todos los \texttt{Controladores} sean iguales, nos ayudamos de estos métodos del \texttt{Gestor de interfaces}. Aunque hayamos podido adaptar el punto de entrada, la implementación no puede ser similar ya que no pueden producir los mismos resultados de la misma manera debido a que en \bt{} la conexión está establecida y en \wifi{} hay que establecerla:

\paragraph{Bluetooth} Se obtienen cada una de las hebras que se utilizan en las conexiones y se vuelcan los datos directamente al \textit{socket} donde se produce una escritura asíncrona que hace que ésta parezca inmediata. Realizamos lo mismo en todos los \textit{sockets} donde haya que transmitir información. Acto seguido confeccionamos un mensaje del tipo \Scst{MESSAGE\_WRITE} para que sea manejado en el servicio. Por último, termina la ejecución del método \textit{write()} sin devolver nada.

\begin{codeInvolved}
\begin{files}
\textbf{WifiController}: write(), \textbf{SendoIP} (ServiceIntent), \textbf{sentReceiver} (BroadcastReceiver interno)
\end{files}
\end{codeInvolved} 

\paragraph{Wi-Fi} Sin embargo en esta interfaz el bucle de establecimiento y volcado de datos al \textit{socket} nos haría esperar demasiado, pudiendo retrasar otras partes del flujo del programa causando problemas. En este caso donde tenemos que levantar la conexión, nos ayudamos de otra hebra en paralelo que haga esta misión (implementado como un \textit{serviceIntent}, ver sección~\ref{subsubsec:serviceIntent}) y recogemos su resultado (cuando esté) gracias a un \textit{BroadcastReceiver} ubicado en el propio controlador. La acción que captura esta respuesta es \Scst{SendoIP\allowbreak.ACTION\allowbreak\_SENT} y en ella encapsulamos:
\begin{itemize}
	\item Un valor booleano que indique si la escritura ha sido correcta o no.
	\item Una \String{} que representa la dirección \ac{IP} donde se ha escrito.
	\item Un valor booleano que indique si se trata del último envío del mensaje de datos.
\end{itemize}

Cuando detectamos el final de un envío del mensaje en todos los nodos
a los que va dirigido, devolvemos una respuesta igual que la de \bt{}
uniformando de nuevo el flujo y ocultando detalles de implementación
al servicio, reforzando nuestro modelo de capas. Para ello, hemos
debido de almacenar al principio del proceso de envío los datos a
enviar para poder devolvérselos al servicio. Este almacenaje se
realiza sobre un objeto \textit{Queue<byte[]>}. Así evitamos que en el
anuncio capturado por el \textit{BroadcastReceiver} se incluya el mensaje a escribir en la red, lo que hace que la respuesta sea más ligera.\\

Por tanto, el método \textit{write()} del controlador \wifi{} al igual que su homólogo en \bt{} no devuelve nada pero su tiempo de ejecución es parecido. En un caso se producen escrituras asíncronas y en el otro inicializaciones de \textit{serviceIntent} de la clase \class[util]{SendoIP}.\\

%Por otra parte 

\subsubsection{Reenvío de mensajes}
\label{forwardProcessImpl}

\begin{codeInvolved}
\begin{files}
%\vspace{2.7pt}
\textbf{Service}: mHandler<controlador>, incomingContentCoordinator(), outgoingContentProgressCoordinator()
\end{files}
\end{codeInvolved}

Al ser una mezcla de una recepción y un envío de datos, los detalles de implementación han sido relatados ya previamente. El parámetro obviado en el flujo de diseño se trata de una \String{} que o bien representa al objeto \textit{Messenger} de la aplicación que ha enviado el mensaje de datos, o bien una \String{} especial que representa la situación de reenvío donde recordamos que la aplicación que ha originado el mensaje no se encuentra en el nodo en cuestión, si no que se trata de otro nodo de la red.

Las \String{s} especiales que representan la situación de reenvío y que son claves para que el flujo del proceso actúe en consecuencia son: \textit{``forward-me''} y \textit{``forward-not-me''} para referirse tanto a la situación en la que el coordinador forma parte de la lista de destinatarios del mensaje que se reenvía, como a cuando no forma parte de ésta.\\

Al haber elegido que este parámetro sea \String{} tanto en el caso de un envío normal como en el de un reenvío, hace que tengamos el mismo punto de entrada y por tanto el mismo tratamiento. Al terminar éste con el informe del éxito o fracaso, podemos discernir que se ha tratado de un reenvío al examinar el campo ``\texttt{requester}'' y actuar en consecuencia mandando el mensaje de confirmación. Es necesario transmitir este parámetro a través de todo el flujo de envío ya que son procesos que pueden no resolverse de manera consecutiva. Además son procesos sin memoria y pueden ser disparados por distintas aplicaciones en cualquier momento donde el orden entre distintos procesos de envío no está garantizado. Por otra parte, al representar el objeto \textit{Messegner} de \android{} como una \String{} en vez de en sí mismo, se evita serializar un objeto complejo o que tengamos que ubicarlo un sitio que no está pensado para ello: estamos hablando del campo del mensaje \replyTo{}. Esta información pertenece al \texttt{Gestor del Sensor} y el mensaje citado es propio de la interfaz entre el servicio cognitivo y los \texttt{Controladores}.\\

El mensaje de red que enviamos de vuelta al nodo originario confirma la entrega del mensaje que acabamos de reenviar, su estructura es la que sigue:

\protobufTableInit{Estructura mensaje ACK}
  \protobufItem{\texttt{type}}{Valor \bsq{RESPONSE} del enumerado ``MessageType''.}
  \protobufItem{Mensaje: \texttt{Response}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{what}}{Valor \bsq{ACK} del enumerado ``AskType''.}
		\protobufItem{Mensaje: \texttt{ACK}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{what}'':}
			\begin{description}
				\protobufItem{\texttt{hash}}{Un \textit{long} con el identificador único de mensaje.}
				\protobufItem{\texttt{successfulmessages}}{Un \integer{} con el número de mensajes que han sido correctamente entregados.}
				\protobufItem{\texttt{undeliveredNodes}}{Una lista de \String{} con las direcciones MAC de \bt{} de los nodos a los cuales no se ha podido entregar el mensaje.}
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} ACK}{ackMessage}

%------------------------------
\subsection{Sensado del entorno compartido y política cognitiva}

%En la tabla~\ref{itm:scanMessage} se ilustra el formato del mensaje de red 
Para compartir los datos de sensado con el nodo coordinador utilizamos el siguiente mensaje de red:

\protobufTableInit{Estructura mensaje SCAN}
  \protobufItem{\texttt{type}}{Valor \bsq{RESPONSE} del enumerado ``MessageType''.}
  \protobufItem{Mensaje: \texttt{Response}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{what}}{Valor \bsq{SCAN} del enumerado ``AskType''.}
		\protobufItem{Mensaje: \texttt{SCAN}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{what}'':}
			\begin{description}
				\protobufItem{\texttt{priority}}{El enumerado ``Priority'' con la urgencia del sensado, toma dos valores \bsq{\small TASK} para sensados normales y \bsq{\small URGENT} para marcar que la información del entorno es sensible.}  
				\protobufItem{\texttt{rssi}}{Un \integer{} con el nivel de señal de la red \wifi{} a la que estamos conectados (-9999 si no estamos en ninguna).}
				\protobufItem{\texttt{throughput}}{Un \double{} con el resultado promedio móvil del intervalo medido en segundos entre envíos de mensajes de datos por parte de las aplicaciones.}
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} SCAN}{scanMessage}

El envío de este mensaje se consigue gracias a la tarea periódica del \var{Optimizador} o a los mecanismos que tiene el módulo de \var{Sensado} para detectar situaciones de peligro.
%\newpage %para ajustar el título a una nueva página.
\subsubsection{Parámetro del entorno: RSSI}
\begin{codeInvolved}
\begin{files}
~\vspace{1.7pt}
\textbf{Service}: normalCognitiveTask(), mWifiAdapter.getConnectionInfo(), sendTroublingRssi()
\end{files}
\end{codeInvolved}

Gracias al adaptador \wifi{} (\class[android.net.wifi]{WifiManager}) que nos facilita la plataforma \android{}, podemos obtener un objeto de la clase \class[android.net.wifi]{WifiInfo} a través del método \textit{getConnectionInfo()}. El objeto obtenido nos facilita entre otros el valor del \ac{RSSI}: \textit{getRssi()}.

Como vimos en diseño, este valor también se puede obtener mediante los anuncios que envía el sistema \android{}, para ello registramos nuestro \textit{BroadcastReceiver} empleado para \wifi{}: \class{StatusReceiver\_wifi}, a la acción \Scst{RSSI\allowbreak\_CHANGED\allowbreak\_ACTION}.
Utilizando estos anuncios somos capaces de enviar datos del entorno con prioridad \bsq{\Scst{URGENT}}, invocando el método \textit{sendTroublingRssi()}, que desemboca en un envío inmediato al coordinador de los datos de sensado.%(es diseño) Al recibirlo el coordinador vuelve a evaluar estos datos para evitar cambios de contexto disparados por umbrales que no concuerden entre los dos nodos. 
\newpage %para ajustar el título a una nueva página.
\subsubsection{Parámetro del entorno: Intervalo promedio envío de mensajes}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: normalCognitiveTask()\\
\textbf{DataMessageQueue}: getAvgArrivalRateUpdateTillNow()
\end{files}
\end{codeInvolved}

Para calcular el promedio almacenamos los valores en una
\textit{LinkedList}, éstos son de tipo \double{} y representan el tiempo transcurrido entre mensajes entregados por las aplicaciones. Este objeto se ubica en la clase \class[util]{MovingAverage} que es utilizada por la cola de mensajes cada vez que encola un mensaje. Al instanciarse, se elige el número de muestras de las que se va a tomar el promedio, en nuestro caso el tamaño de ventana es seis.\\
La razón de poner el promedio en una clase independiente es por si se necesita usar otro tipo de promedios (que puedan ser codificados como \double{}) en otra parte de la arquitectura, por ejemplo su uso en políticas cognitivas.

\subsubsection{Política cognitiva}
\label{subsubsec:policyImpl}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: mayTakeAdvantageOfBT() mayTakeAdvantageOfWiFi(), coordinatorCognitiveTask()
\end{files}
\end{codeInvolved}

%El envío de datos del entorno con prioridad \Scst{URGENT} se realiza gracias al método \textit{sendTroublingRssi()}. Al recibirlo el coordinador vuelve a evaluar estos datos para evitar cambios de contexto disparados por umbrales que no concuerden entre los dos nodos. 

Los parámetros que intervienen en la política cognitiva son modificables a través del archivo de preferencias. Por simplicidad se ha escogido este método de almacenamiento persistente, así como la restringir que sólo el proceso donde viene empaquetada la aplicación sea el único que tenga derechos de escritura.\\

El promedio tanto de la señal \ac{RSSI} como del intervalo medio entre mensajes de datos se realiza directamente en el \var{Repositorio} al lanzar una consulta que coge tantos registros como esté indicado en el archivo de preferencias y calcula su media. 

%------------------------------
\subsection{Cambios de contexto}
Los cambios de contexto usan protocolos, mensajes de red y otros procesos ya descritos tanto en este capítulo como en diseño.

Sin embargo para sincronizar el flujo descrito en diseño necesitamos de mensajes de red propios de cada interfaz:

\subsubsection{Cambio de contexto con interfaz destino Wi-Fi}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfWiFi(), contextChangeToWiFi(), SetupWifiInterface (asyncTask), mHandlerWF, scheduleTaskWifi(), sendEndSwitchMessage(), endContextualChange()
\end{files}
\end{codeInvolved}

El mensaje utilizado para que el nodo coordinador avise de un cambio de contexto hacia \wifi{} se refleja en la tabla~\ref{itm:switchToWifi} que es dirigido a todos los nodos.
 
\protobufTableInit{Estructura mensaje SWITCH hacia \wifi{}}   
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo.}
  \protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{SWITCH} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{SWITCH}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{toInterface}}{Valor \bsq{TO\_WIFI} del enumerado ``ToInterface''.}
				\protobufItem{\texttt{SSID}}{Una \String{} con el nombre de la red \wifi{} a la que se va a realizar el cambio.}
				\protobufItem{\texttt{BSSID}}{Una \String{} con la dirección MAC del punto de acceso para evitar cualquier equívoco.}
				\protobufItem{\texttt{ipCoordinator}}{Una \String{} con la dirección IP del nodo coordinador.}
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} SWITCH hacia \wifi{}}{switchToWifi}

La estructura de este mensaje que vemos en la tabla~\ref{itm:okSwitch} sirve para que el coordinador ponga en conocimiento del nodo normal que ha recibido su petición de entrada en la red.

\protobufTableInit[!h]{Estructura mensaje confirmación cambio de contexto}   
	\protobufItem{\texttt{type}}{Valor \bsq{RESPONSE} del enumerado ``MessageType''.}
  \protobufItem{Mensaje: \texttt{Response}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{what}}{Valor \bsq{SWITCH} del enumerado ``AskType''.}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} confirmación entrada (\wifi{}) / interfaz lista (\bt{})}{okSwitch}

\newpage %para ajustar el título a una nueva página.
\subsubsection{Cambio de contexto con interfaz destino Bluetooth}
\begin{codeInvolved}
\begin{files}
\textbf{Service}: coordinatorCognitiveTask(), mayTakeAdvantageOfBT(), contextChangeToBT(), SetupBTinterface (asyncTask), mHandlerBt,  tellBTisUP(), scheduleEndSwitchBTRunnable (future) scheduleSetupBTRunnable (future) , sendEndSwitchMessage(), endContextualChange()
\end{files}
\end{codeInvolved}

%En la tabla~\ref{itm:switchToBT} vemos 
La disposición del mensaje de señalización enviado para iniciar el cambio de contexto hacia \bt{} es el que sigue:

\protobufTableInit{Estructura mensaje SWITCH hacia \bt{}}   
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo.}
  \protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{SWITCH} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{SWITCH}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{toInterface}}{Valor \bsq{TO\_BT} del enumerado ``ToInterface''.}   
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} SWITCH hacia \bt{}}{switchToBT}

Para indicar que la interfaz \bt{} está lista para recibir conexiones entrantes reutilizamos el mensaje (ver tabla~\ref{itm:okSwitch}) visto en \wifi{} para indicar que queremos entrar en la red. Es legítimo usar el mismo pues ambas situaciones reflejan lo mismo: que el nodo normal esta listo en la nueva interfaz en la que desemboca el cambio de contexto.

%--------------------------
%\clearpage
\paragraph{}También necesitamos mensajes no vinculados a ninguna interfaz como el que se ilustra en la tabla~\ref{itm:endSwitch} utilizado para indicar el fin de cambio de contexto.\\

\protobufTableInit[!h]{Estructura mensaje fin cambio de contexto}   
	\protobufItem{\texttt{type}}{Valor \bsq{SIGNALING} del enumerado ``MessageType''.}
	\protobufItem{\texttt{from}}{Una \String{} con la dirección MAC de \bt{} del nodo (coordinador).}
  \protobufItem{Mensaje: \texttt{Signaling}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{signal}}{Valor \bsq{TOPOLOGY} del enumerado ``SignalType''.}
		\protobufItem{Mensaje: \texttt{Topology}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{signal}'':}
			\begin{description}
				\protobufItem{\texttt{change}}{Valor \bsq{ALL\_END\_SWITCH} del enumerado ``TopologyChange''.}
					\begin{description}
						\protobufItem{Mensaje: \texttt{Node}}{Mensaje con los cambios que sirven para representar al nodo (ver tabla~\ref{itm:infoNode}). Tendremos tantas representaciones como nodos haya en la red.}
					\end{description}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} finalización cambio de contexto}{endSwitch}

Los \textit{timeouts} utilizados para evitar bloqueos mutuos se implementan siguiendo el esquema de programación basado en \textit{Runnables} siguiendo las directrices de la interfaz \class[java.util.concurrent]{ScheduledFuture<V>} y ejecutados en hebras gestionadas por \class[java\allowbreak.util\allowbreak.concurrent]{Executor}

Al programar una tarea (el objeto \textit{Runnable}) con el objeto \textit{Executor} a través de su método \textit{schedule()} obtenemos una referencia a la interfaz \textit{Future}. Esta interfaz nos permite consultar si una tarea ha sido o no realizada y la cancelación de ésta.\\

Por último mencionar que la configuración de la interfaz, proceso que ya vimos, permite ser incluido en el flujo de cambio de contexto con unas pequeñas modificaciones. Esto ayuda a uniformar y no duplicar el código si los procesos comparten mucha semántica. Así tras pasar como parámetro si hemos de configurar la interfaz bien como consecuencia de un cambio de contexto o bien porque estamos en la situación inicial, podemos reutilizar la misma \textit{AsyncTask} encargada del levantamiento de la interfaz.

%-------------------------------------------------------------------
\section{Aplicación utilitaria servicio cognitivo}
\label{sec:appImpl}
%-------------------------------------------------------------------
La aplicación desarrollada se apoya en dos componentes \android{}: en la actividad (\var{\small App\allowbreak\_Activity}) y en la \textit{PreferenceActivity}~\cite{preferenceActivity} (\var{\small App\_Settings\_Activity}), siendo la clase \class{App\_Activity} la que vertebra toda la aplicación.\\

Esta clase extiende del componente \var{FragmentActivity} para permitir la compatibilidad hacia atrás hasta la versión 1.6 de \android{} de ciertas funciones, haciendo uso de la librería \textit{Support Library} \cite{androidSupportLib}. A efectos prácticos, actúa como cualquier actividad. Este componente hace de contenedor y lanza a otros elementos, centralizando la comunicación con la \bsq{capa cognitiva}. Los componentes que contiene son fragmentos (ver sección~\ref{subsubsec:fragments}).

En la figura~\ref{fig:appImpl} se ven los flujos de información intercambiados entre los distintos fragmentos, esta comunicación está representada con flecha discontinua debido a que como vimos, la actividad media en este intercambio.\\

\figura{Vectorial/implementation/app}{width=.76\textwidth}{fig:appImpl}{Diagrama de bloques de las secciones que componen la aplicación y su comunicación entre ellas}

En la figura vemos los componentes que dan sentido a las tres secciones descritas en diseño, las dos primeras están albergadas en la \var{App\_activity} que se componen de:

\begin{itemize}
	\item {\sc Service Controller} Es un fragmento que no tiene interfaz gráfica y que marcamos con la sentencia \textit{setRetainInstance(true);} como \bsq{no destruible} frente a cambios en la configuración (como puede ser un volteo de la pantalla, o un cambio del idioma\ldots) para no perder el vínculo con el servicio cognitivo. En él, se implementan los procesos de atadura y todas las comunicaciones de la \ac{API} del servicio. Este fragmento ubicado en la clase \class{App\_serviceController\_Fragment} da soporte a los demás componentes a través de la actividad que lo contiene, convirtiéndose en la puerta de entrada a la \bsq{capa cognitiva}.
 
	\item {\sc Monitor fragment} Monitoriza el estado del servicio: mostrando el estado de la conexión, la interfaz utilizada y el nombre del coordinador. La comunicación es unidireccional entre la clase \class{App\_monitor\_Fragment} y el fragmento que controla la comunicación con el servicio.

	\item {\sc Sensor fragment} Ubicamos en \class{App\_sensor\_Fragment} la simulación de un sensor. El fragmento extiende la clase \var{ListFragment} para presentar y manejar en pantalla un historial de mensajes recibidos y enviados. Junto a ello se presenta un formulario para introducir y enviar el valor del sensor. Necesitamos de una conexión bidireccional para en un sentido enviar el dato y en el otro recibir y actualizar la lista de nodos que se muestra.

	\item {\sc Test fragment} Este fragmento implementa por sí sólo (en conjunción con el fragmento \var{App\_serviceController\_Fragment}) la segunda sección, mientras que los arriba enumerados componen la primera sección que compone la funcionalidad principal de la aplicación. Dentro de este fragmento: \class{App\_testing\allowbreak\_fragment} se ubican otros dos que son cargados dinámicamente según el tipo de nodo que se trate:
	\begin{itemize}
		\item \class{App\_testing\_normal\_Fragment} ofrece una manera al usuario de guardar un valor en el servicio que será lo que envíe al recibir una petición de \textit{test}.
		\item \class{App\_testing\_coordinator\_Fragment} en caso de nodo coordinador permite seleccionar un nodo gracias a un \textit{spinner} modificado para que la acción de pulsar devuelva siempre un valor aunque sea el mismo que tenía seleccionado. Al interactuar con él, se lanzan los procesos de red necesarios para obtener el valor almacenado en el servicio del nodo remoto. El mensaje de red codificado para requerir esta respuesta es:

\protobufTableInit[!h]{Estructura mensaje petición información (\textit{test})}   
	\protobufItem{\texttt{type}}{Valor \bsq{REQUEST} del enumerado ``MessageType''.}
  \protobufItem{Mensaje: \texttt{Request}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{what}}{Valor \bsq{TEST} del enumerado ``AskType''.}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} petición de información (\textit{test})}{wa_ask_protoMessage}

Al recibir esta petición un nodo normal genera el mensaje % (ver tabla~\ref{itm:wa_ask_reply_protoMessage})
que envía por la red con la respuesta:

\protobufTableInit[!hb]{Estructura mensaje entrega de información (\textit{test})}   
	\protobufItem{\texttt{type}}{Valor \bsq{RESPONSE} del enumerado ``MessageType''.}
  \protobufItem{Mensaje: \texttt{Response}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{type}'':}
	\begin{description}
		\protobufItem{\texttt{what}}{Valor \bsq{TEST} del enumerado ``AskType''.}
		\protobufItem{Mensaje: \texttt{Test}}{Un contenedor que contiene al mensaje del tipo que se indicó en el campo ``\texttt{what}'':}
			\begin{description}
				\protobufItem{\texttt{responseField}}{Una \String{} con la respuesta requerida.}				
			\end{description}
	\end{description}
\protobufTableEnd{Campos del mensaje \msgNETcaption{} entrega de información (\textit{test})}{wa_ask_reply_protoMessage}


 En este fragmento también tenemos la opción del cambio de contexto manual.   
	\end{itemize}
Un detalle de implementación que cabe destacar de esta sección de \textit{test} es el envío periódico de datos del sensor. En vez de arrancar objetos pesados como una hebra o jugar con un \textit{timer} se ha decidido trabajar como trabaja \android{} que es mediante el envío de mensajes a colas del sistema, para ello:
	\begin{enumerate} 
		\item Creamos un objeto \textit{Handler} para obtener una cola y manejar mensajes.
		\item Con el método \textit{postDelayed()} mandamos un mensaje a la cola pasados los milisegundos que se indican como parámetro. El otro parámetro necesario es un objeto \textit{Runnable} donde definimos nuestra funcionalidad. Al final del método \textit{run()} mandamos otro mensaje a la cola pasándole como objeto \textit{Runnable} este mismo y el mismo retraso.
		\item Al transcurrir el periodo especificado el mensaje llega a la cola del sistema y se ejecuta el objeto \textit{Runnable} quien deja preparado otro mensaje en la cola para su posterior ejecución. Mediante una variable de control podemos dejar de programar el envío de mensajes a la cola, para finalizar el envío de datos de forma periódica.
	\end{enumerate}
Este esquema de programación, no introduce \textit{sleeps} ni bloqueos, se gestiona con un procedimiento nativo de \android{} lo que permite ser eficientes al no consumir casi recursos.
\end{itemize}

La tercera sección se ubica en su totalidad en la clase \class{App\allowbreak\_Settings\allowbreak\_Activity}, es un componente especializado para ubicar preferencias ya que muestra un \textit{layout} conveniente para mostrar una serie de valores con su descripción y maneja el archivo de preferencias donde se ubican éstas.

Esta sección es lanzada por la \var{App\_Activity} a través del menú. Se lanza con un \textit{Intent} que espera resultado, es decir cuando el usuario retorne de la configuración, \android{} informa al que lanzó este \textit{Intent} con un código de resultado:
\begin{center}
	\begin{tabular}{l c c}
	\hline%
	Constante & Valor & Máscara\\ \hline%
	\noalign{\vskip 0.17cm}
	\var{Activity.RESULT\_CANCELED} & \multicolumn{2}{c}{(definido por la plataforma)}\\ \hline%
	\var{RESULT\_UPDATE\_APP\_STUFF} & \bsq{1} & \phantom{000}1\\ \hline%
	\var{RESULT\_UPDATE\_SERVICE\_STUFF} & \bsq{2} & \phantom{00}10\\ \hline%
	\var{RESULT\_CHANGES\_MISC} & \bsq{4} & \phantom{0}100\\ \hline%
	\var{RESULT\_CHANGES\_TEST} & \bsq{8} & 1000 \\ \hline\hline%
\end{tabular}
\end{center}
En \var{App\_settingsActivity} vamos, de acuerdo a estas máscaras, modificando el valor a devolver. No se produce enmascaramiento del valor debido a que las máscaras son ortogonales entre sí. Al recibir el resultado en \var{App\_activity}, vamos pasando este valor por cada una de las máscaras descubriendo si ha habido algún cambio en cada sección: parámetros cognitivos, aplicación o servicio; preferencias o \textit{test}. 

Al acabar todos los filtros, los cambios ocurridos son evaluados y agrupados para transmitirlos al servicio con el menor número de mensajes. Hay cambios que sólo son a nivel aplicación como la carga dinámica de la sección de test o el borrado automático del valor del sensor al enviar el dato.

Estas máscaras permiten que si el usuario no hace nada (se devuelve un valor \bsq{0} que corresponde a \var{Activity.RESULT\_CANCELED}) no informar al servicio o si ha habido cambios, no tener que revisar toda la configuración para ver que ha cambiado y actuar en consecuencia, pues el valor devuelto nos indica dónde se ha producido el cambio.\\

En las siguientes páginas podemos ver capturas de pantalla de la aplicación desarrollada sobre el servicio cognitivo. Entre ellas podemos ver un ejemplo de intercambio de mensajes vista desde varios nodos de la red (figura~\ref{fig:app-data-session}) y cuando ocurren fallos en la entrega (figura~\ref{fig:app-failed-connection}). En otras capuras podemos ver la sección de configuración (figuras~\ref{fig:app-settings-coord},~\ref{fig:app-settings-policy} y~\ref{fig:app-settings-normal}), y por último la interfaz de \textit{test} (figuras~\ref{fig:app-test-coord} y~\ref{fig:app-test-normal}).


%2 imagenes en fila
\begin{figure}
	\begin{center}
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=0.5676\linewidth]{Imagenes/Bitmap/implementation/app-chat-denebola}%
		%\caption{Captura de pantalla, sesión \\vista bajo el nodo Denebola (coordinador)}%
	\end{minipage}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=0.5676\linewidth]{Imagenes/Bitmap/implementation/app-chat-regulus}%
		%\caption{Captura de pantalla, sesión vista bajo el nodo Regulus (nodo normal)}%
	\end{minipage}%

	\begin{tabularx}{\textwidth}{X X}%
			\centering\textit{(a)} Sesión vista bajo Denebola (nodo coordinador) & \centering\textit{(b)} Sesión vista bajo Regulus (nodo normal)%
		\end{tabularx}%
		\caption{Captura de pantalla sesión intercambio de datos en una CWSN}%
		\label{fig:app-data-session}%
	\end{center}
\end{figure}


%2 imagenes en fila
\begin{figure}
	\begin{center}
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=0.5676\linewidth]{Imagenes/Bitmap/implementation/app-nodes}%
		\caption{Captura de pantalla, lista \\ de nodos}%
		\label{fig:app-node-list}%
	\end{minipage}%
	\begin{minipage}[t]{.5\textwidth}%
		\centering%
		\includegraphics[width=0.5676\linewidth]{Imagenes/Bitmap/implementation/app-failed-connections}%
		\caption{Captura de pantalla, intercambio de mensajes fallidos en la entrega}%
		\label{fig:app-failed-connection}%
	\end{minipage}%
	\end{center}
\end{figure}


%4 imagenes agropadas de 2 en 2
\begin{figure}
	\begin{center}

	\begin{minipage}[t]{.45\textwidth}%
		\begin{minipage}[t]{.5\textwidth}%
			\centering%
			\includegraphics[width=.96\linewidth]{Imagenes/Bitmap/implementation/settings-top-coord}%
		\end{minipage}%
		\begin{minipage}[t]{.5\textwidth}%
			\centering%
			\includegraphics[width=.96\linewidth]{Imagenes/Bitmap/implementation/settings-bottom-coord}%
			%\caption{settings2}%
		\end{minipage}

		\begin{tabularx}{\textwidth}{X X}%
			\centering\textit{(a)} Parte superior & \centering\textit{(b)} Parte inferior%
		\end{tabularx}%
		\caption{Captura de pantalla configuración, nodo coordinador}%
		\label{fig:app-settings-coord}%
	\end{minipage}%
	\begin{minipage}[t]{.05\textwidth}%
	\hfill%separator
	\end{minipage}%
	\begin{minipage}[t]{.45\textwidth}%
		\begin{minipage}[t]{.5\textwidth}%
			\centering%
			\includegraphics[width=.96\linewidth]{Imagenes/Bitmap/implementation/settings-top-normal}%
		\end{minipage}%
		\begin{minipage}[t]{.5\textwidth}%
			\centering%
			\includegraphics[width=.96\linewidth]{Imagenes/Bitmap/implementation/settings-bottom-normal}%
			%\caption{settings2}%
		\end{minipage}

		\begin{tabularx}{\textwidth}{X X}%
			\centering\textit{(a)} Parte superior & \centering\textit{(b)} Parte inferior%
		\end{tabularx}%
		\caption{Captura de pantalla configuración, nodo normal}%
		\label{fig:app-settings-normal}%
	\end{minipage}%

	\end{center}
\end{figure}
%end


%3 imagenes en fila
\begin{figure}
	\begin{center}
	\begin{minipage}[t]{.33\textwidth}%
		\centering%
		\includegraphics[width=.86\linewidth]{Imagenes/Bitmap/implementation/test-gui-coord}%
		\caption{Captura de\\ pantalla, interfaz de \textit{test},\\ nodo coordinador}%
		\label{fig:app-test-coord}%
	\end{minipage}%
	\begin{minipage}[t]{.33\textwidth}%
		\centering%
		\includegraphics[width=.86\linewidth]{Imagenes/Bitmap/implementation/settings-policy}%
		\caption{Captura de\\ pantalla, parámetros\\ política cognitiva}%
		\label{fig:app-settings-policy}%
	\end{minipage}%
		\begin{minipage}[t]{.33\textwidth}%
		\centering%
		\includegraphics[width=.86\linewidth]{Imagenes/Bitmap/implementation/test-gui-normal}%
		\caption{Captura de\\ pantalla, interfaz de \textit{test},\\ nodo normal}%
		\label{fig:app-test-normal}%
	\end{minipage}%
	\end{center}
\end{figure}

%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo


% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
